<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法与数据结构系列(一)： 链表</title>
      <link href="/2019/01/27/suan-fa-yu-shu-ju-jie-gou-xi-lie-yi-lian-biao/"/>
      <url>/2019/01/27/suan-fa-yu-shu-ju-jie-gou-xi-lie-yi-lian-biao/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">名称：链表基本操作</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">版本：python3.6</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">日期：20190127</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    链表结构，节点类</span></span><br><span class="line"><span class="string">    单链表结构都有两个属性，一个存储自身的值，另一个指针指向下一个值</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UNorderList</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    创建一个无序链表,需要实现的操作有：</span></span><br><span class="line"><span class="string">    add(item) ,remove(item),search(item),isEmpty(),size（）,append(item)</span></span><br><span class="line"><span class="string">    index(item),insert(pos，item) ,pop() ,pop(pos) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        创建一个空链表</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.head = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        检查列表是否为空。它不需要参数，并返回布尔值。</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">return</span> self.head == <span class="keyword">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        向列表头部添加一个新项。它需要 item 作为参数，并不返回任何内容。假定该 item 不在列表中。</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        temp = ListNode(item) <span class="comment"># 创建节点</span></span><br><span class="line">        temp.next = self.head</span><br><span class="line">        self.head = temp</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        将一个新项添加到列表的末尾，使其成为集合中的最后一项。</span></span><br><span class="line"><span class="string">        它需要 item 作为参数，并不返回任何内容。假定该项不在列表中。</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        item = ListNode(item)</span><br><span class="line">        <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.head = item</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> cur.next != <span class="keyword">None</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            cur.next = item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        返回列表中的项数。它不需要参数，并返回一个整数。</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> cur == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">        <span class="keyword">while</span> cur.next != <span class="keyword">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> count+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">         搜索列表中的项目。它需要 item 作为参数，并返回一个布尔值。</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur.next != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> item == cur.value:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        prev = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> cur.next != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> item == cur.value:</span><br><span class="line">                <span class="keyword">if</span> prev == <span class="keyword">None</span>:</span><br><span class="line">                    self.head = self.head.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    prev.next = cur.next</span><br><span class="line">                    self.head = prev</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            prev = cur</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        返回项在列表中的位置。它需要 item 作为参数并返回索引。假定该项在列表中。</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur.next != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.value == item:</span><br><span class="line">                <span class="keyword">return</span> count</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self,pos,item)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        在位置 pos 处向列表中添加一个新项。它需要 item 作为参数并不返回任何内容。</span></span><br><span class="line"><span class="string">        假设该项不在列表中，并且有足够的现有项使其有 pos 的位置。</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        prev = <span class="keyword">None</span></span><br><span class="line">        item = ListNode(item)</span><br><span class="line">        <span class="keyword">while</span> cur.next != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> count == pos:</span><br><span class="line">                <span class="keyword">if</span> prev == <span class="keyword">None</span>:</span><br><span class="line">                    item.next = cur</span><br><span class="line">                    self.head = item</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    prev.next = item</span><br><span class="line">                    item.next = cur</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                prev = cur</span><br><span class="line">                cur = cur.next</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self,pos=None)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        删除并返回列表中的最后一个项。假设该列表至少有一个项。</span></span><br><span class="line"><span class="string">        删除并返回位置 pos 处的项。它需要 pos 作为参数并返回项。假定该项在列表中。</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        prev = <span class="keyword">None</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> cur.next != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> count == pos:</span><br><span class="line">                <span class="keyword">if</span> prev == <span class="keyword">None</span>:</span><br><span class="line">                    prev = cur</span><br><span class="line">                    cur = cur.next</span><br><span class="line">                    self.head = cur</span><br><span class="line">                    <span class="keyword">return</span> prev.value</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    prev.next = cur.next</span><br><span class="line">                    <span class="keyword">return</span> cur.value</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                prev = cur</span><br><span class="line">                cur = cur.next</span><br><span class="line">                count += <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">        prev.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> cur.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        反转链表</span></span><br><span class="line"><span class="string">        要点：后一个节点的next = 前一个节点</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        head = self.head</span><br><span class="line">        prev = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> head != <span class="keyword">None</span>:</span><br><span class="line">            temp = head.next</span><br><span class="line">            head.next = prev <span class="comment"># 关键步骤</span></span><br><span class="line">            prev = head</span><br><span class="line">            head = temp</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> prev</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    test_list = UNorderList()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        test_list.append(i)</span><br><span class="line"></span><br><span class="line">    print(test_list.reverse().value)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python3 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记-----Logistic回归</title>
      <link href="/2019/01/23/ji-qi-xue-xi-bi-ji-logistic-hui-gui/"/>
      <url>/2019/01/23/ji-qi-xue-xi-bi-ji-logistic-hui-gui/</url>
      
        <content type="html"><![CDATA[<p>Logistic回归,有翻译为“逻辑回归”，但是它跟“逻辑”这个单词一点关系都没有，也不是解决回归问题的，是用来解决二分类的算法，最准确的翻译应该是“对数几率回归”</p><p>至于为什么叫对数几率刚回归，请看下面的推倒过程</p><h2 id="线性回归回顾"><a href="#线性回归回顾" class="headerlink" title="线性回归回顾"></a>线性回归回顾</h2><p>先来看一个简单的线性回归模型：</p><script type="math/tex; mode=display">f(x) = \vec\omega^T \vec{x}+b</script><p>这里的</p><script type="math/tex; mode=display">\vec\omega^T = [\omega_1,\omega_2,\cdots,\omega_n]</script><script type="math/tex; mode=display">\vec x  = \left[\begin{matrix}x_1 \\x_2  \\\cdots\\x_n  \end{matrix} \right]</script><p>一般来说给定的数据集是：$D=\{(\vec x^{(1)},y^{(1)}),(\vec x^{(2)},y^{(2)}),⋯,(\vec x^{(m)},y^{(m)})\}$, 即有m组数据，n个未知数，因此多变量线性回归的公式是：</p><script type="math/tex; mode=display">f(x)= X^T \vec\omega</script><p>其中：</p><script type="math/tex; mode=display">X = \left[\begin{matrix}x_1^{(1)} \   x_2^{(1)} \ x_1^{(1)} \ \cdots \ x_n^{(1)} \ 1 \\x_1^{(2)} \   x_2^{(2)} \ x_3^{(2)} \ \cdots \ x_n^{(2)} \ 1 \\x_1^{(3)} \   x_2^{(3)} \ x_3^{(3)} \ \cdots \ x_n^{(3)} \ 1 \\\cdots \\x_1^{(m)} \   x_2^{(m)} \ x_3^{(m)} \ \cdots \ x_n^{(m)} \ 1 \end{matrix} \right] =  \left[\begin{matrix}\vec x^{(1)T} \ 1 \\\vec x^{(2)T} \ 1 \\\vec x^{(3)T} \ 1 \\\cdots \\\vec x^{(m)T} \ 1 \\\end{matrix} \right]</script><p>展开式：</p><script type="math/tex; mode=display">\omega_1 x_1^{(1)} + \omega_2 x_2^{(1)} + \cdots + \omega_n x_n^{(1)} +b = y^{(1)}</script><script type="math/tex; mode=display">\omega_1 x_1^{(2)} + \omega_2 x_2^{(2)} + \cdots + \omega_n x_n^{(2)} + b = y^{(2)}</script><script type="math/tex; mode=display">\cdots</script><script type="math/tex; mode=display">\omega_1 x_1^{(m)} + \omega_2 x_2^{(m)} + \cdots + \omega_n x_n^{(m)} +b = y^{(m)}</script><p>我们为了便于推导，忽略了下标，只用了一组$(\vec{x},y)$,然后把$b$当做$\omega_0$，而此时$x_0 = 1$：</p><script type="math/tex; mode=display">f(x)=\vec\omega^T \vec{x}</script><h2 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h2><p>线性回归很显然是一个连续的值，既然要解决二分类的问题，那最好是换成一个$0/1$的值</p><p>这里引出一个sigmoid函数：</p><script type="math/tex; mode=display">g(z) = \frac {1}{1+e^{-z}}</script><p><img src="/myphoto/logtic.png" alt="logtic"></p><p>令：</p><script type="math/tex; mode=display">z =\vec\omega^T \vec{x}+b</script><script type="math/tex; mode=display">f(x) = g(z) = \frac {1}{1+e^{-\vec\omega^T \vec{x}}}</script><p>我们就引出了我们的模型：</p><script type="math/tex; mode=display">ln \frac{y}{1-y} =  \vec\omega^T \vec{x}+b</script><p>上式中$\frac{y}{1-y}$ 称为几率，反应x获得正例(y)的相对可能性，由此可以看出，模型实际上是在用线性回归模型的预测结果去逼近真实值$y$的对数几率，因此该模型就称为<strong>对数几率回归模型</strong></p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>由于$y$的值为0,1，我们将$y$视为后验概率：</p><script type="math/tex; mode=display">p(y=1 |  x;\omega) = f(x)</script><script type="math/tex; mode=display">p(y=0 |  x;\omega) = 1- f(x)</script><p>$f(x)$越大，代表着预测值与$y$越接近，误差就越小，带入到公式中：</p><script type="math/tex; mode=display">p(y=1 |  x;\omega) = \frac {e^{\vec\omega^T \vec{x}}}{1+e^{\vec\omega^T \vec{x}}}</script><script type="math/tex; mode=display">p(y=0 |  x;\omega) = \frac {1}{1+e^{\vec\omega^T \vec{x}}}</script><p>为了确定$\omega$用对数似然函数：</p><script type="math/tex; mode=display">\ell(\omega) = lnp(y|x ;\omega)</script><p>可以合并到一起：</p><script type="math/tex; mode=display">p(y|x ;\omega) = f(x)^y(1-f(x))^{(1-y)}</script><p>带入到对数似然函数中：</p><script type="math/tex; mode=display">ln p(y|x ;\omega) = y lnf(x) + (1-y)ln(1-f(x))</script><p>我们得到的代价函数：</p><script type="math/tex; mode=display">J(\omega) = - \frac{1}{m} \sum_{i=1}^m [ y^{(i)} lnf(x^{(i)}) + (1-y^{(i)})ln(1-f(x^{(i)})) ]</script><p>$J(\omega)$越小，就说明$f(x) = 1$的概率越大，因此只要求出$J(\omega)$的<strong>最小值</strong></p><blockquote><p>ps：</p><p>1）其实正常推倒出来的J(w)是没有前面的负号的，这里为了习惯，用梯度下降法求最小值，所以加了一个负号</p><p>2） 之前推倒时候忽略了上标，但是我们在最后的损失函数中为了完整性就把上标加了上去</p></blockquote><h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><p>对代价函数求导的过程就不写了，直接写最后的结果:</p><script type="math/tex; mode=display">\frac{\partial J(\omega)}{\partial\omega_j} =\frac{1}{m} \sum_{i=1}^m (f(x^{(i)}) - y^{(i)})x_j^{(i)}</script><script type="math/tex; mode=display">\omega_{j+1} := \omega_j- \frac{1}{m}\alpha\sum_{i=1}^m(f(x^{(i)}) - y^{(i)})x_j^{(i)}</script><h2 id="sklearn代码实现逻辑回归"><a href="#sklearn代码实现逻辑回归" class="headerlink" title="sklearn代码实现逻辑回归"></a>sklearn代码实现逻辑回归</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dataset = pd.read_csv(<span class="string">r'E:\Downloads\100-Days-Of-ML-Code-master\Social_Network_Ads.csv'</span>)</span><br><span class="line">dataset.head(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = dataset.iloc[:,[<span class="number">2</span>,<span class="number">3</span>]].values</span><br><span class="line">Y = dataset.iloc[:,<span class="number">4</span>].values</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size = <span class="number">0.25</span>, random_state = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">sc = StandardScaler()</span><br><span class="line">X_train = sc.fit_transform(X_train)</span><br><span class="line">X_test = sc.transform(X_test)</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">classifier = LogisticRegression()</span><br><span class="line">classifier.fit(X_train, y_train)</span><br><span class="line"><span class="comment"># classifier.coef_</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y_pred = classifier.predict(X_test)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line">cm = confusion_matrix(y_test, y_pred)</span><br></pre></td></tr></table></figure><p>可视化</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">X_set,y_set=X_train,y_train</span><br><span class="line">X1,X2=np. meshgrid(np. arange(start=X_set[:,<span class="number">0</span>].min()<span class="number">-1</span>, stop=X_set[:, <span class="number">0</span>].max()+<span class="number">1</span>, step=<span class="number">0.01</span>),</span><br><span class="line">                   np. arange(start=X_set[:,<span class="number">1</span>].min()<span class="number">-1</span>, stop=X_set[:,<span class="number">1</span>].max()+<span class="number">1</span>, step=<span class="number">0.01</span>))</span><br><span class="line">plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(),X2.ravel()]).T).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>, cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(),X1.max())</span><br><span class="line">plt.ylim(X2.min(),X2.max())</span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> enumerate(np. unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set==j,<span class="number">0</span>],X_set[y_set==j,<span class="number">1</span>],</span><br><span class="line">                c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i), label=j)</span><br><span class="line"></span><br><span class="line">plt. title(<span class="string">' LOGISTIC(Training set)'</span>)</span><br><span class="line">plt. xlabel(<span class="string">' Age'</span>)</span><br><span class="line">plt. ylabel(<span class="string">' Estimated Salary'</span>)</span><br><span class="line">plt. legend()</span><br><span class="line">plt. show()</span><br><span class="line"></span><br><span class="line">X_set,y_set=X_test,y_test</span><br><span class="line">X1,X2=np. meshgrid(np. arange(start=X_set[:,<span class="number">0</span>].min()<span class="number">-1</span>, stop=X_set[:, <span class="number">0</span>].max()+<span class="number">1</span>, step=<span class="number">0.01</span>),</span><br><span class="line">                   np. arange(start=X_set[:,<span class="number">1</span>].min()<span class="number">-1</span>, stop=X_set[:,<span class="number">1</span>].max()+<span class="number">1</span>, step=<span class="number">0.01</span>))</span><br><span class="line"></span><br><span class="line">plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(),X2.ravel()]).T).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>, cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(),X1.max())</span><br><span class="line">plt.ylim(X2.min(),X2.max())</span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> enumerate(np. unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set==j,<span class="number">0</span>],X_set[y_set==j,<span class="number">1</span>],</span><br><span class="line">                c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i), label=j)</span><br><span class="line"></span><br><span class="line">plt. title(<span class="string">' LOGISTIC(Test set)'</span>)</span><br><span class="line">plt. xlabel(<span class="string">' Age'</span>)</span><br><span class="line">plt. ylabel(<span class="string">' Estimated Salary'</span>)</span><br><span class="line">plt. legend()</span><br><span class="line">plt. show()</span><br></pre></td></tr></table></figure><p><img src="/myphoto/output_12_0.png" alt="png"></p><p><img src="/myphoto/output_12_1.png" alt="png"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python3 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记-----线性回归</title>
      <link href="/2019/01/14/ji-qi-xue-xi-bi-ji-xian-xing-hui-gui/"/>
      <url>/2019/01/14/ji-qi-xue-xi-bi-ji-xian-xing-hui-gui/</url>
      
        <content type="html"><![CDATA[<h2 id="线性模型的基本形式"><a href="#线性模型的基本形式" class="headerlink" title="线性模型的基本形式"></a>线性模型的基本形式</h2><p>给定由d 个属性描述的示例$\vec x = (x_1,x_2,…x_d)$ ， 其中$x_i$是x 在第i个属性上的取值，线性模型(linear model)试图学得一个通过属性的线性组合来进行预测的函数，即:</p><script type="math/tex; mode=display">f(\vec x) = \omega_1 x_1 + \omega_2 x_2 +\cdots + \omega_d x_d+d + b  \tag{1}</script><p>写成向量式：</p><script type="math/tex; mode=display">f(\vec x ) = \vec\omega^T \vec x  +b \tag{2}</script><h2 id="线性回归原理"><a href="#线性回归原理" class="headerlink" title="线性回归原理"></a>线性回归原理</h2><p>给定数据集$D = \{(\vec x_1 ,y_1),(\vec x_2,y_2),\cdots,(\vec x_m,y_m)\}$,线性回归就是使用$\vec x$得到一个线性模型是的输出$y’$ 无限接近与$y$，即：</p><script type="math/tex; mode=display">f(\vec x ) = \vec\omega^T \vec x + b \simeq y \tag{3}</script><p>这里忽略了下标，即每一个输入$\vec x$ 通过线性回归模型的式子$(3)$得到的$y’$ 都无限接近与数据集中的$y$</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>那么如何确定公式$(3)$中的$\vec\omega$和$b$呢?</p><p>如果我们的$f(x)$ 与$y$的差别足够小，那么我们就可以带入到公式$(3)$中直接解出$\vec\omega$和$b$来:</p><script type="math/tex; mode=display">min\sum|f(x)-y|</script><p>而在实际运用过程中我们一般用平方误差来做性能度量：</p><script type="math/tex; mode=display">min \sum(f(x)-y)^2 \tag{4}</script><p>当然也有其他的性能度量方式，只是平方误差这个在线性回归中最常用，这个求解线性回归参数的方法也叫做<strong>最小二乘法</strong></p><p>令：</p><script type="math/tex; mode=display">E(w,b) = \sum(f(x)-y)^2 \tag{5}</script><p>$E(w,b)$在这里就叫做<strong>代价函数</strong>,吴恩达老师的机器学习课程中稍做了调整：</p><script type="math/tex; mode=display">E(w,b) = \frac{1}{2m} \sum_{i=1}^m (f(x)-y)^2 \tag{5}</script><p>我们只需要对$E(w,b)$求偏导就能够求得最小值，这里假设$E(w,b)$是<strong>凸函数</strong>：</p><script type="math/tex; mode=display">\frac{\partial E(\omega,b) }{\partial \omega} = 2(\omega \sum_{1=1}^m x_i^2 - \sum_{i=1}^m (y_i-b)x_i)</script><script type="math/tex; mode=display">\frac{\partial E(\omega,b) }{\partial b} = 2(mb - \sum_{i=1}^m (y_i-\omega x_i))</script><h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><p>在讲梯度下降法之前，我们先讲如何直接解出$E(\omega,b)$的最小值：</p><p><img src="/myphoto/ml1.png" alt="解方程"></p><p><img src="/myphoto/ml2.png" alt="解方程2"></p><p><img src="/myphoto/ml3.png" alt="解方程3"></p><p>显然这种方法比较复杂，貌似计算量也很大?</p><p>下面讲另一种求解$E$最小值的方式，<strong>梯度下降法</strong></p><p>该方法的核心思想是同步更新$\vec\omega,b$中每个值：</p><script type="math/tex; mode=display">\omega_i = \omega_i -\alpha \frac{\partial E }{\partial \omega_i} ,(i=1,2,...m)</script><p>$\alpha​$称作<strong>学习率</strong>,它的值太小会增加求解的时间，太大会容易造成过拟合。</p><p>该方法像是一种穷举，一步一步的找到最小值。</p><p>关于这种方法的实现我们将会在逻辑回归中演示，下面讲一下Scikit-Learn关于线性回归的用法。</p><h2 id="LinearRegression"><a href="#LinearRegression" class="headerlink" title="LinearRegression"></a>LinearRegression</h2><p>参考sklearn的官方文档中文版：<a href="http://cwiki.apachecn.org/pages/viewpage.action?pageId=12681716" target="_blank" rel="noopener">http://cwiki.apachecn.org/pages/viewpage.action?pageId=12681716</a></p><p><code>linear_model.LinearRegression</code>类的成员函数 <code>fit</code> 以数组X和y为输入，并将线性模型的系数$\omega$存储在其成员变量<code>coef_</code> 中：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reg = linear_model.LinearRegression()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reg.fit ([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>]], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">LinearRegression(copy_X=<span class="keyword">True</span>, fit_intercept=<span class="keyword">True</span>, n_jobs=<span class="number">1</span>, normalize=<span class="keyword">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reg.coef_</span><br><span class="line">array([ <span class="number">0.5</span>,  <span class="number">0.5</span>])</span><br></pre></td></tr></table></figure><blockquote><p>然而，最小二乘的系数估计依赖于模型特征项的独立性。当特征项相关并且设计矩阵X 的列近似的线性相关时，设计矩阵便接近于一个奇异矩阵(不是满秩，列数过多，会有多个最优解，需要<strong>正则化</strong>)，因此最小二乘估计对观测点中的随机误差变得高度敏感，产生大的方差。</p></blockquote><h2 id="造轮子"><a href="#造轮子" class="headerlink" title="造轮子"></a>造轮子</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleLR</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._a = <span class="keyword">None</span></span><br><span class="line">        self._b = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self,x_train,y_train)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x_train.ndim == <span class="number">1</span> <span class="keyword">and</span> len(x_train) == len(y_train):</span><br><span class="line">            self._a = (np.mean(x_train) * np.mean(y_train) - np.mean(x_train * y_train)) / \</span><br><span class="line">                      ((np.mean(x_train)**<span class="number">2</span>) - np.mean(x_train**<span class="number">2</span>))</span><br><span class="line">            self._b = np.mean(y_train) - self._a * np.mean(x_train)</span><br><span class="line">            print(self._a,self._b)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self,x_test)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x_test.ndim == <span class="number">1</span> <span class="keyword">and</span> self._a <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> self._b <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self._a * x_test + self._b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    rng = np.random.RandomState(<span class="number">1</span>)</span><br><span class="line">    x_train = <span class="number">10</span> * rng.rand(<span class="number">50</span>) <span class="comment"># 生成均匀分布的50个数</span></span><br><span class="line">    y_train = <span class="number">2</span> * x_train - <span class="number">5</span> + rng.randn(<span class="number">50</span>) <span class="comment"># randn是标准正太分布</span></span><br><span class="line">    x_test = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">1000</span>)</span><br><span class="line">    slr = SimpleLR()</span><br><span class="line">    slr.fit(x_train, y_train)</span><br><span class="line">    y = slr.predict(x_test)</span><br><span class="line">    <span class="comment"># 画图</span></span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    plt.scatter(x_train, y_train)</span><br><span class="line">    plt.plot(x_test,y)</span><br><span class="line">    plt.show()</span><br><span class="line">    fig.savefig(<span class="string">'fig.png'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.027208810360695 -4.998577085553202</span><br></pre></td></tr></table></figure></p><p>可见训练效果还是不错的</p><p><img src="/myphoto/liner_reg.png" alt="可视化"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python3 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 cookbook年度终极版(超长整理)</title>
      <link href="/2018/12/30/python3cookbook-nian-du-zhong-ji-ban-chao-chang-zheng-li/"/>
      <url>/2018/12/30/python3cookbook-nian-du-zhong-ji-ban-chao-chang-zheng-li/</url>
      
        <content type="html"><![CDATA[<h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><p><u>这次是对《python3 cookbook》的最终整理笔记，只是一个简短的对问题的回答，方便以后查阅，但其中的原理和扩展知识说的不是很详细，毕竟篇幅有限，所以还是需要去查资料、看文档。鉴于自己也是刚入门python，对书中的一些问题看的不是很明白，因此就出现了很多带有 “略”、“待补充的”字样，如果以后有机会接触到类似的问题，或者自己突然开窍就明白了其中的一些原理，会继续回来补充的</u></p><hr><hr><h2 id="第一章：数据结构和算法"><a href="#第一章：数据结构和算法" class="headerlink" title="第一章：数据结构和算法"></a>第一章：数据结构和算法</h2><h3 id="1-1-解压序列赋值给多个变量"><a href="#1-1-解压序列赋值给多个变量" class="headerlink" title="1.1 解压序列赋值给多个变量"></a>1.1 解压序列赋值给多个变量</h3><p><strong>Q:现在有一个包含N 个元素的元组或者是序列，怎样将它里面的值解压后同时赋值给N 个变量</strong></p><p>A: 元祖, 列表，或者其他可迭代对象都可以进行直接解压，并赋值，用 <code>_</code>,<code>*_</code> 占位并丢弃，</p><p>用 <code>*name</code>  可以解压成列表形式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = [ <span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.1</span>, (<span class="number">2012</span>, <span class="number">12</span>, <span class="number">21</span>) ]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_, shares, price, _ = data</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shares</span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>price</span><br><span class="line"><span class="number">91.1</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="1-2-解压可迭代对象赋值给多个变量"><a href="#1-2-解压可迭代对象赋值给多个变量" class="headerlink" title="1.2 解压可迭代对象赋值给多个变量"></a>1.2 解压可迭代对象赋值给多个变量</h3><p><strong>Q: 如果一个可迭代对象的元素个数超过变量个数时，会抛出一个ValueError 。那么怎样才能从这个可迭代对象中解压出N 个元素出来？</strong></p><p>A: 星号表达式可以用来收集那些不确定的变量:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>*trailing, current = [<span class="number">10</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>trailing</span><br><span class="line">[<span class="number">10</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>current</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="1-3-保留最后N-个元素"><a href="#1-3-保留最后N-个元素" class="headerlink" title="1.3 保留最后N 个元素"></a>1.3 保留最后N 个元素</h3><p><strong>Q: 在迭代操作或者其他操作的时候，怎样只保留最后有限几个元素的历史记录？</strong></p><p>A: <code>collections.deque</code>会构造函数会新建一个固定大小的队列。当新的元素加入并<br>且这个队列已满的时候，最老的元素会自动被移除掉。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = deque(maxlen=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q</span><br><span class="line">deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], maxlen=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q</span><br><span class="line">deque([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], maxlen=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q</span><br><span class="line">deque([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], maxlen=<span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p><em><code>collections.deque</code>构造的队列也支持在队列两头进行插入删除操作</em></p><h3 id="1-4-查找最大或最小的N-个元素"><a href="#1-4-查找最大或最小的N-个元素" class="headerlink" title="1.4 查找最大或最小的N 个元素"></a>1.4 查找最大或最小的N 个元素</h3><p><strong>Q: 怎样从一个集合中获得最大或者最小的N 个元素列表？</strong></p><p>A: <code>heapq</code> 模块有两个函数：<code>nlargest()</code> 和<code>nsmallest()</code> 可以完美解决这个问题。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">-4</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">37</span>, <span class="number">2</span>]</span><br><span class="line">print(heapq.nlargest(<span class="number">3</span>, nums)) <span class="comment"># Prints [42, 37, 23]</span></span><br><span class="line">print(heapq.nsmallest(<span class="number">3</span>, nums)) <span class="comment"># Prints [-4, 1, 2]</span></span><br></pre></td></tr></table></figure><p>也可以接收关键字参数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">portfolio = [</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'IBM'</span>, <span class="string">'shares'</span>: <span class="number">100</span>, <span class="string">'price'</span>: <span class="number">91.1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'AAPL'</span>, <span class="string">'shares'</span>: <span class="number">50</span>, <span class="string">'price'</span>: <span class="number">543.22</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'FB'</span>, <span class="string">'shares'</span>: <span class="number">200</span>, <span class="string">'price'</span>: <span class="number">21.09</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'HPQ'</span>, <span class="string">'shares'</span>: <span class="number">35</span>, <span class="string">'price'</span>: <span class="number">31.75</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'YHOO'</span>, <span class="string">'shares'</span>: <span class="number">45</span>, <span class="string">'price'</span>: <span class="number">16.35</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'ACME'</span>, <span class="string">'shares'</span>: <span class="number">75</span>, <span class="string">'price'</span>: <span class="number">115.65</span>&#125;</span><br><span class="line">]</span><br><span class="line">cheap = heapq.nsmallest(<span class="number">3</span>, portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">'price'</span>])</span><br><span class="line">expensive = heapq.nlargest(<span class="number">3</span>, portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">'price'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面代码在对每个元素进行对比的时候，会以price 的值进行比较</span></span><br></pre></td></tr></table></figure><h3 id="1-5-实现一个优先级队列"><a href="#1-5-实现一个优先级队列" class="headerlink" title="1.5 实现一个优先级队列"></a>1.5 实现一个优先级队列</h3><p><strong>Q:怎样实现一个按优先级排序的队列？并且在这个队列上面每次pop 操作总是返回优先级最高的那个元素</strong></p><p>A: 利用heapq 模块可是实现一个简单的优先级队列:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._queue = []</span><br><span class="line">        self._index = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item, priority)</span>:</span></span><br><span class="line">        heapq.heappush(self._queue, (-priority, self._index, item))</span><br><span class="line">        self._index += <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> heapq.heappop(self._queue)[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Item</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.name = name</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'Item(&#123;!r&#125;)'</span>.format(self.name)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = PriorityQueue()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.push(Item(<span class="string">'foo'</span>), <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.push(Item(<span class="string">'bar'</span>), <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.push(Item(<span class="string">'spam'</span>), <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.push(Item(<span class="string">'grok'</span>), <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.pop()</span><br><span class="line">Item(<span class="string">'bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.pop()</span><br><span class="line">Item(<span class="string">'spam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.pop()</span><br><span class="line">Item(<span class="string">'foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.pop()</span><br><span class="line">Item(<span class="string">'grok'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="1-6-字典中的键映射多个值"><a href="#1-6-字典中的键映射多个值" class="headerlink" title="1.6 字典中的键映射多个值"></a>1.6 字典中的键映射多个值</h3><p><strong>Q: 怎样实现一个键对应多个值的字典（也叫multidict）？</strong></p><p>A:这其实也就是字典与列表的嵌套，有三种方式实现： 一是自己创建，二是用<code>collections.defaultdict</code>，最后一种是用<code>setdefault</code> : </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> pairs:</span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">        d[key] = []</span><br><span class="line">    d[key].append(value)</span><br></pre></td></tr></table></figure><p><code>defaultdict</code> 会自动为将要访问的键（就算目前字典中并不存在这样的键）创建映射实体:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">d = defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> pairs:</span><br><span class="line">    d[key].append(value)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;&#125; <span class="comment"># A regular dictionary</span></span><br><span class="line">d.setdefault(<span class="string">'a'</span>, []).append(<span class="number">1</span>)</span><br><span class="line">d.setdefault(<span class="string">'a'</span>, []).append(<span class="number">2</span>)</span><br><span class="line">d.setdefault(<span class="string">'b'</span>, []).append(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3 id="1-7-字典排序"><a href="#1-7-字典排序" class="headerlink" title="1.7 字典排序"></a>1.7 字典排序</h3><p><strong>Q: 你想创建一个字典，并且在迭代或序列化这个字典的时候能够控制元素的顺序</strong></p><p>A: 字典默认是不排序的，所以每次遍历输出的键顺序是不一样的，而<code>collections.OrderedDict</code>会创建一个键顺序固定的字典：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">d = OrderedDict()</span><br><span class="line">d[<span class="string">'foo'</span>] = <span class="number">1</span></span><br><span class="line">d[<span class="string">'bar'</span>] = <span class="number">2</span></span><br><span class="line">d[<span class="string">'spam'</span>] = <span class="number">3</span></span><br><span class="line">d[<span class="string">'grok'</span>] = <span class="number">4</span></span><br><span class="line"><span class="comment"># Outputs "foo 1", "bar 2", "spam 3", "grok 4"</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">    print(key, d[key])`</span><br></pre></td></tr></table></figure><h3 id="1-8-字典的运算"><a href="#1-8-字典的运算" class="headerlink" title="1.8 字典的运算"></a>1.8 字典的运算</h3><p><strong>Q: 怎样在数据字典中执行一些计算操作（比如求最小值、最大值、排序等等）？</strong></p><p>A: <code>zip()</code>函数可以将字典的键与值反转，然后我们可以愉快的进行排序，求最值等操作了：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>prices = &#123;</span><br><span class="line"><span class="meta">... </span><span class="string">'ACME'</span>: <span class="number">45.23</span>,</span><br><span class="line"><span class="meta">... </span><span class="string">'AAPL'</span>: <span class="number">612.78</span>,</span><br><span class="line"><span class="meta">... </span><span class="string">'IBM'</span>: <span class="number">205.55</span>,</span><br><span class="line"><span class="meta">... </span><span class="string">'HPQ'</span>: <span class="number">37.20</span>,</span><br><span class="line"><span class="meta">... </span><span class="string">'FB'</span>: <span class="number">10.75</span></span><br><span class="line"><span class="meta">... </span>&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zip(prices.values(), prices.keys())</span><br><span class="line">&lt;zip object at <span class="number">0x7fdfae678548</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min(zip(prices.values(), prices.keys()))</span><br><span class="line">(<span class="number">10.75</span>, <span class="string">'FB'</span>)</span><br></pre></td></tr></table></figure><h3 id="1-9-查找两字典的相同点"><a href="#1-9-查找两字典的相同点" class="headerlink" title="1.9 查找两字典的相同点"></a>1.9 查找两字典的相同点</h3><p><strong>Q: 怎样在两个字典中寻找相同点（比如相同的键、相同的值等等）？</strong></p><p>A: 其实就是两个列表的运算：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;</span><br><span class="line"><span class="meta">... </span><span class="string">'x'</span> : <span class="number">1</span>,</span><br><span class="line"><span class="meta">... </span><span class="string">'y'</span> : <span class="number">2</span>,</span><br><span class="line"><span class="meta">... </span><span class="string">'z'</span> : <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = &#123;</span><br><span class="line"><span class="meta">... </span><span class="string">'w'</span> : <span class="number">10</span>,</span><br><span class="line"><span class="meta">... </span><span class="string">'x'</span> : <span class="number">11</span>,</span><br><span class="line"><span class="meta">... </span><span class="string">'y'</span> : <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.keys() &amp; b.keys()</span><br><span class="line">&#123;<span class="string">'x'</span>, <span class="string">'y'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.keys() - b.keys()</span><br><span class="line">&#123;<span class="string">'z'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.keys() - a.keys()</span><br><span class="line">&#123;<span class="string">'w'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.items() &amp; b.items()</span><br><span class="line">&#123;(<span class="string">'y'</span>, <span class="number">2</span>)&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="1-10-删除序列相同元素并保持顺序"><a href="#1-10-删除序列相同元素并保持顺序" class="headerlink" title="1.10 删除序列相同元素并保持顺序"></a>1.10 删除序列相同元素并保持顺序</h3><p><strong>Q: 怎样在一个序列上面保持元素顺序的同时消除重复的值？</strong></p><p>A: 大家首先想到的方法是<code>ser()</code>，但是这种方法不能维护元素的顺序，其实方法有很多中，可以构建一个键位固定的字典(<code>OrderedDict</code>),也可对``set()稍作调整：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dedupe</span><span class="params">(items)</span>:</span></span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">        <span class="keyword">yield</span> item</span><br><span class="line">        seen.add(item)</span><br></pre></td></tr></table></figure><h3 id="1-11-命名切片"><a href="#1-11-命名切片" class="headerlink" title="1.11 命名切片"></a>1.11 命名切片</h3><p><strong>Q: 你的程序已经出现一大堆已无法直视的硬编码切片下标，然后你想清理下代码。</strong></p><p>A: <code>slice()</code>方法可以对切片进行命名，而避免用一大堆难以阅读的下标进行运算：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = slice(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="1-12-序列中出现次数最多的元素"><a href="#1-12-序列中出现次数最多的元素" class="headerlink" title="1.12 序列中出现次数最多的元素"></a>1.12 序列中出现次数最多的元素</h3><p><strong>Q:怎样找出序列中出现次数最多的元素呢？</strong></p><p>A: <code>collecttions.Counter</code>类中的<code>most_common</code>就可以直接给出答案，当然你也可以手动计数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w = Counter(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w</span><br><span class="line">Counter(&#123;<span class="number">6</span>: <span class="number">4</span>, <span class="number">1</span>: <span class="number">3</span>, <span class="number">2</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment"># 出现频率最高的1个数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w.most_common(<span class="number">1</span>)</span><br><span class="line">[(<span class="number">6</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="comment"># 出现频率最高的两个数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w.most_common(<span class="number">2</span>)</span><br><span class="line">[(<span class="number">6</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">3</span>)]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="1-13-通过某个关键字排序一个字典列表"><a href="#1-13-通过某个关键字排序一个字典列表" class="headerlink" title="1.13 通过某个关键字排序一个字典列表"></a>1.13 通过某个关键字排序一个字典列表</h3><p><strong>Q:你有一个字典列表，你想根据某个或某届字典字段来排序这个列表</strong></p><p>A: <code>operator</code> 模块的<code>itemgetter</code> 函数可以生成一个<strong>callable</strong>对象，当作关键字传入到<code>sorted</code>函数中：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rows = [</span><br><span class="line">&#123;<span class="string">'fname'</span>: <span class="string">'Brian'</span>, <span class="string">'lname'</span>: <span class="string">'Jones'</span>, <span class="string">'uid'</span>: <span class="number">1003</span>&#125;,</span><br><span class="line">&#123;<span class="string">'fname'</span>: <span class="string">'David'</span>, <span class="string">'lname'</span>: <span class="string">'Beazley'</span>, <span class="string">'uid'</span>: <span class="number">1002</span>&#125;,</span><br><span class="line">&#123;<span class="string">'fname'</span>: <span class="string">'John'</span>, <span class="string">'lname'</span>: <span class="string">'Cleese'</span>, <span class="string">'uid'</span>: <span class="number">1001</span>&#125;,</span><br><span class="line">&#123;<span class="string">'fname'</span>: <span class="string">'Big'</span>, <span class="string">'lname'</span>: <span class="string">'Jones'</span>, <span class="string">'uid'</span>: <span class="number">1004</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line">rows_by_fname = sorted(rows, key=itemgetter(<span class="string">'fname'</span>))</span><br><span class="line">rows_by_uid = sorted(rows, key=itemgetter(<span class="string">'uid'</span>))</span><br><span class="line">print(rows_by_fname)</span><br><span class="line">print(rows_by_uid)</span><br></pre></td></tr></table></figure><h3 id="1-14-排序不支持原生比较的对象"><a href="#1-14-排序不支持原生比较的对象" class="headerlink" title="1.14 排序不支持原生比较的对象"></a>1.14 排序不支持原生比较的对象</h3><p><strong>Q: 你想排序类型相同的对象，但是他们不支持原生的比较操作。</strong></p><p>A: 内置的<code>sorted</code>是值可以传入<strong>callable</strong>对象，传入其他的对象就需要用<code>operator.attrgetter()</code> 或者<code>lamba</code>来构造，示例略</p><h3 id="1-15-通过某个字段将记录分组"><a href="#1-15-通过某个字段将记录分组" class="headerlink" title="1.15 通过某个字段将记录分组"></a>1.15 通过某个字段将记录分组</h3><p><strong>Q: 个字典或者实例的序列，然后你想根据某个特定的字段比如date 来分组迭代访问。</strong></p><p>A: 用<code>itertools.groupby()</code>函数, 使用之前要先排序，示例略</p><h3 id="1-16-过滤序列元素"><a href="#1-16-过滤序列元素" class="headerlink" title="1.16 过滤序列元素"></a>1.16 过滤序列元素</h3><p><strong>Q: 个数据序列，想利用一些规则从中提取出需要的值或者是缩短序列</strong></p><p>A: 最简单的方法就是列表推倒，也可以直接迭代，这里要说的另外的方法就是<code>filter()</code>函数，它接收一个函数和要过滤的列表，接受的函数可以定义过滤规则，另外一个值得关注的过滤工具就是<code>tertools.compress()</code>, 用法也差不多：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">values = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'-3'</span>, <span class="string">'-'</span>, <span class="string">'4'</span>, <span class="string">'N/A'</span>, <span class="string">'5'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_int</span><span class="params">(val)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = int(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">ivals = list(filter(is_int, values))</span><br><span class="line">print(ivals)</span><br><span class="line"><span class="comment"># Outputs ['1', '2', '-3', '4', '5']</span></span><br></pre></td></tr></table></figure><h3 id="1-17-从字典中提取子集"><a href="#1-17-从字典中提取子集" class="headerlink" title="1.17 从字典中提取子集"></a>1.17 从字典中提取子集</h3><p><strong>Q:构造一个字典，它是另外一个字典的子集。</strong></p><p>A: 字典推倒，示例略</p><h3 id="1-18-映射名称到序列元素"><a href="#1-18-映射名称到序列元素" class="headerlink" title="1.18 映射名称到序列元素"></a>1.18 映射名称到序列元素</h3><p><strong>Q: 段通过下标访问列表或者元组中元素的代码，但是这样有时候会使得你的代码难以阅读，于是你想通过名称来访问元素。</strong></p><p>A:  使用<code>collections.namedtuple()</code>函数来对元组进行命名：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Subscriber = namedtuple(<span class="string">'Subscriber'</span>, [<span class="string">'addr'</span>, <span class="string">'joined'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sub = Subscriber(<span class="string">'jonesy@example.com'</span>, <span class="string">'2012-10-19'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sub</span><br><span class="line">Subscriber(addr=<span class="string">'jonesy@example.com'</span>, joined=<span class="string">'2012-10-19'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sub.addr</span><br><span class="line"><span class="string">'jonesy@example.com'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sub.joined</span><br><span class="line"><span class="string">'2012-10-19'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="1-19-转换并同时计算数据"><a href="#1-19-转换并同时计算数据" class="headerlink" title="1.19 转换并同时计算数据"></a>1.19 转换并同时计算数据</h3><p><strong>Q: 在数据序列上执行聚集函数（比如sum() , min() , max() ），但是首先你需<br>要先转换或者过滤数据</strong></p><p>A: 一般来讲，我们都是先进行过滤再进行计算，但是python为了是语法更简洁，可以允许我们省略中间的临时列表：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">s = sum((x * x <span class="keyword">for</span> x <span class="keyword">in</span> nums)) <span class="comment"># 显示的传递一个生成器表达式对象</span></span><br><span class="line">s = sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> nums) <span class="comment"># 更加优雅的实现方式，省略了括号</span></span><br></pre></td></tr></table></figure><h3 id="1-20-合并多个字典或映射"><a href="#1-20-合并多个字典或映射" class="headerlink" title="1.20 合并多个字典或映射"></a>1.20 合并多个字典或映射</h3><p><strong>Q: 多个字典或者映射，你想将它们从逻辑上合并为一个单一的映射后执行某些操作，比如查找值或者检查某些键是否存在。</strong></p><p>A: <code>llections</code>模块中的<code>CainMap</code>类可以讲两个字典在逻辑上和为一个字典：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'z'</span>: <span class="number">3</span> &#125;</span><br><span class="line">b = &#123;<span class="string">'y'</span>: <span class="number">2</span>, <span class="string">'z'</span>: <span class="number">4</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line"></span><br><span class="line">c = ChainMap(a,b)</span><br><span class="line">print(c[<span class="string">'x'</span>]) <span class="comment"># Outputs 1 (from a)</span></span><br><span class="line">print(c[<span class="string">'y'</span>]) <span class="comment"># Outputs 2 (from b)</span></span><br><span class="line">print(c[<span class="string">'z'</span>]) <span class="comment"># Outputs 3 (from a)  若有重复值那么只输出一个的值</span></span><br></pre></td></tr></table></figure><hr><hr><h2 id="第二章：字符串和文本"><a href="#第二章：字符串和文本" class="headerlink" title="第二章：字符串和文本"></a>第二章：字符串和文本</h2><h3 id="2-1-使用多个界定符分割字符串"><a href="#2-1-使用多个界定符分割字符串" class="headerlink" title="2.1 使用多个界定符分割字符串"></a>2.1 使用多个界定符分割字符串</h3><p><strong>Q: 你需要将一个字符串分割为多个字段，但是分隔符(还有周围的空格) 并不是固定的。</strong></p><p>A: 用<code>re.split</code>, 因为<code>str.split</code>并不允许多个分隔符：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>line = <span class="string">'asdf fjdk; afed, fjek,asdf, foo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'[;,\s]\s*'</span>, line)</span><br><span class="line">[<span class="string">'asdf'</span>, <span class="string">'fjdk'</span>, <span class="string">'afed'</span>, <span class="string">'fjek'</span>, <span class="string">'asdf'</span>, <span class="string">'foo'</span>]</span><br><span class="line"><span class="comment"># 如果有捕获分组的话，如果捕获到了也会输出</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fields = re.split(<span class="string">r'(;|,|\s)\s*'</span>, line)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fields</span><br><span class="line">[<span class="string">'asdf'</span>, <span class="string">' '</span>, <span class="string">'fjdk'</span>, <span class="string">';'</span>, <span class="string">'afed'</span>, <span class="string">','</span>, <span class="string">'fjek'</span>, <span class="string">','</span>, <span class="string">'asdf'</span>, <span class="string">','</span>, <span class="string">'foo'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="comment"># 形如(?:....) 就不会输出捕获的分组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'(?:,|;|\s)\s*'</span>, line)</span><br><span class="line">[<span class="string">'asdf'</span>, <span class="string">'fjdk'</span>, <span class="string">'afed'</span>, <span class="string">'fjek'</span>, <span class="string">'asdf'</span>, <span class="string">'foo'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="2-2-字符串开头或结尾匹配"><a href="#2-2-字符串开头或结尾匹配" class="headerlink" title="2.2 字符串开头或结尾匹配"></a>2.2 字符串开头或结尾匹配</h3><p><strong>Q: 你需要通过指定的文本模式去检查字符串的开头或者结尾，比如文件名后缀，URLScheme 等等。</strong></p><p>A: 参考<code>startswith()</code> 和<code>endswith()</code> 方法,当然也可以用正则表达式或者对字符串进行切片</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>filename = <span class="string">'spam.txt'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>filename.endswith(<span class="string">'.txt'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>filename.startswith(<span class="string">'file:'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://www.python.org'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>url.startswith(<span class="string">'http:'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>也可以接收以元祖作为参数</p><h3 id="2-3-用Shell-通配符匹配字符串"><a href="#2-3-用Shell-通配符匹配字符串" class="headerlink" title="2.3 用Shell 通配符匹配字符串"></a>2.3 用Shell 通配符匹配字符串</h3><p><strong>A: 你想使用Unix Shell 中常用的通配符(比如<code>*.py</code> , <code>Dat[0-9]*.csv</code> 等) 去匹配文本字符串</strong></p><p>A: 参见<code>fnmatch</code> 模块提供的两个函数——<code>fnmatch()</code> 和<code>fnmatchcase()</code>，示例略</p><h3 id="2-4-字符串匹配和搜索"><a href="#2-4-字符串匹配和搜索" class="headerlink" title="2.4 字符串匹配和搜索"></a>2.4 字符串匹配和搜索</h3><p><strong>Q: 你想匹配或者搜索特定模式的文本</strong></p><p>A: 正则表达式</p><h3 id="2-5-字符串搜索和替换"><a href="#2-5-字符串搜索和替换" class="headerlink" title="2.5 字符串搜索和替换"></a>2.5 字符串搜索和替换</h3><p><strong>Q: 你想在字符串中搜索和匹配指定的文本模式</strong></p><p>A: <code>str.replace()</code> ,<code>re.sub()</code>:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">'Today is 11/27/2012. PyCon starts 3/13/2013.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r'(\d+)/(\d+)/(\d+)'</span>, <span class="string">r'\3-\1-\2'</span>, text)</span><br><span class="line"><span class="string">'Today is 2012-11-27. PyCon starts 2013-3-13.'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p><code>sub()</code> 函数中的第一个参数是被匹配的模式，第二个参数是替换模式。反斜杠数字比如”\3” 指向前面模式的<strong>捕获组号</strong>。</p><h3 id="2-6-字符串忽略大小写的搜索替换"><a href="#2-6-字符串忽略大小写的搜索替换" class="headerlink" title="2.6 字符串忽略大小写的搜索替换"></a>2.6 字符串忽略大小写的搜索替换</h3><p><strong>Q: 你需要以忽略大小写的方式搜索与替换文本字符串</strong></p><p>A: 在正则表达式中使用<code>re.IGNORECASE</code>参数</p><h3 id="2-7-最短匹配模式"><a href="#2-7-最短匹配模式" class="headerlink" title="2.7 最短匹配模式"></a>2.7 最短匹配模式</h3><p><strong>Q: 你正在试着用正则表达式匹配某个文本模式，但是它找到的是模式的最长可能匹配。而你想修改它变成查找最短的可能匹配。</strong></p><p>A: 使用<code>?</code>进行非贪婪匹配：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text2 = <span class="string">'Computer says "no." Phone says "yes."'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_pat.findall(text2)</span><br><span class="line">[<span class="string">'no." Phone says "yes.'</span>]</span><br><span class="line"><span class="comment"># 非贪婪匹配</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_pat = re.compile(<span class="string">r'\"(.*?)\"'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_pat.findall(text2)</span><br><span class="line">[<span class="string">'no.'</span>, <span class="string">'yes.'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="2-8-多行匹配模式"><a href="#2-8-多行匹配模式" class="headerlink" title="2.8 多行匹配模式"></a>2.8 多行匹配模式</h3><p><strong>Q: 你正在试着使用正则表达式去匹配一大块的文本，而你需要跨越多行去匹配。</strong></p><p>A: 使用<code>re.DOTALL</code>参数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'''hello</span></span><br><span class="line"><span class="string"><span class="meta">... </span>world'''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">'hello\nworld'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">'(o.*)'</span>,a,re.DOTALL).group(<span class="number">1</span>)</span><br><span class="line"><span class="string">'o\nworld'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="2-9-将Unicode-文本标准化"><a href="#2-9-将Unicode-文本标准化" class="headerlink" title="2.9 将Unicode 文本标准化"></a>2.9 将Unicode 文本标准化</h3><p><strong>Q: 你正在处理Unicode 字符串，需要确保所有字符串在底层有相同的表示。</strong></p><p>A: 在Unicode 中，某些字符能够用多个合法的编码表示,所以有些字符在编码字节是不同的，但是在显示的时候却是一样的，这种情况可以用<code>unicodedata</code> 模块先将文本标准化</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="string">'Spicy Jalape\u00f1o'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">'Spicy Jalapen\u0303o'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1</span><br><span class="line"><span class="string">'Spicy Jalapeño'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2</span><br><span class="line"><span class="string">'Spicy Jalapeño'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 == s2</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="comment">####</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> unicodedata</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = unicodedata.normalize(<span class="string">'NFC'</span>, s1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = unicodedata.normalize(<span class="string">'NFC'</span>, s2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 == t2</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>关于<code>unicodedata</code> 模块的其他用法请参考官方文档</p><h3 id="2-10-在正则式中使用Unicode"><a href="#2-10-在正则式中使用Unicode" class="headerlink" title="2.10 在正则式中使用Unicode"></a>2.10 在正则式中使用Unicode</h3><p><strong>Q:你正在使用正则表达式处理文本，但是关注的是Unicode 字符处理。</strong></p><p>A: <code>re</code>模块支持Unicode 字符，直接用就好：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pat = re.compile(<span class="string">'stra\u00dfe'</span>, re.IGNORECASE)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'straße'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pat.match(s) <span class="comment"># Matches</span></span><br><span class="line">&lt;_sre.SRE_Match object at <span class="number">0x10069d370</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pat.match(s.upper()) <span class="comment"># Doesn't match</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.upper() <span class="comment"># Case folds</span></span><br><span class="line"><span class="string">'STRASSE'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="2-11-删除字符串中不需要的字符"><a href="#2-11-删除字符串中不需要的字符" class="headerlink" title="2.11 删除字符串中不需要的字符"></a>2.11 删除字符串中不需要的字符</h3><p><strong>Q: 你想去掉文本字符串开头，结尾或者中间不想要的字符，比如空白</strong></p><p>A: <code>strip()</code> 方法能用于删除开始或结尾的字符。<code>lstrip()</code> 和<code>rstrip()</code> 分别从左和从右执行删除操作。默认情况下，这些方法会去除空白字符，但是你也可以指定其他字符。<br>当然也可以使用正则表达式</p><h3 id="2-12-审查清理文本字符串"><a href="#2-12-审查清理文本字符串" class="headerlink" title="2.12 审查清理文本字符串"></a>2.12 审查清理文本字符串</h3><p><strong>Q: 一些无聊的幼稚黑客在你的网站页面表单中输入文本”pýtĥöñ”，然后你想将这些字符清理掉。</strong></p><p>A: 解决的思路就是用<code>str.upper()</code> 和<code>str.lower()</code>将字符串标准化，使用<code>str.replace()</code> 或者<code>re.sub()</code><br>对字符串进行删除或者替换，问题中的文本 “pýtĥöñ” 则可以用<code>unicodedata.normalize()</code> 函数将unicode文本标准化。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">'pýtĥöñ is awesome\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = unicodedata.normalize(<span class="string">'NFD'</span>, a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.encode(<span class="string">'ascii'</span>, <span class="string">'ignore'</span>).decode(<span class="string">'ascii'</span>)</span><br><span class="line"><span class="string">'python is awesome\n'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>另外再介绍一下经常会被忽视的<code>str.translate()</code>方法:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'pýtĥöñ\fis\tawesome\r\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'pýtĥöñ\x0cis\tawesome\r\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>remap = &#123;</span><br><span class="line"><span class="meta">... </span>ord(<span class="string">'\t'</span>) : <span class="string">' '</span>, <span class="comment"># 将特殊字符重新映射为空格</span></span><br><span class="line"><span class="meta">... </span>ord(<span class="string">'\f'</span>) : <span class="string">' '</span>,</span><br><span class="line"><span class="meta">... </span>ord(<span class="string">'\r'</span>) : <span class="keyword">None</span> <span class="comment"># 删除</span></span><br><span class="line"><span class="meta">... </span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = s.translate(remap)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">'pýtĥöñ is awesome\n'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="2-13-字符串对齐"><a href="#2-13-字符串对齐" class="headerlink" title="2.13 字符串对齐"></a>2.13 字符串对齐</h3><p><strong>Q: 你想通过某种对齐方式来格式化字符串</strong></p><p>A: 可以使用字符串的<code>ljust()</code> , <code>rjust()</code> 和<code>center()</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">'Hello World'</span></span><br><span class="line"><span class="comment"># 默认是空格，也可以接收其他字符</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.ljust(<span class="number">20</span>)</span><br><span class="line"><span class="string">' Hello World            '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.rjust(<span class="number">20</span>)</span><br><span class="line"><span class="string">'            Hello World '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.center(<span class="number">20</span>)</span><br><span class="line"><span class="string">'       Hello World      '</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>还有就是<code>format()</code>函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &gt; &lt;　＾　分别是居左，居右，居中</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(text, <span class="string">'&gt;20'</span>)</span><br><span class="line"><span class="string">'       Hello World'</span></span><br><span class="line">＃　也可以在字符串格式化中用</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;:&gt;10s&#125; &#123;:&gt;10s&#125;'</span>.format(<span class="string">'Hello'</span>, <span class="string">'World'</span>)</span><br><span class="line"><span class="string">'    Hello　　 World '</span></span><br></pre></td></tr></table></figure><p>最后，老代码中的％操作符来格式化字符串就不细说啦</p><h3 id="2-14-合并拼接字符串"><a href="#2-14-合并拼接字符串" class="headerlink" title="2.14 合并拼接字符串"></a>2.14 合并拼接字符串</h3><p><strong>Q: 你想将几个小的字符串合并为一个大的字符串</strong></p><p>A: <code>&#39; &#39;.join(str)</code> 和”+”操作符都可以合并字符串，比较简单就不举例了</p><h3 id="2-15-字符串中插入变量"><a href="#2-15-字符串中插入变量" class="headerlink" title="2.15 字符串中插入变量"></a>2.15 字符串中插入变量</h3><p><strong>Q: 你想创建一个内嵌变量的字符串，变量被它的值所表示的字符串替换掉。</strong></p><p>A: 这里推荐python3.6版本的新特性: <strong>f-string</strong> :</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">"Lee"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">666</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">f'<span class="subst">&#123;name&#125;</span> has <span class="subst">&#123;n&#125;</span> messages.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'Lee has 666 messages.'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="2-16-以指定列宽格式化字符串"><a href="#2-16-以指定列宽格式化字符串" class="headerlink" title="2.16 以指定列宽格式化字符串"></a>2.16 以指定列宽格式化字符串</h3><p><strong>Q: 你有一些长字符串，想以指定的列宽将它们重新格式化。</strong></p><p>A: 使用<code>textwrap</code> 模块来格式化字符串的输出:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> textwrap</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(textwrap.fill(s, <span class="number">70</span>)) <span class="comment"># 宽度70</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(textwrap.fill(s, <span class="number">40</span>, initial_indent=<span class="string">'  '</span>)) <span class="comment"># 宽度40，首行空两格</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(textwrap.fill(s, <span class="number">40</span>, subsequent_indent=<span class="string">'  '</span>)) <span class="comment"># 宽度40，非首行空两格</span></span><br></pre></td></tr></table></figure><h3 id="2-17-在字符串中处理html-和xml"><a href="#2-17-在字符串中处理html-和xml" class="headerlink" title="2.17 在字符串中处理html 和xml"></a>2.17 在字符串中处理html 和xml</h3><p><strong>Q: 你想将HTML 或者XML 实体如&entity; 或&#code; 替换为对应的文本。再者，你需要转换文本中特定的字符(比如&lt;, &gt;, 或&amp;)。</strong></p><p>A: 使用<code>html.escape()</code></p><h3 id="2-18-字符串令牌解析"><a href="#2-18-字符串令牌解析" class="headerlink" title="2.18 字符串令牌解析"></a>2.18 字符串令牌解析</h3><p><strong>Q: 你有一个字符串，想从左至右将其解析为一个令牌流。</strong></p><p>A: 看不懂题目</p><h3 id="2-19-实现一个简单的递归下降分析器"><a href="#2-19-实现一个简单的递归下降分析器" class="headerlink" title="2.19 实现一个简单的递归下降分析器"></a>2.19 实现一个简单的递归下降分析器</h3><p><strong>Q: 你想根据一组语法规则解析文本并执行命令，或者构造一个代表输入的抽象语法树。如果语法非常简单，你可以自己写这个解析器，而不是使用一些框架。</strong></p><p>A: 看不懂答案</p><h3 id="2-20-字节字符串上的字符串操作"><a href="#2-20-字节字符串上的字符串操作" class="headerlink" title="2.20 字节字符串上的字符串操作"></a>2.20 字节字符串上的字符串操作</h3><p><strong>Q: 你想在字节字符串上执行普通的文本操作(比如移除，搜索和替换)。</strong></p><p>A: 与普通文本字符串的操作没啥差别，需要注意的是使用正则表达式的时候要加<code>b</code>:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = <span class="string">b'FOO:BAR,SPAM'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">b'[:,]'</span>, data)</span><br></pre></td></tr></table></figure><hr><hr><h2 id="第三章：数字日期和时间"><a href="#第三章：数字日期和时间" class="headerlink" title="第三章：数字日期和时间"></a>第三章：数字日期和时间</h2><h3 id="3-1-数字的四舍五入"><a href="#3-1-数字的四舍五入" class="headerlink" title="3.1 数字的四舍五入"></a>3.1 数字的四舍五入</h3><p><strong>Q:你想对浮点数执行指定精度的舍入运算</strong></p><p>A: 简单的用<code>round(value, ndigits)</code> 函数, 也可以格式化</p><h3 id="3-2-执行精确的浮点数运算"><a href="#3-2-执行精确的浮点数运算" class="headerlink" title="3.2 执行精确的浮点数运算"></a>3.2 执行精确的浮点数运算</h3><p><strong>Q: 你需要对浮点数执行精确的计算操作，并且不希望有任何小误差的出现。</strong></p><p>A: 科学计算用<code>decimal</code> 模块</p><h3 id="3-3-数字的格式化输出"><a href="#3-3-数字的格式化输出" class="headerlink" title="3.3 数字的格式化输出"></a>3.3 数字的格式化输出</h3><p><strong>Q: 你需要将数字格式化后输出，并控制数字的位数、对齐、千位分隔符和其他的细节。</strong></p><p>A: 跟字符串格式化输出一样，使用<code>format</code>函数</p><h3 id="3-4-二八十六进制整数"><a href="#3-4-二八十六进制整数" class="headerlink" title="3.4 二八十六进制整数"></a>3.4 二八十六进制整数</h3><p><strong>Q: 你需要转换或者输出使用二进制，八进制或十六进制表示的整数。</strong></p><p>A: 了将整数转换为二进制、八进制或十六进制的文本串，可以分别使用<code>bin()</code> ,<code>oct()</code> 或<code>hex()</code> 函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1234</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bin(x)</span><br><span class="line"><span class="string">'0b10011010010'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>oct(x)</span><br><span class="line"><span class="string">'0o2322'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(x)</span><br><span class="line"><span class="string">'0x4d2'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="3-5-字节到大整数的打包与解包"><a href="#3-5-字节到大整数的打包与解包" class="headerlink" title="3.5 字节到大整数的打包与解包"></a>3.5 字节到大整数的打包与解包</h3><p><strong>Q: 你有一个字节字符串并想将它解压成一个整数。或者，你需要将一个大整数转换为一个字节字符串。</strong></p><p>A: 字节转整数用<code>int.from_bytes()</code>,整数转字节用<code>int.to_bytes()</code></p><h3 id="3-6-复数的数学运算-略"><a href="#3-6-复数的数学运算-略" class="headerlink" title="3.6 复数的数学运算(略)"></a>3.6 复数的数学运算(略)</h3><h3 id="3-7-无穷大与NaN-略"><a href="#3-7-无穷大与NaN-略" class="headerlink" title="3.7 无穷大与NaN(略)"></a>3.7 无穷大与NaN(略)</h3><h3 id="3-8-分数运算-略"><a href="#3-8-分数运算-略" class="headerlink" title="3.8 分数运算(略)"></a>3.8 分数运算(略)</h3><h3 id="3-9-大型数组运算"><a href="#3-9-大型数组运算" class="headerlink" title="3.9 大型数组运算"></a>3.9 大型数组运算</h3><p><strong>Q: 你需要在大数据集(比如数组或网格) 上面执行计算。</strong></p><p>A: 请参阅numpy和pandas库</p><h3 id="3-10-矩阵与线性代数运算-略"><a href="#3-10-矩阵与线性代数运算-略" class="headerlink" title="3.10 矩阵与线性代数运算(略)"></a>3.10 矩阵与线性代数运算(略)</h3><h3 id="3-11-随机选择"><a href="#3-11-随机选择" class="headerlink" title="3.11 随机选择"></a>3.11 随机选择</h3><p><strong>Q: 你想从一个序列中随机抽取若干元素，或者想生成几个随机数。</strong></p><p>A: 请使用<code>random</code>模块，除了生成随机数随机序列，还可以生成均匀分布、高斯分布等其他函数，随机数的生成也可以设置初始化种子(<code>random.seed()</code>)</p><h3 id="3-12-基本的日期与时间转换"><a href="#3-12-基本的日期与时间转换" class="headerlink" title="3.12 基本的日期与时间转换"></a>3.12 基本的日期与时间转换</h3><p><strong>Q:你需要执行简单的时间转换，比如天到秒，小时到分钟等的转换。</strong></p><p>A: 日期与时间处理用<code>datetime</code>模块</p><h3 id="3-13-计算最后一个周五的日期-略"><a href="#3-13-计算最后一个周五的日期-略" class="headerlink" title="3.13 计算最后一个周五的日期(略)"></a>3.13 计算最后一个周五的日期(略)</h3><h3 id="3-14-计算当前月份的日期范围-略"><a href="#3-14-计算当前月份的日期范围-略" class="headerlink" title="3.14 计算当前月份的日期范围(略)"></a>3.14 计算当前月份的日期范围(略)</h3><h3 id="3-15-字符串转换为日期"><a href="#3-15-字符串转换为日期" class="headerlink" title="3.15 字符串转换为日期"></a>3.15 字符串转换为日期</h3><p><strong>Q: 你的应用程序接受字符串格式的输入，但是你想将它们转换为datetime 对象以便在上面执行非字符串操作。</strong></p><p>A:  一个简单的时间格式化问题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="string">'2012-09-20'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = datetime.strptime(t,<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">datetime.datetime(<span class="number">2012</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z</span><br><span class="line">datetime.datetime(<span class="number">2018</span>, <span class="number">12</span>, <span class="number">19</span>, <span class="number">22</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">914504</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z-y</span><br><span class="line">datetime.timedelta(<span class="number">2281</span>, <span class="number">79269</span>, <span class="number">914504</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="第四章：迭代器与生成器"><a href="#第四章：迭代器与生成器" class="headerlink" title="第四章：迭代器与生成器"></a>第四章：迭代器与生成器</h2><h3 id="4-1-手动遍历迭代器"><a href="#4-1-手动遍历迭代器" class="headerlink" title="4.1 手动遍历迭代器"></a>4.1 手动遍历迭代器</h3><p><strong>Q: 你想遍历一个可迭代对象中的所有元素，但是却不想使用for 循环。</strong></p><p>A: 使用<code>next()</code>函数来获取下一个对象：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = iter(list) <span class="comment"># 转换成可迭代对象才可以使用next方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(a)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(a)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(a)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(a)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="4-2-代理迭代"><a href="#4-2-代理迭代" class="headerlink" title="4.2 代理迭代"></a>4.2 代理迭代</h3><p><strong>Q: 你构建了一个自定义容器对象，里面包含有列表、元组或其他可迭代对象。你想直接在你的这个新容器对象上执行迭代操作。</strong></p><p>A: 给对象定义一个<code>__iter__</code>方法就好：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span> :</span></span><br><span class="line">    <span class="keyword">return</span> iter(self.items)</span><br></pre></td></tr></table></figure><h3 id="4-3-使用生成器创建新的迭代模式"><a href="#4-3-使用生成器创建新的迭代模式" class="headerlink" title="4.3 使用生成器创建新的迭代模式"></a>4.3 使用生成器创建新的迭代模式</h3><p><strong>Q: 你想实现一个自定义迭代模式，跟普通的内置函数比如<code>range()</code> , <code>reversed()</code> 不一样。</strong></p><p>A: <code>yield</code>就是一个生成器函数，生成一个迭代对象</p><h3 id="4-4-实现迭代器协议"><a href="#4-4-实现迭代器协议" class="headerlink" title="4.4 实现迭代器协议"></a>4.4 实现迭代器协议</h3><p><strong>Q: 你想构建一个能支持迭代操作的自定义对象，并希望找到一个能实现迭代协议的简单方法。</strong></p><p>A: 其实就是想自己定义迭代的方法，那就定义一个<code>__next__</code>方法就好</p><h3 id="4-5-反向迭代"><a href="#4-5-反向迭代" class="headerlink" title="4.5 反向迭代"></a>4.5 反向迭代</h3><p><strong>Q: 你想反方向迭代一个序列</strong></p><p>A: 用<code>reversed()</code>函数，<del>先有韦神后有天，反向迭代耗时间</del></p><h3 id="4-6-带有外部状态的生成器函数"><a href="#4-6-带有外部状态的生成器函数" class="headerlink" title="4.6 带有外部状态的生成器函数"></a>4.6 带有外部状态的生成器函数</h3><p><strong>Q: 你想定义一个生成器函数，但是它会调用某个你想暴露给用户使用的外部状态值。</strong></p><p>A: 如果你想让你的生成器暴露外部状态给用户，别忘了你可以简单的将它实现为一<br>个类，然后把生成器函数放到<code>__iter__()</code> 方法中过去</p><h3 id="4-7-迭代器切片"><a href="#4-7-迭代器切片" class="headerlink" title="4.7 迭代器切片"></a>4.7 迭代器切片</h3><p><strong>Q: 你想得到一个由迭代器生成的切片对象，但是标准切片操作并不能做到。</strong></p><p>A: 函数<code>itertools.islice()</code>: </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="meta">... </span><span class="keyword">yield</span> n</span><br><span class="line"><span class="meta">... </span>n += <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = count(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="number">10</span>:<span class="number">20</span>] <span class="comment"># 会报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> itertools.islice(c, <span class="number">10</span>, <span class="number">20</span>):</span><br><span class="line"><span class="meta">... </span>print(x)</span><br><span class="line">...</span><br><span class="line"><span class="number">10</span> <span class="comment"># 一直到20</span></span><br></pre></td></tr></table></figure><h3 id="4-8-跳过可迭代对象的开始部分"><a href="#4-8-跳过可迭代对象的开始部分" class="headerlink" title="4.8 跳过可迭代对象的开始部分"></a>4.8 跳过可迭代对象的开始部分</h3><p><strong>Q: 你想遍历一个可迭代对象，但是它开始的某些元素你并不感兴趣，想跳过它们。</strong></p><p>A: <code>itertools.dropwhile()</code>函数可以做到，比如跳过文件开头几行的注释：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> dropwhile</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'/etc/passwd'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span><span class="keyword">for</span> line <span class="keyword">in</span> dropwhile(<span class="keyword">lambda</span> line: line.startswith(<span class="string">'#'</span>), f):</span><br><span class="line"><span class="meta">... </span>print(line, end=<span class="string">''</span>)</span><br><span class="line">...</span><br><span class="line">nobody:*:<span class="number">-2</span>:<span class="number">-2</span>:Unprivileged User:/var/empty:/usr/bin/false</span><br><span class="line">root:*:<span class="number">0</span>:<span class="number">0</span>:System Administrator:/var/root:/bin/sh</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="4-9-排列组合的迭代"><a href="#4-9-排列组合的迭代" class="headerlink" title="4.9 排列组合的迭代"></a>4.9 排列组合的迭代</h3><p><strong>Q: 你想迭代遍历一个集合中元素的所有可能的排列或组合</strong></p><p>A: 去看一下<code>itertools.permutations()</code>,<code>itertools.combinations()</code>, <code>itertools.combinations_with_replacement</code>使用方法就好了</p><h3 id="4-10-序列上索引值迭代"><a href="#4-10-序列上索引值迭代" class="headerlink" title="4.10 序列上索引值迭代"></a>4.10 序列上索引值迭代</h3><p><strong>Q:你想在迭代一个序列的同时跟踪正在被处理的元素索引。</strong></p><p>A: 这个简单，用<code>enumerate()</code></p><h3 id="4-11-同时迭代多个序列"><a href="#4-11-同时迭代多个序列" class="headerlink" title="4.11 同时迭代多个序列"></a>4.11 同时迭代多个序列</h3><p><strong>Q: 你想同时迭代多个序列，每次分别从一个序列中取一个元素</strong></p><p>A: 章口就莱：<code>zip()</code></p><h3 id="4-12-不同集合上元素的迭代"><a href="#4-12-不同集合上元素的迭代" class="headerlink" title="4.12 不同集合上元素的迭代"></a>4.12 不同集合上元素的迭代</h3><p><strong>Q: 你想在多个对象执行相同的操作，但是这些对象在不同的容器中，你希望代码在不失可读性的情况下避免写重复的循环。</strong></p><p>A: 其实你把这个两个对象合在一起就好了，但是这样做就会有多余的赋值操作，所以就可以用<code>itertools.chain()</code>函数了：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> chain(a, b): <span class="comment"># 等价于 for x in a+b</span></span><br><span class="line"><span class="meta">... </span>print(x)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">x</span><br><span class="line">y</span><br><span class="line">z</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="4-13-创建数据处理管道"><a href="#4-13-创建数据处理管道" class="headerlink" title="4.13 创建数据处理管道"></a>4.13 创建数据处理管道</h3><p><strong>Q: 你想以数据管道(类似Unix 管道) 的方式迭代处理数据。比如，你有个大量的数据需要处理，但是不能将它们一次性放入内存中</strong></p><p>A: 这个还是看书吧，书中的例子将的比较详细，注意一下<code>yiled</code>和<code>yield from</code>用法</p><h3 id="4-14-展开嵌套的序列"><a href="#4-14-展开嵌套的序列" class="headerlink" title="4.14 展开嵌套的序列"></a>4.14 展开嵌套的序列</h3><p><strong>Q: 你想将一个多层嵌套的序列展开成一个单层列表</strong></p><p>A: 详见<code>yield from</code> 用法</p><h3 id="4-15-顺序迭代合并后的排序迭代对象"><a href="#4-15-顺序迭代合并后的排序迭代对象" class="headerlink" title="4.15 顺序迭代合并后的排序迭代对象"></a>4.15 顺序迭代合并后的排序迭代对象</h3><p><strong>Q: 你有一系列排序序列，想将它们合并后得到一个排序序列并在上面迭代遍历。</strong></p><p>A: <code>heapq.merge()</code> 函数可以帮你解决这个问题</p><h3 id="4-16-迭代器代替while-无限循环"><a href="#4-16-迭代器代替while-无限循环" class="headerlink" title="4.16 迭代器代替while 无限循环"></a>4.16 迭代器代替while 无限循环</h3><p><strong>Q: 你在代码中使用while 循环来迭代处理数据，因为它需要调用某个函数或者和一般迭代模式不同的测试条件。能不能用迭代器来重写这个循环呢？</strong></p><p>A: 可以用<code>iter()</code>函数转成可迭代对象，然后就可以用for循环啦</p><hr><hr><h2 id="第五章：文件与IO"><a href="#第五章：文件与IO" class="headerlink" title="第五章：文件与IO"></a>第五章：文件与IO</h2><h3 id="5-1-读写文本数据"><a href="#5-1-读写文本数据" class="headerlink" title="5.1 读写文本数据"></a>5.1 读写文本数据</h3><p><strong>Q: 你需要读写各种不同编码的文本数据，比如ASCII，UTF-8 或UTF-16 编码等。</strong></p><p>A: <code>open</code>函数的<code>encoding</code>参数可以解决这个问题</p><h3 id="5-2-打印输出至文件中"><a href="#5-2-打印输出至文件中" class="headerlink" title="5.2 打印输出至文件中"></a>5.2 打印输出至文件中</h3><p><strong>Q: 你想将print() 函数的输出重定向到一个文件中去。</strong></p><p>A: <code>print</code>函数有个<code>file</code>参数可以指定文件</p><h3 id="5-3-使用其他分隔符或行终止符打印"><a href="#5-3-使用其他分隔符或行终止符打印" class="headerlink" title="5.3 使用其他分隔符或行终止符打印"></a>5.3 使用其他分隔符或行终止符打印</h3><p><strong>Q: 你想使用print() 函数输出数据，但是想改变默认的分隔符或者行尾符。</strong></p><p>A: <code>print()</code> 函数中使用<code>sep</code> 和<code>end</code> 关键字参数</p><h3 id="5-4-读写字节数据"><a href="#5-4-读写字节数据" class="headerlink" title="5.4 读写字节数据"></a>5.4 读写字节数据</h3><p><strong>Q: 你想读写二进制文件，比如图片，声音文件等等。</strong></p><p>A: <code>open</code>函数的<code>rb</code>,<code>wb</code>可以读写二进制文件</p><h3 id="5-5-文件不存在才能写入"><a href="#5-5-文件不存在才能写入" class="headerlink" title="5.5 文件不存在才能写入"></a>5.5 文件不存在才能写入</h3><p><strong>Q: 你想像一个文件中写入数据，但是前提必须是这个文件在文件系统上不存在。也就是不允许覆盖已存在的文件内容。</strong></p><p>A: <code>w</code>模式默认会清空文件，那就换成<code>x</code>模式就好</p><h3 id="5-6-字符串的I-O-操作"><a href="#5-6-字符串的I-O-操作" class="headerlink" title="5.6 字符串的I/O 操作"></a>5.6 字符串的I/O 操作</h3><p><strong>Q: 你想使用操作类文件对象的程序来操作文本或二进制字符串。</strong></p><p>A: 使用<code>io.StringIO()</code>和<code>io.BytesIO</code>类：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = io.StringIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.write(<span class="string">'Hello World\n'</span>)</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'This is a test'</span>, file=s)</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Get all of the data written so far</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.getvalue() <span class="comment"># 注意此时文件指针是指向末尾的，所以你用s.read()是读不出来的</span></span><br><span class="line"><span class="string">'Hello World\nThis is a test\n'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Wrap a file interface around an existing string</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = io.StringIO(<span class="string">'Hello\nWorld\n'</span>) <span class="comment"># 指针在开始出</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.read(<span class="number">4</span>)</span><br><span class="line"><span class="string">'Hell'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.read()</span><br><span class="line"><span class="string">'o\nWorld\n'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="5-7-读写压缩文件"><a href="#5-7-读写压缩文件" class="headerlink" title="5.7 读写压缩文件"></a>5.7 读写压缩文件</h3><p><strong>Q: 你想读写一个gzip 或bz2 格式的压缩文件。</strong></p><p>A: 用<code>gzip</code>和<code>bz2</code>模块的<code>open</code>函数</p><h3 id="5-8-固定大小记录的文件迭代"><a href="#5-8-固定大小记录的文件迭代" class="headerlink" title="5.8 固定大小记录的文件迭代"></a>5.8 固定大小记录的文件迭代</h3><p><strong>Q: 你想在一个固定长度记录或者数据块的集合上迭代，而不是在一个文件中一行一行的迭代。</strong></p><p>A: 方法倒是有，不过我不觉得有必要这样做：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line">RECORD_SIZE = <span class="number">32</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.data'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    records = iter(partial(f.read, RECORD_SIZE), <span class="string">b''</span>)</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> records:</span><br><span class="line">        ...<span class="comment">#　输出</span></span><br></pre></td></tr></table></figure><h3 id="5-9-读取二进制数据到可变缓冲区中"><a href="#5-9-读取二进制数据到可变缓冲区中" class="headerlink" title="5.9 读取二进制数据到可变缓冲区中"></a>5.9 读取二进制数据到可变缓冲区中</h3><p><strong>Q: 你想直接读取二进制数据到一个可变缓冲区中，而不需要做任何的中间复制操作。或者你想原地修改数据并将它写回到一个文件中去。</strong></p><p>A: <code>readinto()</code>函数就是将文件数据读取到一个数组中去：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_into_buffer</span><span class="params">(filename)</span>:</span></span><br><span class="line">buf = bytearray(os.path.getsize(filename)) <span class="comment"># 此时的buf是一个二进制的数组</span></span><br><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">f.readinto(buf)</span><br><span class="line"><span class="keyword">return</span> buf</span><br></pre></td></tr></table></figure><p>和普通<code>read()</code> 方法不同的是，<code>readinto()</code> 填充已存在的缓冲区而不是为新对象重新分配内存再返回它们</p><h3 id="5-10-内存映射的二进制文件"><a href="#5-10-内存映射的二进制文件" class="headerlink" title="5.10 内存映射的二进制文件"></a>5.10 内存映射的二进制文件</h3><p><strong>Q: 你想内存映射一个二进制文件到一个可变字节数组中，目的可能是为了随机访问它的内容或者是原地做些修改。</strong></p><p>A: <code>mmap</code>模块可以解决这个问题，有需要的去看<a href="https://docs.python.org/3/library/mmap.html" target="_blank" rel="noopener">官方文档</a>吧，这里就不介绍了</p><h3 id="5-11-文件路径名的操作"><a href="#5-11-文件路径名的操作" class="headerlink" title="5.11 文件路径名的操作"></a>5.11 文件路径名的操作</h3><p><strong>Q: 你需要使用路径名来获取文件名，目录名，绝对路径等等。</strong></p><p>A: <code>os.path</code>模块就不用我多说了吧</p><h3 id="5-12-测试文件是否存在"><a href="#5-12-测试文件是否存在" class="headerlink" title="5.12 测试文件是否存在"></a>5.12 测试文件是否存在</h3><p><strong>Q: 你想测试一个文件或目录是否存在。</strong></p><p>A: <code>os.path.isfile()</code>, <code>os.path.isdir()</code>, <code>os.path.islink()</code> , <code>os.path.realpath()</code>, <code>os.path.abspath</code>, <code>os.path.getsize()</code>…</p><h3 id="5-13-获取文件夹中的文件列表"><a href="#5-13-获取文件夹中的文件列表" class="headerlink" title="5.13 获取文件夹中的文件列表"></a>5.13 获取文件夹中的文件列表</h3><p><strong>Q: 你想获取文件系统中某个目录下的所有文件列表。</strong></p><p>A: <code>os.listdir()</code></p><h3 id="5-14-忽略文件名编码"><a href="#5-14-忽略文件名编码" class="headerlink" title="5.14 忽略文件名编码"></a>5.14 忽略文件名编码</h3><p><strong>Q: 你想使用原始文件名执行文件的I/O 操作，也就是说文件名并没有经过系统默认编码去解码或编码过。</strong></p><p>A: 既然文件名编码不知道，那就统一用字节名吧，然后用字节名当做文件名读写：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">b'jalapen\xcc\x83o.txt'</span>) <span class="keyword">as</span> f:</span><br></pre></td></tr></table></figure><h3 id="5-15-打印不合法的文件名"><a href="#5-15-打印不合法的文件名" class="headerlink" title="5.15 打印不合法的文件名"></a>5.15 打印不合法的文件名</h3><p><strong>Q: 你的程序获取了一个目录中的文件名列表，但是当它试着去打印文件名的时候程序崩溃，出现了UnicodeEncodeError 异常和一条奇怪的消息——surrogates notallowed 。</strong></p><p>A: 解决方法：<code>repr(filename)[1:-1]</code>这样就将一些奇奇怪怪的字正确显示</p><h3 id="5-16-增加或改变已打开文件的编码"><a href="#5-16-增加或改变已打开文件的编码" class="headerlink" title="5.16 增加或改变已打开文件的编码"></a>5.16 增加或改变已打开文件的编码</h3><p><strong>Q: 你想在不关闭一个已打开的文件前提下增加或改变它的Unicode 编码。</strong></p><p>A: 我不建议这么做</p><h3 id="5-17-将字节写入文本文件"><a href="#5-17-将字节写入文本文件" class="headerlink" title="5.17 将字节写入文本文件"></a>5.17 将字节写入文本文件</h3><p><strong>Q: 你想在文本模式打开的文件中写入原始的字节数据。</strong></p><p>A: 将字节数据直接写入文件的缓冲区即可：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys`</span><br><span class="line">sys.stdout.buffer.write(<span class="string">b'Hello\n'</span>)</span><br></pre></td></tr></table></figure><h3 id="5-18-将文件描述符包装成文件对象"><a href="#5-18-将文件描述符包装成文件对象" class="headerlink" title="5.18 将文件描述符包装成文件对象"></a>5.18 将文件描述符包装成文件对象</h3><p><strong>Q: 你有一个对应于操作系统上一个已打开的I/O 通道(比如文件、管道、套接字等)的整型文件描述符，你想将它包装成一个更高层的Python 文件对象</strong></p><p>A: 包装文件描述符的技术可以很方便的将一个类文件接口作用于一个以不同方式打开的I/O 通道上，如管道、套接字等，有需要的自己去查资料吧</p><h3 id="5-19-创建临时文件和文件夹"><a href="#5-19-创建临时文件和文件夹" class="headerlink" title="5.19 创建临时文件和文件夹"></a>5.19 创建临时文件和文件夹</h3><p><strong>Q: 你需要在程序执行时创建一个临时文件或目录，并希望使用完之后可以自动销毁掉。</strong></p><p>A: <code>tempfile</code> 模块的<code>TemporaryFile()</code>、<code>NamedTemporaryFile()</code> 和<code>TemporaryDirectory()</code> 函数<br>可以满足需求</p><h3 id="5-20-与串行端口的数据通信"><a href="#5-20-与串行端口的数据通信" class="headerlink" title="5.20 与串行端口的数据通信"></a>5.20 与串行端口的数据通信</h3><p><strong>Q: 你想通过串行端口读写数据，典型场景就是和一些硬件设备打交道(比如一个机器人或传感器)。</strong></p><p>A: 请使用<a href="https://pyserial.readthedocs.io/en/latest/" target="_blank" rel="noopener"><code>pySerial</code></a></p><h3 id="5-21-序列化Python-对象"><a href="#5-21-序列化Python-对象" class="headerlink" title="　5.21 序列化Python 对象"></a>　5.21 序列化Python 对象</h3><p><strong>Q: 你需要将一个Python 对象序列化为一个字节流，以便将它保存到一个文件、存储到数据库或者通过网络传输它。</strong></p><p>A: 请使用<code>pickle.load</code>, <code>pickle.loads</code>, <code>pickle.dump</code>, <code>pickle.dumps</code></p><hr><hr><h2 id="第六章：数据编码和处理"><a href="#第六章：数据编码和处理" class="headerlink" title="第六章：数据编码和处理"></a>第六章：数据编码和处理</h2><h3 id="6-1-读写CSV-数据"><a href="#6-1-读写CSV-数据" class="headerlink" title="6.1 读写CSV 数据"></a>6.1 读写CSV 数据</h3><p><strong>Q: 你想读写一个CSV 格式的文件。</strong></p><p>A: 请看示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'stocks.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.reader(f)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> f_csv:</span><br><span class="line">        <span class="comment"># 其他操作</span></span><br><span class="line">        <span class="comment"># 请注意这里的row是一个列表，是自动以逗号分隔的</span></span><br></pre></td></tr></table></figure><h3 id="6-2-读写JSON-数据"><a href="#6-2-读写JSON-数据" class="headerlink" title="6.2 读写JSON 数据"></a>6.2 读写JSON 数据</h3><p><strong>Q: 你想读写JSON(JavaScript Object Notation) 编码格式的数据。</strong></p><p>A: <code>json.loads</code>读取JSON格式，<code>json.dumps</code>转换为JSON格式，对应的文件读写方法是：<code>json.dump</code>, <code>json.load</code></p><h3 id="6-3-解析简单的XML-数据"><a href="#6-3-解析简单的XML-数据" class="headerlink" title="6.3 解析简单的XML 数据"></a>6.3 解析简单的XML 数据</h3><p><strong>Q: 你想从一个简单的XML 文档中提取数据。</strong></p><p>A: 可以试一下<code>xml.etree.ElementTree</code>模块的<code>parse</code>函数</p><h3 id="6-4-增量式解析大型XML-文件"><a href="#6-4-增量式解析大型XML-文件" class="headerlink" title="6.4 增量式解析大型XML 文件"></a>6.4 增量式解析大型XML 文件</h3><p><strong>Q: 你想使用尽可能少的内存从一个超大的XML 文档中提取数据。</strong></p><p>A: 任何时候只要你遇到增量式的数据处理时，第一时间就应该想到迭代器和生成器。示例略</p><h3 id="6-5-将字典转换为XML-略"><a href="#6-5-将字典转换为XML-略" class="headerlink" title="6.5 将字典转换为XML(略)"></a>6.5 将字典转换为XML(略)</h3><h3 id="6-6-解析和修改XML-略"><a href="#6-6-解析和修改XML-略" class="headerlink" title="6.6 解析和修改XML(略)"></a>6.6 解析和修改XML(略)</h3><h3 id="6-7-利用命名空间解析XML-文档-略"><a href="#6-7-利用命名空间解析XML-文档-略" class="headerlink" title="6.7 利用命名空间解析XML 文档(略)"></a>6.7 利用命名空间解析XML 文档(略)</h3><h3 id="6-8-与关系型数据库的交互"><a href="#6-8-与关系型数据库的交互" class="headerlink" title="6.8 与关系型数据库的交互"></a>6.8 与关系型数据库的交互</h3><p><strong>Q: 你想在关系型数据库中查询、增加或删除记录</strong></p><p>A: 可以使用内置的<code>sqlite3 模块</code>， 安装其他模块也可以</p><h3 id="6-9-编码和解码十六进制数"><a href="#6-9-编码和解码十六进制数" class="headerlink" title="6.9 编码和解码十六进制数"></a>6.9 编码和解码十六进制数</h3><p><strong>Q: 你想将一个十六进制字符串解码成一个字节字符串或者将一个字节字符串编码成一个十六进制字符串。</strong></p><p>A: <code>base64.b16decode()</code> 和<code>base64.b16encode()</code></p><h3 id="6-10-编码解码Base64-数据"><a href="#6-10-编码解码Base64-数据" class="headerlink" title="6.10 编码解码Base64 数据"></a>6.10 编码解码Base64 数据</h3><p><strong>Q: 你需要使用Base64 格式解码或编码二进制数据。</strong></p><p>A: <code>base64.b64decode()</code> 和<code>base64.b64encode()</code></p><h3 id="6-11-读写二进制数组数据-略"><a href="#6-11-读写二进制数组数据-略" class="headerlink" title="6.11 读写二进制数组数据(略)"></a>6.11 读写二进制数组数据(略)</h3><h3 id="6-12-读取嵌套和可变长二进制数据-略"><a href="#6-12-读取嵌套和可变长二进制数据-略" class="headerlink" title="6.12 读取嵌套和可变长二进制数据(略)"></a>6.12 读取嵌套和可变长二进制数据(略)</h3><h3 id="6-13-数据的累加与统计操作-略"><a href="#6-13-数据的累加与统计操作-略" class="headerlink" title="6.13 数据的累加与统计操作(略)"></a>6.13 数据的累加与统计操作(略)</h3><hr><hr><h2 id="第七章：函数"><a href="#第七章：函数" class="headerlink" title="第七章：函数"></a>第七章：函数</h2><h3 id="7-1-可接受任意数量参数的函数"><a href="#7-1-可接受任意数量参数的函数" class="headerlink" title="7.1 可接受任意数量参数的函数"></a>7.1 可接受任意数量参数的函数</h3><p><strong>Q: 你想构造一个可接受任意数量参数的函数。</strong></p><p>A: 使用<code>*</code>任意位置参数和<code>**</code>任意关键字参数</p><h3 id="7-2-只接受关键字参数的函数"><a href="#7-2-只接受关键字参数的函数" class="headerlink" title="7.2 只接受关键字参数的函数"></a>7.2 只接受关键字参数的函数</h3><p><strong>Q: 你希望函数的某些参数强制使用关键字参数传递</strong></p><p>A: 将强制关键字参数放到某个<code>*</code> 参数或者单个<code>*</code> 后面就能达到这种效果。比如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 强制最后一个参数必须输入</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv</span><span class="params">(maxsize, *, block)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="7-3-给函数参数增加元信息"><a href="#7-3-给函数参数增加元信息" class="headerlink" title="7.3 给函数参数增加元信息"></a>7.3 给函数参数增加元信息</h3><p><strong>Q: 你写好了一个函数，然后想为这个函数的参数增加一些额外的信息，这样的话其他使用者就能清楚的知道这个函数应该怎么使用。</strong></p><p>A: 使用函数注解：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x:int, y:int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure><h3 id="7-4-返回多个值的函数"><a href="#7-4-返回多个值的函数" class="headerlink" title="7.4 返回多个值的函数"></a>7.4 返回多个值的函数</h3><p><strong>Q: 你希望构造一个可以返回多个值的函数</strong></p><p>A: <code>return</code></p><h3 id="7-5-定义有默认参数的函数"><a href="#7-5-定义有默认参数的函数" class="headerlink" title="7.5 定义有默认参数的函数"></a>7.5 定义有默认参数的函数</h3><p><strong>Q: 你想定义一个函数或者方法，它的一个或多个参数是可选的并且有一个默认值。</strong></p><p>A:　这么简单就不回答了</p><h3 id="7-6-定义匿名或内联函数"><a href="#7-6-定义匿名或内联函数" class="headerlink" title="7.6 定义匿名或内联函数"></a>7.6 定义匿名或内联函数</h3><p><strong>你想为sort() 操作创建一个很短的回调函数，但又不想用def 去写一个单行函数，而是希望通过某个快捷方式以内联方式来创建这个函数。</strong></p><p>A: <code>lambda</code>表达式，但是只能指定单个表达式，它的值就是最后的返回值。</p><h3 id="7-7-匿名函数捕获变量值"><a href="#7-7-匿名函数捕获变量值" class="headerlink" title="7.7 匿名函数捕获变量值"></a>7.7 匿名函数捕获变量值</h3><p><strong>Q: 你用lambda 定义了一个匿名函数，并想在定义时捕获到某些变量的值。</strong></p><p>A: 这个问题看似很难懂，其实你只要明白下列代码的意思就懂了：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="keyword">lambda</span> y: x + y</span><br><span class="line">a = <span class="keyword">lambda</span> y, x=x: x + y</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">funcs = [<span class="keyword">lambda</span> x: x+n <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">funcs = [<span class="keyword">lambda</span> x, n=n: x+n <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br></pre></td></tr></table></figure><h3 id="7-8-减少可调用对象的参数个数-待补充"><a href="#7-8-减少可调用对象的参数个数-待补充" class="headerlink" title="7.8 减少可调用对象的参数个数(待补充)"></a>7.8 减少可调用对象的参数个数(待补充)</h3><h3 id="7-9-将单方法的类转换为函数-待补充"><a href="#7-9-将单方法的类转换为函数-待补充" class="headerlink" title="7.9 将单方法的类转换为函数(待补充)"></a>7.9 将单方法的类转换为函数(待补充)</h3><h3 id="7-10-带额外状态信息的回调函数-待补充"><a href="#7-10-带额外状态信息的回调函数-待补充" class="headerlink" title="7.10 带额外状态信息的回调函数(待补充)"></a>7.10 带额外状态信息的回调函数(待补充)</h3><h3 id="7-11-内联回调函数-待补充"><a href="#7-11-内联回调函数-待补充" class="headerlink" title="7.11 内联回调函数(待补充)"></a>7.11 内联回调函数(待补充)</h3><h3 id="7-12-访问闭包中定义的变量-待补充"><a href="#7-12-访问闭包中定义的变量-待补充" class="headerlink" title="7.12 访问闭包中定义的变量(待补充)"></a>7.12 访问闭包中定义的变量(待补充)</h3><hr><hr><h2 id="第八章：类与对象"><a href="#第八章：类与对象" class="headerlink" title="第八章：类与对象"></a>第八章：类与对象</h2><h3 id="8-1-改变对象的字符串显示"><a href="#8-1-改变对象的字符串显示" class="headerlink" title="8.1 改变对象的字符串显示"></a>8.1 改变对象的字符串显示</h3><p><strong>Q: 你想改变对象实例的打印或显示输出，让它们更具可读性。</strong></p><p>A: 重新定义<code>__str__()</code>和<code>__repr__()</code>方法就好</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Pair(&#123;0.x!r&#125;, &#123;0.y!r&#125;)'</span>.format(self)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'(&#123;0.x!s&#125;, &#123;0.y!s&#125;)'</span>.format(self)</span><br></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Pair(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p</span><br><span class="line">Pair(<span class="number">3</span>, <span class="number">4</span>) <span class="comment"># __repr__() output</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(p)</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>) <span class="comment"># __str__() output</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="8-2-自定义字符串的格式化"><a href="#8-2-自定义字符串的格式化" class="headerlink" title="8.2 自定义字符串的格式化"></a>8.2 自定义字符串的格式化</h3><p><strong>Q: 你想通过format() 函数和字符串方法使得一个对象能支持自定义的格式化。</strong></p><p>A:  重新定义<code>__format__()</code>方法</p><h3 id="8-3-让对象支持上下文管理协议"><a href="#8-3-让对象支持上下文管理协议" class="headerlink" title="8.3 让对象支持上下文管理协议"></a>8.3 让对象支持上下文管理协议</h3><p><strong>Q:你想让你的对象支持上下文管理协议(with 语句)。</strong></p><p>A:  让你的对象实现<code>__enter__()</code>和<code>__exit__()</code>方法</p><h3 id="8-4-创建大量对象时节省内存方法"><a href="#8-4-创建大量对象时节省内存方法" class="headerlink" title="8.4 创建大量对象时节省内存方法"></a>8.4 创建大量对象时节省内存方法</h3><p><strong>Q: 你的程序要创建大量(可能上百万) 的对象，导致占用很大的内存。</strong></p><p>A: 给你的类添加<code>__slots__</code>把对象存入元组中</p><h3 id="8-5-在类中封装属性名"><a href="#8-5-在类中封装属性名" class="headerlink" title="8.5 在类中封装属性名"></a>8.5 在类中封装属性名</h3><p><strong>Q: 你想封装类的实例上面的“私有”数据，但是Python 语言并没有访问控制。</strong></p><p>A: 私有属性可以用单下划线的命名命名，若果以双下划线开头命名，那么访问方式会有所改变</p><h3 id="8-6-创建可管理的属性"><a href="#8-6-创建可管理的属性" class="headerlink" title="8.6 创建可管理的属性"></a>8.6 创建可管理的属性</h3><p><strong>Q: 你想给某个实例attribute 增加除访问与修改之外的其他处理逻辑，比如类型检查或合法性验证。</strong></p><p>A: <code>@property</code>装饰器可以设置getter 、setter 和deleter 方法</p><h3 id="8-7-调用父类方法"><a href="#8-7-调用父类方法" class="headerlink" title="8.7 调用父类方法"></a>8.7 调用父类方法</h3><p><strong>Q: 你想在子类中调用父类的某个已经被覆盖的方法。</strong></p><p>A: 在子类中使用<code>super()</code>函数</p><h3 id="8-8-子类中扩展property"><a href="#8-8-子类中扩展property" class="headerlink" title="8.8 子类中扩展property"></a>8.8 子类中扩展property</h3><p><strong>Q: 在子类中，你想要扩展定义在父类中的property 的功能。</strong></p><p>A: 直接继承并修改父类中的方法</p><h3 id="8-9-创建新的类或实例属性"><a href="#8-9-创建新的类或实例属性" class="headerlink" title="8.9 创建新的类或实例属性"></a>8.9 创建新的类或实例属性</h3><p><strong>Q: 你想创建一个新的拥有一些额外功能的实例属性类型，比如类型检查。</strong></p><p>A: <code>@property</code>装饰器是对<code>__get__()</code>, <code>__set__()</code>, <code>__delete__()</code>的实现，如果不想用装饰器，那就这几个函数重新定义就好</p><h3 id="8-10-使用延迟计算属性"><a href="#8-10-使用延迟计算属性" class="headerlink" title="8.10 使用延迟计算属性"></a>8.10 使用延迟计算属性</h3><p><strong>Q: 你想将一个只读属性定义成一个property，并且只在访问的时候才会计算结果。但是一旦被访问后，你希望结果值被缓存起来，不用每次都去计算。</strong></p><p>A: 只设置<code>@property.getter</code></p><h3 id="8-11-简化数据结构的初始化"><a href="#8-11-简化数据结构的初始化" class="headerlink" title="8.11 简化数据结构的初始化"></a>8.11 简化数据结构的初始化</h3><p><strong>Q: 你写了很多仅仅用作数据结构的类，不想写太多烦人的<strong>init</strong>() 函数</strong></p><p>A: 可以在一个基类中写一个公用的<code>__init__()</code> 函数, 用<code>setattr()</code>实现</p><h3 id="8-12-8-25-待补充"><a href="#8-12-8-25-待补充" class="headerlink" title="8.12 -8.25(待补充)"></a>8.12 -8.25(待补充)</h3><hr><hr><h2 id="第九章：元编程-待补充"><a href="#第九章：元编程-待补充" class="headerlink" title="第九章：元编程(待补充)"></a>第九章：元编程(待补充)</h2><hr><hr><h2 id="第十章：模块与包"><a href="#第十章：模块与包" class="headerlink" title="第十章：模块与包"></a>第十章：模块与包</h2><h3 id="10-1-构建一个模块的层级包"><a href="#10-1-构建一个模块的层级包" class="headerlink" title="10.1 构建一个模块的层级包"></a>10.1 构建一个模块的层级包</h3><p><strong>Q: 你想将你的代码组织成由很多分层模块构成的包。</strong></p><p>A: 封装成包是很简单的。在文件系统上组织你的代码，并确保每个目录都定义了一个<code>__init__.py</code> 文件</p><h3 id="10-2-控制模块被全部导入的内容"><a href="#10-2-控制模块被全部导入的内容" class="headerlink" title="10.2 控制模块被全部导入的内容"></a>10.2 控制模块被全部导入的内容</h3><p><strong>Q: 当使用’from module import *’语句时，希望对从模块或包导出的符号进行精确控制</strong></p><p>A: 在你的模块中定义一个<code>__all__</code>属性来列出你要导出的内容</p><h3 id="10-3-使用相对路径名导入包中子模块"><a href="#10-3-使用相对路径名导入包中子模块" class="headerlink" title="10.3 使用相对路径名导入包中子模块"></a>10.3 使用相对路径名导入包中子模块</h3><p><strong>Q: 将代码组织成包, 想用import 语句从另一个包名没有硬编码过的包的中导入子模块。</strong></p><p>A: <code>from . import  samepackge</code> ,其实<code>from</code>后面跟一个相对路径就好</p><h3 id="10-4-将模块分割成多个文件"><a href="#10-4-将模块分割成多个文件" class="headerlink" title="10.4 将模块分割成多个文件"></a>10.4 将模块分割成多个文件</h3><p><strong>Q: 你想将一个模块分割成多个文件。但是你不想将分离的文件统一成一个逻辑模块时使已有的代码遭到破坏。</strong></p><p>A: 在<code>__init__.py</code> 文件中统一导入就好，如果模块太多又不想导入，也可以定义成延迟导入(详情见本书示例)</p><h3 id="10-5-利用命名空间导入目录分散的代码"><a href="#10-5-利用命名空间导入目录分散的代码" class="headerlink" title="10.5 利用命名空间导入目录分散的代码"></a>10.5 利用命名空间导入目录分散的代码</h3><p><strong>Q: 你可能有大量的代码，由不同的人来分散地维护。每个部分被组织为文件目录，如一个包。然而，你希望能用共同的包前缀将所有组件连接起来，不是将每一个部分作为独立的包来安装。</strong></p><p>A: 用一个顶级的python包，包下面有不同的模块文件，删去用来将组件联合起来的<code>__init__.py</code> 文件</p><h3 id="10-6-重新加载模块"><a href="#10-6-重新加载模块" class="headerlink" title="10.6 重新加载模块"></a>10.6 重新加载模块</h3><p><strong>Q: 你想重新加载已经加载的模块，因为你对其源码进行了修改。</strong></p><p>A: 使用<code>imp.reload()</code></p><h3 id="10-7-运行目录或压缩文件"><a href="#10-7-运行目录或压缩文件" class="headerlink" title="10.7 运行目录或压缩文件"></a>10.7 运行目录或压缩文件</h3><p><strong>Q: 您有一个已成长为包含多个文件的应用，它已远不再是一个简单的脚本，你想向用户提供一些简单的方法运行这个程序</strong></p><p>A: 在目录里添加<code>__main__.py</code>文件就可以把目录当做一个运行程序来运行啦</p><h3 id="10-8-读取位于包中的数据文件"><a href="#10-8-读取位于包中的数据文件" class="headerlink" title="10.8 读取位于包中的数据文件"></a>10.8 读取位于包中的数据文件</h3><p><strong>Q: 你的包中包含代码需要去读取的数据文件。你需要尽可能地用最便捷的方式来做这件事</strong></p><p>A: 假设你的包中的文件组织成如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mypackage/</span><br><span class="line">    __init__.py</span><br><span class="line">    somedata.dat</span><br><span class="line">    spam.py</span><br></pre></td></tr></table></figure><p>现在假设<code>spam.py</code> 文件需要读取<code>somedata.dat</code> 文件中的内容。你可以用以下代码来完成：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spam.py</span></span><br><span class="line"><span class="keyword">import</span> pkgutil</span><br><span class="line">data = pkgutil.get_data(__package__, <span class="string">'somedata.dat'</span>)</span><br></pre></td></tr></table></figure><h3 id="10-9-将文件夹加入到sys-path"><a href="#10-9-将文件夹加入到sys-path" class="headerlink" title="10.9 将文件夹加入到sys.path"></a>10.9 将文件夹加入到sys.path</h3><p><strong>Q: 你无法导入你的Python 代码因为它所在的目录不在sys.path 里。你想将添加新目录到Python 路径，但是不想硬链接到你的代码。</strong></p><p>A: 第一种方式是在你的环境变量<code>PYTHONPATH</code>添加路径，第二种就是创建一个<code>myapplication.pth</code>文件将路径写进去，放在<code>site-packages</code>目录下，还有就是在脚本开头导入路径<code>sys.path.insert(0, &#39;/some/dir&#39;)</code>，<code>sys.path.appedn(&#39;/some/dir&#39;)</code>，</p><h3 id="10-10-通过字符串名导入模块"><a href="#10-10-通过字符串名导入模块" class="headerlink" title="10.10 通过字符串名导入模块"></a>10.10 通过字符串名导入模块</h3><p><strong>Q: 你想导入一个模块，但是模块的名字在字符串里。你想对字符串调用导入命令。</strong></p><p>A: <code>importlib.import_module()</code>函数返回一个模块对象</p><h3 id="10-11-通过钩子远程加载模块-待补充"><a href="#10-11-通过钩子远程加载模块-待补充" class="headerlink" title="10.11 通过钩子远程加载模块(待补充)"></a>10.11 通过钩子远程加载模块(待补充)</h3><h3 id="10-12-导入模块的同时修改模块-待补充"><a href="#10-12-导入模块的同时修改模块-待补充" class="headerlink" title="10.12 导入模块的同时修改模块(待补充)"></a>10.12 导入模块的同时修改模块(待补充)</h3><h3 id="10-13-安装私有的包"><a href="#10-13-安装私有的包" class="headerlink" title="10.13 安装私有的包"></a>10.13 安装私有的包</h3><p><strong>Q: 你想要安装一个第三方包，但是没有权限将它安装到系统Python 库中去。或者，你可能想要安装一个供自己使用的包，而不是系统上面所有用户。</strong></p><p>A:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3 setup.py install --user</span><br><span class="line">pip install --user packagename</span><br></pre></td></tr></table></figure></p><h3 id="10-14-创建新的Python-环境"><a href="#10-14-创建新的Python-环境" class="headerlink" title="10.14 创建新的Python 环境"></a>10.14 创建新的Python 环境</h3><p><strong>Q: 你想创建一个新的Python 环境，用来安装模块和包。不过，你不想安装一个新的Python 克隆，也不想对系统Python 环境产生影响。</strong></p><p>A: 用<code>pyvenv</code>创建一个虚拟环境，请参阅<a href="https://www.python.org/dev/peps/pep-0405/" target="_blank" rel="noopener">PEP405</a></p><h3 id="10-15-分发包-待补充"><a href="#10-15-分发包-待补充" class="headerlink" title="10.15 分发包(待补充)"></a>10.15 分发包(待补充)</h3><hr><hr><h2 id="第十一章：网络与Web-编程-待补充"><a href="#第十一章：网络与Web-编程-待补充" class="headerlink" title="第十一章：网络与Web 编程(待补充)"></a>第十一章：网络与Web 编程(待补充)</h2><h3 id="11-1-作为客户端与HTTP-服务交互"><a href="#11-1-作为客户端与HTTP-服务交互" class="headerlink" title="11.1 作为客户端与HTTP 服务交互"></a>11.1 作为客户端与HTTP 服务交互</h3><p><strong>Q: 你需要通过HTTP 协议以客户端的方式访问多种服务。例如，下载数据或者与基于REST 的API 进行交互</strong></p><p>A: 通常我们会有<code>urllib.request</code>, <code>requests</code> 两种方式来我完成，由于<code>requests</code>库比较简单，所以示例我们这个来写个简单的POST请求：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line"><span class="comment"># Dictionary of query parameters (if any)</span></span><br><span class="line">parms = &#123;</span><br><span class="line">    <span class="string">'name1'</span> : <span class="string">'value1'</span>,</span><br><span class="line">    <span class="string">'name2'</span> : <span class="string">'value2'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># Extra headers</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-agent'</span> : <span class="string">'none/ofyourbusiness'</span>,</span><br><span class="line">    <span class="string">'Spam'</span> : <span class="string">'Eggs'</span></span><br><span class="line">&#125;</span><br><span class="line">resp = requests.post(url, data=parms, headers=headers)</span><br><span class="line"><span class="comment"># Decoded text returned by the request</span></span><br><span class="line">text = resp.text</span><br></pre></td></tr></table></figure><hr><hr><h2 id="第十二章：并发编程-待补充"><a href="#第十二章：并发编程-待补充" class="headerlink" title="第十二章：并发编程(待补充)"></a>第十二章：并发编程(待补充)</h2><h3 id="12-1-启动与停止线程"><a href="#12-1-启动与停止线程" class="headerlink" title="12.1 启动与停止线程"></a>12.1 启动与停止线程</h3><p><strong>Q: 你要为需要并发执行的代码创建/销毁线程</strong></p><p>A: <code>threading</code>库的简单使用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">t = Thread(target=somemethod,args=(someargvs,))</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line">t.is_alive()</span><br></pre></td></tr></table></figure><h3 id="12-2-判断线程是否已经启动"><a href="#12-2-判断线程是否已经启动" class="headerlink" title="12.2 判断线程是否已经启动"></a>12.2 判断线程是否已经启动</h3><p><strong>Q: 你已经启动了一个线程，但是你想知道它是不是真的已经开始运行了。</strong></p><p>A: 使用<code>threading</code> 库中的<code>Event</code> 对象</p><h3 id="12-3-线程间通信"><a href="#12-3-线程间通信" class="headerlink" title="12.3 线程间通信"></a>12.3 线程间通信</h3><p><strong>Q: 你的程序中有多个线程，你需要在这些线程之间安全地交换信息或数据</strong></p><p>A: 基本思路就是搞个外部队列，然后各个线程进行get或者put数据</p><h3 id="12-4-给关键部分加锁"><a href="#12-4-给关键部分加锁" class="headerlink" title="12.4 给关键部分加锁"></a>12.4 给关键部分加锁</h3><p><strong>Q: 你需要对多线程程序中的临界区加锁以避免竞争条件。</strong></p><p>A: 注意一下<code>threading.RLock</code> 和 <code>threading.Lock</code> 的区别</p><h3 id="12-5-防止死锁的加锁机制"><a href="#12-5-防止死锁的加锁机制" class="headerlink" title="12.5 防止死锁的加锁机制"></a>12.5 防止死锁的加锁机制</h3><p><strong>Q: 你正在写一个多线程程序，其中线程需要一次获取多个锁，此时如何避免死锁问题。</strong></p><p>A: 给锁加ID</p><h3 id="12-6-保存线程的状态信息"><a href="#12-6-保存线程的状态信息" class="headerlink" title="12.6 保存线程的状态信息"></a>12.6 保存线程的状态信息</h3><p><strong>Q: 你需要保存正在运行线程的状态，这个状态对于其他的线程是不可见的。</strong></p><p>A: </p><hr><hr><h2 id="第十三章：脚本编程与系统管理"><a href="#第十三章：脚本编程与系统管理" class="headerlink" title="第十三章：脚本编程与系统管理"></a>第十三章：脚本编程与系统管理</h2><h3 id="13-1-通过重定向-管道-文件接受输入"><a href="#13-1-通过重定向-管道-文件接受输入" class="headerlink" title="13.1 通过重定向/管道/文件接受输入"></a>13.1 通过重定向/管道/文件接受输入</h3><p><strong>Q: 13.1 通过重定向/管道/文件接受输入</strong></p><p>A: <code>fileinput.input()</code>可以接收管道输入的文件列表</p><h3 id="13-2-终止程序并给出错误信息"><a href="#13-2-终止程序并给出错误信息" class="headerlink" title="13.2 终止程序并给出错误信息"></a>13.2 终止程序并给出错误信息</h3><p><strong>Q: 你想向标准错误打印一条消息并返回某个非零状态码来终止程序运行解</strong></p><p>A: 抛出一个<code>SystemExit</code> 异常:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">raise</span> SystemExit(<span class="string">'It failed!'</span>)</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.stderr.write(<span class="string">'It failed!\n'</span>)</span><br><span class="line"><span class="keyword">raise</span> SystemExit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="13-3-解析命令行选项"><a href="#13-3-解析命令行选项" class="headerlink" title="13.3 解析命令行选项"></a>13.3 解析命令行选项</h3><p><strong>Q: 你的程序如何能够解析命令行选项（位于sys.argv 中）</strong></p><p>A: <code>argparse</code> 模块</p><h3 id="13-4-运行时弹出密码输入提示"><a href="#13-4-运行时弹出密码输入提示" class="headerlink" title="13.4 运行时弹出密码输入提示"></a>13.4 运行时弹出密码输入提示</h3><p><strong>Q: 你写了个脚本，运行时需要一个密码。此脚本是交互式的，因此不能将密码在脚本中硬编码，而是需要弹出一个密码输入提示，让用户自己输入。</strong></p><p>A:　看代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> getpass</span><br><span class="line">user = getpass.getuser()</span><br><span class="line">passwd = getpass.getpass()</span><br></pre></td></tr></table></figure><p>代码中<code>getpass.getuser()</code> 不会弹出用户名的输入提示。它会根据该用户的shell 环境或者会依据本地系统的密码库（支持pwd 模块的平台）来使用当前用户的登录名，如果你想显示的弹出用户名输入提示，使用内置的input 函数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user = input(<span class="string">'Enter your username: '</span>)</span><br></pre></td></tr></table></figure></p><h3 id="13-5-获取终端的大小"><a href="#13-5-获取终端的大小" class="headerlink" title="13.5 获取终端的大小"></a>13.5 获取终端的大小</h3><p><strong>Q: 你需要知道当前终端的大小以便正确的格式化输出。</strong></p><p>A: <code>os.get_terminal_size()</code>函数</p><h3 id="13-6-执行外部命令并获取它的输出"><a href="#13-6-执行外部命令并获取它的输出" class="headerlink" title="13.6 执行外部命令并获取它的输出"></a>13.6 执行外部命令并获取它的输出</h3><p><strong>Q: 你想执行一个外部命令并以Python 字符串的形式获取执行结果。</strong></p><p>A: <code>subprocess</code>模块</p><h3 id="13-7-复制或者移动文件和目录"><a href="#13-7-复制或者移动文件和目录" class="headerlink" title="13.7 复制或者移动文件和目录"></a>13.7 复制或者移动文件和目录</h3><p><strong>Q: 你想要复制或移动文件和目录，但是又不想调用shell 命令。</strong></p><p>A: <code>shutil</code> 模块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="comment"># Copy src to dst. (cp src dst)</span></span><br><span class="line">shutil.copy(src, dst)</span><br><span class="line"><span class="comment"># Copy files, but preserve metadata (cp -p src dst)</span></span><br><span class="line">shutil.copy2(src, dst)</span><br><span class="line"><span class="comment"># Copy directory tree (cp -R src dst)</span></span><br><span class="line">shutil.copytree(src, dst)</span><br><span class="line"><span class="comment"># Move src to dst (mv src dst)</span></span><br><span class="line">shutil.move(src, dst)</span><br></pre></td></tr></table></figure><h3 id="13-8-创建和解压归档文件"><a href="#13-8-创建和解压归档文件" class="headerlink" title="13.8 创建和解压归档文件"></a>13.8 创建和解压归档文件</h3><p><strong>Q: 你需要创建或解压常见格式的归档文件（比如.tar, .tgz 或.zip）</strong></p><p>A: <code>shutil</code> 模块拥有两个函数——<code>make_archive()</code> 和<code>unpack_archive()</code> 可派上用场。例如：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> shutil</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shutil.unpack_archive(<span class="string">'Python-3.3.0.tgz'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shutil.make_archive(<span class="string">'py33'</span>,<span class="string">'zip'</span>,<span class="string">'Python-3.3.0'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="13-9-通过文件名查找文件"><a href="#13-9-通过文件名查找文件" class="headerlink" title="13.9 通过文件名查找文件"></a>13.9 通过文件名查找文件</h3><p><strong>Q: 你需要写一个涉及到文件查找操作的脚本，比如对日志归档文件的重命名工具，你不想在Python 脚本中调用shell，或者你要实现一些shell 不能做的功能。</strong></p><p>A: 用<code>os.walk()</code> 函数, <code>os.walk()</code> 方法为我们遍历目录树，每次进入一个目录，它会返回一个三元组，包<br>含相对于查找目录的相对路径，一个该目录下的目录名列表，以及那个目录下面的文件名列表。</p><h3 id="13-10-读取配置文件"><a href="#13-10-读取配置文件" class="headerlink" title="13.10 读取配置文件"></a>13.10 读取配置文件</h3><p><strong>Q: 怎样读取普通.ini 格式的配置文件？</strong></p><p>A: <code>configparser</code> 模块</p><h3 id="13-11-给简单脚本增加日志功能"><a href="#13-11-给简单脚本增加日志功能" class="headerlink" title="13.11 给简单脚本增加日志功能"></a>13.11 给简单脚本增加日志功能</h3><p><strong>Q: 你希望在脚本和程序中将诊断信息写入日志文件。</strong></p><p>A: <code>logging</code> 模块</p><h3 id="13-12-给函数库增加日志功能"><a href="#13-12-给函数库增加日志功能" class="headerlink" title="13.12 给函数库增加日志功能"></a>13.12 给函数库增加日志功能</h3><p><strong>Q: 你想给某个函数库增加日志功能，但是又不能影响到那些不使用日志功能的程序。</strong></p><p>A: <code>getLogger(__name__)</code>是给当前模块添加日志，相应的把<code>__name__</code>换成其他模块就是给其他模块添加(修改)日志</p><h3 id="13-13-实现一个计时器-略"><a href="#13-13-实现一个计时器-略" class="headerlink" title="13.13 实现一个计时器(略)"></a>13.13 实现一个计时器(略)</h3><h3 id="13-14-限制内存和CPU-的使用量"><a href="#13-14-限制内存和CPU-的使用量" class="headerlink" title="13.14 限制内存和CPU 的使用量"></a>13.14 限制内存和CPU 的使用量</h3><p><strong>Q: 你想对在Unix 系统上面运行的程序设置内存或CPU 的使用限制。</strong></p><p>A: <code>resource</code> 模块</p><h3 id="13-15-启动一个WEB-浏览器"><a href="#13-15-启动一个WEB-浏览器" class="headerlink" title="13.15 启动一个WEB 浏览器"></a>13.15 启动一个WEB 浏览器</h3><p><strong>Q: 你想通过脚本启动浏览器并打开指定的URL 网页</strong></p><p>A: <code>webbrowser</code> 模块</p><hr><hr><h2 id="第十四章：测试、调试和异常-待补充"><a href="#第十四章：测试、调试和异常-待补充" class="headerlink" title="第十四章：测试、调试和异常(待补充)"></a>第十四章：测试、调试和异常(待补充)</h2><hr><hr><h2 id="第十五章：C-语言扩展-待补充"><a href="#第十五章：C-语言扩展-待补充" class="headerlink" title="第十五章：C 语言扩展(待补充)"></a>第十五章：C 语言扩展(待补充)</h2>]]></content>
      
      
      <categories>
          
          <category> python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫系列(五)---获取可用代理</title>
      <link href="/2018/12/10/pa-chong-xi-lie-wu-huo-qu-ke-yong-dai-li/"/>
      <url>/2018/12/10/pa-chong-xi-lie-wu-huo-qu-ke-yong-dai-li/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests </span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> RequestException</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_ip</span><span class="params">(http,ip,port)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        proxies = &#123;<span class="string">"http"</span>: <span class="string">"http://"</span>+ip+<span class="string">":"</span>+port&#125;</span><br><span class="line">        print(proxies)</span><br><span class="line">        resp2 = requests.get(<span class="string">"http://2018.ip138.com/ic.asp"</span>, proxies=proxies)</span><br><span class="line">        soup = BeautifulSoup(resp2.content.decode(<span class="string">"gbk"</span>), <span class="string">"html.parser"</span>)</span><br><span class="line">        <span class="keyword">return</span> soup.body.get_text()</span><br><span class="line">    <span class="keyword">except</span> RequestException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_proxy</span><span class="params">(index)</span>:</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36"</span></span><br><span class="line">    &#125;</span><br><span class="line">    html = requests.get(<span class="string">f"https://www.xicidaili.com/nn/<span class="subst">&#123;index&#125;</span>"</span>,headers=headers)</span><br><span class="line">    <span class="comment">#print(html.text)</span></span><br><span class="line">    soup = BeautifulSoup(html.content,<span class="string">"lxml"</span>)</span><br><span class="line">    get_info = soup.find_all(<span class="string">"tr"</span>)</span><br><span class="line">    <span class="comment">#print(get_info[1])</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> get_info:</span><br><span class="line">        get_ip = re.match(<span class="string">"&lt;tr.+?&gt;.&lt;td.+?&gt;&lt;/td&gt;.&lt;td&gt;(.+?)&lt;/td&gt;.&lt;td&gt;(.+?)&lt;/td&gt;.+(HTTP\w)"</span>,str(i),re.S)</span><br><span class="line">        <span class="comment"># &lt;tr.+?&gt;.&lt;td.+?&gt;&lt;/td&gt;.&lt;td&gt;(.+?)&lt;/td&gt;.&lt;td&gt;(.+?)&lt;/td&gt;.+(HTTP\w)</span></span><br><span class="line">        <span class="keyword">if</span> get_ip:</span><br><span class="line">            <span class="comment">#print(f"&#123;get_ip.group(3)&#125;://&#123;get_ip.group(1)&#125;:&#123;get_ip.group(2)&#125;")</span></span><br><span class="line">            ip = parse_ip(get_ip.group(<span class="number">3</span>),get_ip.group(<span class="number">1</span>),get_ip.group(<span class="number">2</span>))</span><br><span class="line">            <span class="comment">#print(ip)</span></span><br><span class="line">            time.sleep(<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">if</span> ip:</span><br><span class="line">                <span class="keyword">return</span> ip</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(get_proxy(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python3 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫系列(四)---保持登陆</title>
      <link href="/2018/12/05/pa-chong-xi-lie-si-bao-chi-deng-lu/"/>
      <url>/2018/12/05/pa-chong-xi-lie-si-bao-chi-deng-lu/</url>
      
        <content type="html"><![CDATA[<p>在爬取一些网站的时候，需要登陆，而且需要一直保持登陆状态才可以看一些文章，比如知乎、微博，这时我们就需要把我们的登陆信息在请求的时候一并提交，而这个登陆信息就是cookies</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests </span><br><span class="line"><span class="keyword">from</span>  urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="comment"># 可以保持同一个cookies，保持登陆状态</span></span><br><span class="line"><span class="comment">#s = s.Session()</span></span><br><span class="line"><span class="comment">#s = s.get("https://weibo.com") # 没有登陆的状态</span></span><br><span class="line"><span class="comment">#print(s.text)</span></span><br><span class="line"><span class="comment"># 不知道为什么用 requests 请求到的网页是中文乱码，而且不能用 bg2313 解码</span></span><br><span class="line"><span class="comment"># 但是用 uurllib 的就没事，这里暂时先不管了</span></span><br><span class="line"><span class="comment">#s = urlopen("https://weibo.com")</span></span><br><span class="line"><span class="comment">#print(s.read().decode("gb2312"))</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"Cookie"</span>: <span class="string">"太长了，这里就不写了"</span>,</span><br><span class="line">    <span class="string">"Host"</span>: <span class="string">"weibo.com"</span>,</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s = requests.Session()</span><br><span class="line">s = s.get(<span class="string">"这里的地址必须是跟你在Request URL看到的一样"</span>,headers=headers)</span><br><span class="line">print(s.text)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python3 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3基础知识系列--函数装饰器</title>
      <link href="/2018/12/03/python3-ji-chu-zhi-shi-xi-lie-han-shu-zhuang-shi-qi/"/>
      <url>/2018/12/03/python3-ji-chu-zhi-shi-xi-lie-han-shu-zhuang-shi-qi/</url>
      
        <content type="html"><![CDATA[<p><strong>装饰器</strong>是一个函数，其主要用途是包装另一个函数或类。这种包装的首要目的是光明正大地修改或增强被包装对象的行为。语法上使用 特殊符号<code>@</code> 表示装饰器，如下所示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@trace</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">　　 <span class="keyword">return</span> x*x</span><br></pre></td></tr></table></figure><p>上面的代码是下面代码的简化：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">　　<span class="keyword">return</span> x*x</span><br><span class="line">square = trace(square)</span><br></pre></td></tr></table></figure><p>下面介绍几种用法：</p><p>在类定义中，所有函数都被假定在实例上操作，该实例总是作为第一个参数self 传递。但是，还可以定义两种常见的方法。</p><p><strong>静态方法</strong> 是一种普通函数，只不过它们正好位于类定义的命名空间中。它不会对任何实例类型进行操作。要定义静态方<br>法，可使用<code>@staticmethod</code> 装饰器，如下所示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">　　 @staticmethod</span><br><span class="line">　　 <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x,y)</span>:</span></span><br><span class="line">　　　　 <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure><p>要调用静态方法，只需用类名作为它的前缀。无需向它传递任何其他信息，例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = Foo.add(<span class="number">3</span>,<span class="number">4</span>)　　 <span class="comment"># x = 7</span></span><br></pre></td></tr></table></figure><p>如果在编写类时需要采用很多不同的方式来创建新实例，则常常使用静态方法。因为类中只能有一个<code>__init__()</code> 函数，所以替代的创建函数通常按如下方式定义：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span><span class="params">(object)</span>:</span></span><br><span class="line">　　<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,year,month,day)</span>:</span></span><br><span class="line">　　　　self.year = year</span><br><span class="line">　　　　self.month = month</span><br><span class="line">　　　　self.day = day</span><br><span class="line">　　@staticmethod</span><br><span class="line">　　<span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">　　　　 t = time.localtime()</span><br><span class="line">　　　　 <span class="keyword">return</span> Date(t.tm_year, t.tm_mon, t.tm_day)</span><br><span class="line">　　@staticmethod</span><br><span class="line">　　<span class="function"><span class="keyword">def</span> <span class="title">tomorrow</span><span class="params">()</span>:</span></span><br><span class="line">　　　　 t = time.localtime(time.time()+<span class="number">86400</span>)</span><br><span class="line">　　　　 <span class="keyword">return</span> Date(t.tm_year, t.tm_mon, t.tm_day)</span><br><span class="line"><span class="comment"># 创建日期的示例</span></span><br><span class="line">a = Date(<span class="number">1967</span>, <span class="number">4</span>, <span class="number">9</span>)</span><br><span class="line">b = Date.now()　　　　 <span class="comment"># 调用静态方法now()</span></span><br><span class="line">c = Date.tomorrow()　　<span class="comment"># 调用静态方法tomorrow()</span></span><br></pre></td></tr></table></figure><p><strong>类方法</strong> 是将类本身作为对象进行操作的方法。类方法使用<code>@classmethod</code> 装饰器定义，与实例方法不同，因为根据约定，类是作为第一个参数（名为cls ）传递的，例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Times</span><span class="params">(object)</span>:</span></span><br><span class="line">　　factor = <span class="number">1</span></span><br><span class="line">　　@classmethod</span><br><span class="line">　　<span class="function"><span class="keyword">def</span> <span class="title">mul</span><span class="params">(cls,x)</span>:</span></span><br><span class="line">　　　　<span class="keyword">return</span> cls.factor*x</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoTimes</span><span class="params">(Times)</span>:</span></span><br><span class="line">　　factor = <span class="number">2</span></span><br><span class="line">x = TwoTimes.mul(<span class="number">4</span>)　　<span class="comment"># 调用Times.mul(TwoTimes, 4) -&gt; 8</span></span><br></pre></td></tr></table></figure><p>最后介绍一个装饰器函数是<code>@property</code>, 是将对象的方法变为属性的一个装饰器，这个在<strong>python3cookbook</strong>系列中讲过了，这里就不举例了</p>]]></content>
      
      
      <categories>
          
          <category> python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习实战笔记(五)---决策树(二)</title>
      <link href="/2018/12/02/ji-qi-xue-xi-shi-zhan-bi-ji-wu-jue-ce-shu-er/"/>
      <url>/2018/12/02/ji-qi-xue-xi-shi-zhan-bi-ji-wu-jue-ce-shu-er/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2018/1/3 14:02</span></span><br><span class="line"><span class="comment"># @Author  : wangzy</span></span><br><span class="line"><span class="comment"># 原文代码作者：https://github.com/wzyonggege/statistical-learning-method</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 中文注释制作：机器学习初学者(微信公众号：ID:ai-start-com)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 配置环境：python 3.6</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义节点类 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root=True, label=None, feature_name=None, feature=None)</span>:</span></span><br><span class="line">        self.root = root</span><br><span class="line">        self.label = label</span><br><span class="line">        self.feature_name = feature_name</span><br><span class="line">        self.feature = feature</span><br><span class="line">        self.tree = &#123;&#125;</span><br><span class="line">        self.result = &#123;<span class="string">'label:'</span>: self.label, <span class="string">'feature'</span>: self.feature, <span class="string">'tree'</span>: self.tree&#125;</span><br><span class="line">    <span class="comment"># 调用 __repr__ 而不是 __str__</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;'</span>.format(self.result)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_node</span><span class="params">(self, val, node)</span>:</span></span><br><span class="line">        self.tree[val] = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, features)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">return</span> self.label</span><br><span class="line">        <span class="keyword">return</span> self.tree[features[self.feature]].predict(features)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 书上题目5.1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_data</span><span class="params">()</span>:</span></span><br><span class="line">    datasets = [[<span class="string">'青年'</span>, <span class="string">'否'</span>, <span class="string">'否'</span>, <span class="string">'一般'</span>, <span class="string">'否'</span>],</span><br><span class="line">               [<span class="string">'青年'</span>, <span class="string">'否'</span>, <span class="string">'否'</span>, <span class="string">'好'</span>, <span class="string">'否'</span>],</span><br><span class="line">               [<span class="string">'青年'</span>, <span class="string">'是'</span>, <span class="string">'否'</span>, <span class="string">'好'</span>, <span class="string">'是'</span>],</span><br><span class="line">               [<span class="string">'青年'</span>, <span class="string">'是'</span>, <span class="string">'是'</span>, <span class="string">'一般'</span>, <span class="string">'是'</span>],</span><br><span class="line">               [<span class="string">'青年'</span>, <span class="string">'否'</span>, <span class="string">'否'</span>, <span class="string">'一般'</span>, <span class="string">'否'</span>],</span><br><span class="line">               [<span class="string">'中年'</span>, <span class="string">'否'</span>, <span class="string">'否'</span>, <span class="string">'一般'</span>, <span class="string">'否'</span>],</span><br><span class="line">               [<span class="string">'中年'</span>, <span class="string">'否'</span>, <span class="string">'否'</span>, <span class="string">'好'</span>, <span class="string">'否'</span>],</span><br><span class="line">               [<span class="string">'中年'</span>, <span class="string">'是'</span>, <span class="string">'是'</span>, <span class="string">'好'</span>, <span class="string">'是'</span>],</span><br><span class="line">               [<span class="string">'中年'</span>, <span class="string">'否'</span>, <span class="string">'是'</span>, <span class="string">'非常好'</span>, <span class="string">'是'</span>],</span><br><span class="line">               [<span class="string">'中年'</span>, <span class="string">'否'</span>, <span class="string">'是'</span>, <span class="string">'非常好'</span>, <span class="string">'是'</span>],</span><br><span class="line">               [<span class="string">'老年'</span>, <span class="string">'否'</span>, <span class="string">'是'</span>, <span class="string">'非常好'</span>, <span class="string">'是'</span>],</span><br><span class="line">               [<span class="string">'老年'</span>, <span class="string">'否'</span>, <span class="string">'是'</span>, <span class="string">'好'</span>, <span class="string">'是'</span>],</span><br><span class="line">               [<span class="string">'老年'</span>, <span class="string">'是'</span>, <span class="string">'否'</span>, <span class="string">'好'</span>, <span class="string">'是'</span>],</span><br><span class="line">               [<span class="string">'老年'</span>, <span class="string">'是'</span>, <span class="string">'否'</span>, <span class="string">'非常好'</span>, <span class="string">'是'</span>],</span><br><span class="line">               [<span class="string">'老年'</span>, <span class="string">'否'</span>, <span class="string">'否'</span>, <span class="string">'一般'</span>, <span class="string">'否'</span>],</span><br><span class="line">               ]</span><br><span class="line">    <span class="comment"># 每行的名字</span></span><br><span class="line">    labels = [<span class="string">u'年龄'</span>, <span class="string">u'有工作'</span>, <span class="string">u'有自己的房子'</span>, <span class="string">u'信贷情况'</span>, <span class="string">u'类别'</span>]</span><br><span class="line">    <span class="comment"># 返回数据集和每个维度的名称</span></span><br><span class="line">    <span class="keyword">return</span> datasets, labels</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, epsilon=<span class="number">0.1</span>)</span>:</span></span><br><span class="line">        self.epsilon = epsilon</span><br><span class="line">        self._tree = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 熵</span></span><br><span class="line"><span class="meta">    @staticmethod # 声明的静态方法，因此无需实例化，不用写self，可以直接使用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc_ent</span><span class="params">(datasets)</span>:</span></span><br><span class="line">        data_length = len(datasets)</span><br><span class="line">        label_count = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(data_length):</span><br><span class="line">            label = datasets[i][<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> label <span class="keyword">not</span> <span class="keyword">in</span> label_count:</span><br><span class="line">                label_count[label] = <span class="number">0</span></span><br><span class="line">            label_count[label] += <span class="number">1</span></span><br><span class="line">        ent = -sum([(p/data_length)*log(p/data_length, <span class="number">2</span>) <span class="keyword">for</span> p <span class="keyword">in</span> label_count.values()])</span><br><span class="line">        <span class="keyword">return</span> ent</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 经验条件熵</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cond_ent</span><span class="params">(self, datasets, axis=<span class="number">0</span>)</span>:</span></span><br><span class="line">        data_length = len(datasets)</span><br><span class="line">        feature_sets = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(data_length):</span><br><span class="line">            feature = datasets[i][axis]</span><br><span class="line">            <span class="keyword">if</span> feature <span class="keyword">not</span> <span class="keyword">in</span> feature_sets:</span><br><span class="line">                feature_sets[feature] = []</span><br><span class="line">            feature_sets[feature].append(datasets[i])</span><br><span class="line">        cond_ent = sum([(len(p)/data_length)*self.calc_ent(p) <span class="keyword">for</span> p <span class="keyword">in</span> feature_sets.values()])</span><br><span class="line">        <span class="keyword">return</span> cond_ent</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 信息增益</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info_gain</span><span class="params">(ent, cond_ent)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> ent - cond_ent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info_gain_train</span><span class="params">(self, datasets)</span>:</span></span><br><span class="line">        count = len(datasets[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        ent = self.calc_ent(datasets) <span class="comment"># 获得信息熵</span></span><br><span class="line">        best_feature = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(count):</span><br><span class="line">            c_info_gain = self.info_gain(ent, self.cond_ent(datasets, axis=c)) <span class="comment"># 计算信息增益</span></span><br><span class="line">            best_feature.append((c, c_info_gain)) <span class="comment"># 存于列表中，然后选出信息增益最大的</span></span><br><span class="line">        <span class="comment"># 比较大小</span></span><br><span class="line">        best_ = max(best_feature, key=<span class="keyword">lambda</span> x: x[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> best_</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, train_data)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        input:数据集D(DataFrame格式)，特征集A，阈值eta</span></span><br><span class="line"><span class="string">        output:决策树T</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        1. 计算信息熵 H(D)</span></span><br><span class="line"><span class="string">        2. 获取信息增益最大的类别</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 训练集，类别(y值),列名</span></span><br><span class="line">        _, y_train, features = train_data.iloc[:, :<span class="number">-1</span>], train_data.iloc[:, <span class="number">-1</span>], train_data.columns[:<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 1,若D中实例属于同一类Ck，则T为单节点树，并将类Ck作为结点的类标记，返回T</span></span><br><span class="line">        <span class="keyword">if</span> len(y_train.value_counts()) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> Node(root=<span class="keyword">True</span>,</span><br><span class="line">                        label=y_train.iloc[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2, 若A为空，则T为单节点树，将D中实例树最大的类Ck作为该节点的类标记，返回T</span></span><br><span class="line">        <span class="keyword">if</span> len(features) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> Node(root=<span class="keyword">True</span>, label=y_train.value_counts().sort_values(ascending=<span class="keyword">False</span>).index[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3,计算最大信息增益 同5.1,Ag为信息增益最大的特征</span></span><br><span class="line">        max_feature, max_info_gain = self.info_gain_train(np.array(train_data))</span><br><span class="line">        max_feature_name = features[max_feature]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4,Ag的信息增益小于阈值eta,则置T为单节点树，并将D中是实例数最大的类Ck作为该节点的类标记，返回T</span></span><br><span class="line">        <span class="keyword">if</span> max_info_gain &lt; self.epsilon:</span><br><span class="line">            <span class="keyword">return</span> Node(root=<span class="keyword">True</span>, label=y_train.value_counts().sort_values(ascending=<span class="keyword">False</span>).index[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 5,构建Ag子集</span></span><br><span class="line">        node_tree = Node(root=<span class="keyword">False</span>, feature_name=max_feature_name, feature=max_feature)</span><br><span class="line"></span><br><span class="line">        feature_list = train_data[max_feature_name].value_counts().index</span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> feature_list:</span><br><span class="line">            sub_train_df = train_data.loc[train_data[max_feature_name] == f].drop([max_feature_name], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 6, 递归生成树</span></span><br><span class="line">            sub_tree = self.train(sub_train_df)</span><br><span class="line">            node_tree.add_node(f, sub_tree)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># pprint.pprint(node_tree.tree)</span></span><br><span class="line">        <span class="keyword">return</span> node_tree</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, train_data)</span>:</span></span><br><span class="line">        self._tree = self.train(train_data)</span><br><span class="line">        <span class="keyword">return</span> self._tree</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X_test)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._tree.predict(X_test)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 数据是统计学与方法中的立体</span></span><br><span class="line">    datasets, labels = create_data()</span><br><span class="line">    data_df = pd.DataFrame(datasets, columns=labels)</span><br><span class="line">    <span class="comment">#print(data_df)</span></span><br><span class="line">    dt = DTree()</span><br><span class="line">    tree = dt.fit(data_df)</span><br><span class="line">    print(dt.predict([<span class="string">'老年'</span>, <span class="string">'否'</span>, <span class="string">'否'</span>, <span class="string">'一般'</span>]))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python3 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3基础知识系列--匿名函数</title>
      <link href="/2018/12/01/python3-ji-chu-zhi-shi-xi-lie-ni-ming-han-shu/"/>
      <url>/2018/12/01/python3-ji-chu-zhi-shi-xi-lie-ni-ming-han-shu/</url>
      
        <content type="html"><![CDATA[<p>匿名函数其实就是lambda函数，不需要显示定义函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x: x*x</span><br><span class="line">f(<span class="number">6</span>)</span><br><span class="line"><span class="comment"># 36</span></span><br></pre></td></tr></table></figure><p>这个等价于：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br></pre></td></tr></table></figure><p>但是匿名函数有一个限制就是只能写一个表达式</p><p>此外，<code>lambda</code>函数还可以与<code>map</code>, <code>sorted</code>等函数配合使用，我们以后再整理</p><p>list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</p><h1 id="1-4-9-16-25-36-49-64-81"><a href="#1-4-9-16-25-36-49-64-81" class="headerlink" title="[1, 4, 9, 16, 25, 36, 49, 64, 81]"></a>[1, 4, 9, 16, 25, 36, 49, 64, 81]</h1>]]></content>
      
      
      <categories>
          
          <category> python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 标准库系列(六)---base64</title>
      <link href="/2018/11/30/python3-biao-zhun-ku-xi-lie-liu-base64/"/>
      <url>/2018/11/30/python3-biao-zhun-ku-xi-lie-liu-base64/</url>
      
        <content type="html"><![CDATA[<p>Base64是一种用64个字符来表示任意二进制数据的方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将二进制转为64位 存储</span></span><br><span class="line">base64.b64encode(<span class="string">b'hello world'</span>)</span><br></pre></td></tr></table></figure><pre><code>b&#39;aGVsbG8gd29ybGQ=&#39;</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">base64.b64decode(<span class="string">b'aGVsbG8gd29ybGQ='</span>) <span class="comment"># 解码</span></span><br></pre></td></tr></table></figure><pre><code>b&#39;hello world&#39;</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">base64.b64decode(<span class="string">b'aGVsbG8gd29ybGQ='</span>).decode(<span class="string">"utf-8"</span>)</span><br></pre></td></tr></table></figure><pre><code>&#39;hello world&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用python3写的cgi服务器脚本无法显示中文</title>
      <link href="/2018/11/28/yong-python3-xie-de-cgi-fu-wu-qi-jiao-ben-wu-fa-xian-shi-zhong-wen/"/>
      <url>/2018/11/28/yong-python3-xie-de-cgi-fu-wu-qi-jiao-ben-wu-fa-xian-shi-zhong-wen/</url>
      
        <content type="html"><![CDATA[<p>在脚本前加上如下两句即可正常显示中文</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> codecs, sys</span><br><span class="line">sys.stdout = codecs.getwriter(<span class="string">'utf8'</span>)(sys.stdout.buffer)</span><br></pre></td></tr></table></figure><p>脚本示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/miniconda3/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> codecs, sys</span><br><span class="line">sys.stdout = codecs.getwriter(<span class="string">'utf8'</span>)(sys.stdout.buffer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Content-type:text/html"</span>)</span><br><span class="line"><span class="keyword">print</span> ()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'&lt;html&gt;'</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'&lt;head&gt;'</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'&lt;meta charset="utf-8"&gt;'</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'&lt;title&gt;Hello Word&lt;/title&gt;'</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'&lt;/head&gt;'</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'&lt;body&gt;'</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'&lt;h2&gt;Hello Word!中文测试&lt;/h2&gt;'</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'&lt;/body&gt;'</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'&lt;/html&gt;'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vimrc文件简单配置</title>
      <link href="/2018/11/27/linux-xi-lie-vim-pei-zhi/"/>
      <url>/2018/11/27/linux-xi-lie-vim-pei-zhi/</url>
      
        <content type="html"><![CDATA[<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">"关闭vi兼容模式</span></span><br><span class="line"><span class="keyword">set</span> nocompatible</span><br><span class="line"><span class="comment">"设置字符编码</span></span><br><span class="line"><span class="keyword">set</span> fileencoding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">set</span> fileencodings=utf-<span class="number">8</span>,gb2312,gb18030,latin1</span><br><span class="line"><span class="keyword">set</span> termencoding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">set</span> encoding=utf-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="string">"set mouse=a"</span>启用鼠标</span><br><span class="line"><span class="comment">" 语法高亮</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" 检测文件类型</span></span><br><span class="line"><span class="comment">" filetype on</span></span><br><span class="line"><span class="comment">"根据文件类型加载对应的插件, 未安装插件</span></span><br><span class="line"><span class="comment">" filetype plugin on</span></span><br><span class="line"><span class="string">" filetype indent on "</span> 开启文件类型检查，并且载入与该类型对应的缩进规则,未配置</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> ruler <span class="comment">" 打开状态栏标尺</span></span><br><span class="line"><span class="keyword">set</span> smarttab <span class="comment">" 使得按退格键时可以一次删掉4个空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" 显示行号</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span></span><br><span class="line"><span class="comment">" 在第99列显示竖线</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">cc</span>=<span class="number">99</span></span><br><span class="line"><span class="comment">" 高亮显示当前行</span></span><br><span class="line"><span class="keyword">set</span> cursorline</span><br><span class="line"><span class="keyword">set</span> showmode <span class="comment">" 在底部显示，当前处于命令模式还是插入模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" 设置各种缩进</span></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span></span><br><span class="line"><span class="keyword">set</span> softtabstop=<span class="number">4</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span> <span class="comment">" 设定&lt;&lt;和&gt;&gt;命令移动时的宽度为4</span></span><br><span class="line"><span class="keyword">set</span> autoindent <span class="comment">" 按下回车键后，下一行的缩进会自动跟上一行的缩进保持一致</span></span><br><span class="line"><span class="keyword">set</span> smartindent</span><br><span class="line"><span class="keyword">set</span> <span class="built_in">cindent</span></span><br><span class="line"><span class="keyword">set</span> smartindent <span class="comment">" 开启新行时使用智能自动缩进</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" 如果行尾有多余的空格（包括Tab键），该配置将让这些空格显示成可见的小方块。</span></span><br><span class="line"><span class="comment">" set listchars=tab:»■,trail:■</span></span><br><span class="line"><span class="comment">" set list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> hlsearch <span class="comment">" 搜索时高亮显示被找到的文本</span></span><br><span class="line"><span class="keyword">set</span> noerrorbells <span class="comment">" 关闭错误信息响铃</span></span><br><span class="line"><span class="keyword">set</span> novisualbell <span class="comment">" 关闭使用可视响铃代替呼叫</span></span><br><span class="line"><span class="keyword">set</span> smartindent <span class="comment">" 开启新行时使用智能自动缩进</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">" Python文件的一般设置，比如不要tab等</span></span><br><span class="line"><span class="keyword">autocmd</span> FileType <span class="keyword">python</span> <span class="keyword">set</span> tabstop=<span class="number">4</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span> expandtab</span><br><span class="line"><span class="keyword">autocmd</span> FileType <span class="keyword">python</span> <span class="keyword">map</span> <span class="symbol">&lt;F12&gt;</span> :!python %<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="string">" set expandtab "</span> <span class="keyword">tab</span> 转换为空格</span><br><span class="line"><span class="string">" set softtabstop=2 "</span> Tab转为多少个空格</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习实战笔记(六)---kNN算法(二)-使用鸢尾花数据集</title>
      <link href="/2018/11/25/ji-qi-xue-xi-shi-zhan-bi-ji-liu-knn-suan-fa-er/"/>
      <url>/2018/11/25/ji-qi-xue-xi-shi-zhan-bi-ji-liu-knn-suan-fa-er/</url>
      
        <content type="html"><![CDATA[<p>python实现，遍历所有数据点，找出n个距离最近的点的分类情况，少数服从多数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原文代码作者：https://github.com/wzyonggege/statistical-learning-method</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 中文注释制作：机器学习初学者(微信公众号：ID:ai-start-com)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 配置环境：python 3.6</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">get_ipython().run_line_magic(<span class="string">'matplotlib'</span>, <span class="string">'inline'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line">df = pd.DataFrame(iris.data, columns=iris.feature_names)</span><br><span class="line">df[<span class="string">'label'</span>] = iris.target</span><br><span class="line">df.columns = [<span class="string">'sepal length'</span>, <span class="string">'sepal width'</span>, <span class="string">'petal length'</span>, <span class="string">'petal width'</span>, <span class="string">'label'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.scatter(df[:<span class="number">50</span>][<span class="string">'sepal length'</span>], df[:<span class="number">50</span>][<span class="string">'sepal width'</span>], label=<span class="string">'0'</span>)</span><br><span class="line">plt.scatter(df[<span class="number">50</span>:<span class="number">100</span>][<span class="string">'sepal length'</span>], df[<span class="number">50</span>:<span class="number">100</span>][<span class="string">'sepal width'</span>], label=<span class="string">'1'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'sepal length'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'sepal width'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = np.array(df.iloc[:<span class="number">100</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>]])</span><br><span class="line">X, y = data[:,:<span class="number">-1</span>], data[:,<span class="number">-1</span>]</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KNN</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, X_train, y_train, n_neighbors=<span class="number">3</span>, p=<span class="number">2</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        parameter: n_neighbors 临近点个数</span></span><br><span class="line"><span class="string">        parameter: p 距离度量</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.n = n_neighbors</span><br><span class="line">        self.p = p</span><br><span class="line">        self.X_train = X_train</span><br><span class="line">        self.y_train = y_train</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="comment"># 取出n个点</span></span><br><span class="line">        knn_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.n):</span><br><span class="line">            dist = np.linalg.norm(X - self.X_train[i], ord=self.p)</span><br><span class="line">            knn_list.append((dist, self.y_train[i]))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.n, len(self.X_train)):</span><br><span class="line">            max_index = knn_list.index(max(knn_list, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]))</span><br><span class="line">            dist = np.linalg.norm(X - self.X_train[i], ord=self.p)</span><br><span class="line">            <span class="keyword">if</span> knn_list[max_index][<span class="number">0</span>] &gt; dist:</span><br><span class="line">                knn_list[max_index] = (dist, self.y_train[i])</span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 统计</span></span><br><span class="line">        knn = [k[<span class="number">-1</span>] <span class="keyword">for</span> k <span class="keyword">in</span> knn_list]</span><br><span class="line">        count_pairs = Counter(knn)</span><br><span class="line">        max_count = sorted(count_pairs, key=<span class="keyword">lambda</span> x:x)[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> max_count</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, X_test, y_test)</span>:</span></span><br><span class="line">        right_count = <span class="number">0</span></span><br><span class="line">        n = <span class="number">10</span></span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> zip(X_test, y_test):</span><br><span class="line">            label = self.predict(X)</span><br><span class="line">            <span class="keyword">if</span> label == y:</span><br><span class="line">                right_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right_count / len(X_test)</span><br><span class="line"></span><br><span class="line">clf = KNN(X_train, y_train)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clf.score(X_test, y_test)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test_point = [<span class="number">6.0</span>, <span class="number">3.0</span>]</span><br><span class="line">print(<span class="string">'Test Point: &#123;&#125;'</span>.format(clf.predict(test_point)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.scatter(df[:<span class="number">50</span>][<span class="string">'sepal length'</span>], df[:<span class="number">50</span>][<span class="string">'sepal width'</span>], label=<span class="string">'0'</span>)</span><br><span class="line">plt.scatter(df[<span class="number">50</span>:<span class="number">100</span>][<span class="string">'sepal length'</span>], df[<span class="number">50</span>:<span class="number">100</span>][<span class="string">'sepal width'</span>], label=<span class="string">'1'</span>)</span><br><span class="line">plt.plot(test_point[<span class="number">0</span>], test_point[<span class="number">1</span>], <span class="string">'bo'</span>, label=<span class="string">'test_point'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'sepal length'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'sepal width'</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure><p>当然也可以使用<code>sklearn</code>快速实现,中文文档地址：<a href="http://sklearn.apachecn.org/cn/0.19.0/" target="_blank" rel="noopener">http://sklearn.apachecn.org/cn/0.19.0/</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line">clf_sk = KNeighborsClassifier()</span><br><span class="line">clf_sk.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">clf_sk.score(X_test, y_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ### sklearn.neighbors.KNeighborsClassifier</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># - n_neighbors: 临近点个数</span></span><br><span class="line"><span class="comment"># - p: 距离度量</span></span><br><span class="line"><span class="comment"># - algorithm: 近邻算法，可选&#123;'auto', 'ball_tree', 'kd_tree', 'brute'&#125;</span></span><br><span class="line"><span class="comment"># - weights: 确定近邻的权重</span></span><br></pre></td></tr></table></figure><p><em>下一小节：kd树的实现</em></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python3 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(转)linux下查看CPU、内存、磁盘信息</title>
      <link href="/2018/11/24/linux-xi-lie-cha-kan-cpu-deng-xin-xi/"/>
      <url>/2018/11/24/linux-xi-lie-cha-kan-cpu-deng-xin-xi/</url>
      
        <content type="html"><![CDATA[<p>文章内容来源：<a href="https://www.cnblogs.com/xubiao/p/6497533.html" target="_blank" rel="noopener">https://www.cnblogs.com/xubiao/p/6497533.html</a></p><p><strong>查看CPU信息</strong></p><p>总核数 = 物理CPU个数 X 每颗物理CPU的核数</p><p>总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数</p><p><strong>查看物理CPU个数</strong><br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo| grep <span class="string">"physical id"</span>| sort| uniq| wc -l</span><br></pre></td></tr></table></figure></p><p><strong>查看每个物理CPU中core的个数(即核数)</strong><br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo| grep <span class="string">"cpu cores"</span>| uniq</span><br></pre></td></tr></table></figure></p><p><strong>查看逻辑CPU的个数</strong><br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo| grep <span class="string">"processor"</span>| wc -l</span><br></pre></td></tr></table></figure></p><p><strong>查看CPU信息（型号）</strong><br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br></pre></td></tr></table></figure></p><p><strong>查看CPU的负载</strong></p><p><strong>平均负载</strong>是指上一分钟同时处于就绪状态的平均进程数。在CPU中可以理解为CPU可以并行处理的任务数量，就是CPU个数X核数。</p><p>如果CPU Load等于CPU个数乘以核数，那么就说CPU正好满负载，再多一点，可能就要出问题了，有些任务不能被及时分配处理器，那要保证性能的话，最好要小于CPU个数X核数X0.7。</p><p>Load Average是指CPU的Load。它所包含的信息是在一段时间内CPU正在处理及等待CPU处理的进程数之和的统计信息，也就是CPU使用队列的长度的统计信息。</p><p>Load Average的值应该小于CPU个数X核数X0.7，Load Average会有3个状态平均值，分别是1分钟、5分钟和15分钟平均Load。</p><p>如果1分钟平均出现大于CPU个数X核数的情况，还不需要担心；如果5分钟的平均也是这样，那就要警惕了；15分钟的平均也是这样，就要分析哪里出现问题，防范未然。</p><p><strong>查看内存信息</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cat /proc/meminfo</span><br><span class="line">$ free </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">**查看磁盘信息**</span><br><span class="line">```sh</span><br><span class="line">$ fdisk -l</span><br><span class="line">$ iostat -x 10    <span class="comment">#查看磁盘IO的性能</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git极简入门</title>
      <link href="/2018/11/23/git-ji-jian-ru-men/"/>
      <url>/2018/11/23/git-ji-jian-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装-略"><a href="#1-安装-略" class="headerlink" title="1. 安装(略)"></a>1. 安装(略)</h2><h2 id="2-基础命令"><a href="#2-基础命令" class="headerlink" title="2.基础命令"></a>2.基础命令</h2><p><code>git config --global user.name &quot;Your Name&quot;</code><br><code>git config --global user.email &quot;email@example.com&quot;</code></p><p><code>git init [dir]</code> : 目录变成Git可以管理的仓库<br><code>git add [file] [file]...</code> : 添加文件到仓库<br><code>git commit -m &quot;一些版本描述&quot;</code> : 把(多个)文件交给仓库<br><code>git log --pretty=oneline</code> : 改动日志<br><code>git reset --hard HEAD^</code> || <code>git reset --hard HEAD^^</code> : 切换到上次修改，或者上上次修改<br><code>git reset --hard [哈希值]</code> ： 切换到哈希值对应的版本号<br><code>git status</code> : 查看工作区状态<br><code>git diff</code> : 比较文件<br><code>git checkout -- [file]</code> ： 撤销工作区的修改，回到最近一次<code>git commit</code>或<code>git add</code>时的状态<br><code>git rm [file]</code>  : 从版本库里删除文件<br><code>git checkout [哈希值]</code> : 切换版本</p><h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/JeWeizhong/Machine-learning-in-action-notes-and-code.git</span><br><span class="line">git push -u origin master <span class="comment">#第一次提交</span></span><br><span class="line">git push origin master -f <span class="comment">#强制覆盖已有分支</span></span><br></pre></td></tr></table></figure><h2 id="远程仓库同步到本地"><a href="#远程仓库同步到本地" class="headerlink" title="远程仓库同步到本地"></a>远程仓库同步到本地</h2><p>１.　假如需要在另一个地方写项目可以用一下步骤：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/JeWeizhong/Machine-learning-in-action-notes-and-c <span class="comment"># 克隆到本地</span></span><br><span class="line"><span class="comment">#在本地修改后</span></span><br><span class="line">git add .</span><br><span class="line">git commit  -m <span class="string">"creat DTs"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><ol><li>假如本地已经有项目代码，需要同远程的项目合并：<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从远程的origin的master主分支下载最新的版本到origin/master分支上</span></span><br><span class="line">Git fetch origin master </span><br><span class="line"><span class="comment"># 比较本地的master分支和origin/master分支的差别</span></span><br><span class="line">git <span class="built_in">log</span> -p master ..origin/master</span><br><span class="line">git merge origin/master <span class="comment"># 合并</span></span><br></pre></td></tr></table></figure></li></ol><p>第二种方式：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从远程下载到master下的tmp分支上</span></span><br><span class="line">git fetch origin master:tmp </span><br><span class="line"><span class="comment"># 比较</span></span><br><span class="line">git diff tmp </span><br><span class="line"><span class="comment"># 合并</span></span><br><span class="line">git merge tmp</span><br></pre></td></tr></table></figure></p><p>或者直接用<code>git pull origin master</code>，但是看不到细节</p><ol><li><em>目前还没学会分支</em></li></ol>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫系列(三)---抓取淘宝商品</title>
      <link href="/2018/11/22/pa-chong-xi-lie-san-zhua-qu-tao-bao-shang-pin/"/>
      <url>/2018/11/22/pa-chong-xi-lie-san-zhua-qu-tao-bao-shang-pin/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> html.parser</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.desired_capabilities <span class="keyword">import</span> DesiredCapabilities</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome(<span class="string">"E:\\Program Files\\chromedriver_win32\\chromedriver.exe"</span>)</span><br><span class="line"><span class="comment">#browser = webdriver.Chrome()</span></span><br><span class="line">wait = WebDriverWait(browser, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getProducts</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    提取商品数据</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    html = browser.page_source</span><br><span class="line">    <span class="comment"># 解析</span></span><br><span class="line">    doc = pq(html)</span><br><span class="line">    <span class="comment"># 找id，子标签是商品列表</span></span><br><span class="line">    items = doc(<span class="string">'#mainsrp-itemlist .items .item'</span>).items()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        product = &#123;</span><br><span class="line">            <span class="string">'image'</span>: item.find(<span class="string">'.pic .img'</span>).attr(<span class="string">'data-src'</span>),</span><br><span class="line">            <span class="string">'price'</span>: item.find(<span class="string">'.price'</span>).text(),</span><br><span class="line">            <span class="string">'deal'</span>: item.find(<span class="string">'.deal-cnt'</span>).text(),</span><br><span class="line">            <span class="string">'title'</span>: item.find(<span class="string">'.title'</span>).text(),</span><br><span class="line">            <span class="string">'shop'</span>: item.find(<span class="string">'.shop'</span>).text(),</span><br><span class="line">            <span class="string">'location'</span>: item.find(<span class="string">'.location'</span>).text()</span><br><span class="line">        &#125;</span><br><span class="line">        print(product)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        browser.get(<span class="string">"https://www.taobao.com/"</span>)</span><br><span class="line">        <span class="comment"># 登陆，淘宝反爬虫，目前是手动扫码登陆，做了个sleep等待时间</span></span><br><span class="line">        login = wait.until(</span><br><span class="line">            EC.element_to_be_clickable((By.CSS_SELECTOR,<span class="string">'#J_SiteNavLogin &gt; div.site-nav-menu-hd &gt; div.site-nav-sign &gt; a.h'</span>))</span><br><span class="line">        )</span><br><span class="line">        login.click()</span><br><span class="line">        time.sleep(<span class="number">30</span>)</span><br><span class="line">        <span class="comment"># 输入框</span></span><br><span class="line">        input = wait.until(</span><br><span class="line">            EC.presence_of_element_located((By.CSS_SELECTOR, <span class="string">"#q"</span>))</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 搜索按钮</span></span><br><span class="line">        submit = wait.until(</span><br><span class="line">            EC.element_to_be_clickable((By.CSS_SELECTOR,<span class="string">"#J_TSearchForm &gt; div.search-button &gt; button"</span>))</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 输入</span></span><br><span class="line">        input.send_keys(<span class="string">"美食"</span>)</span><br><span class="line">        <span class="comment"># 点击搜索</span></span><br><span class="line">        submit.click()</span><br><span class="line">        getProducts()</span><br><span class="line">    <span class="keyword">except</span> TimeoutError:</span><br><span class="line">        <span class="keyword">return</span>  search()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    search()</span><br><span class="line">    browser.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python3 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫系列(二)---抓取图片</title>
      <link href="/2018/11/21/pa-chong-xi-lie-er-zhua-qu-tu-pian/"/>
      <url>/2018/11/21/pa-chong-xi-lie-er-zhua-qu-tu-pian/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#导入所需要的模块</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mzitu</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">all_url</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        html = self.request(url)<span class="comment">##</span></span><br><span class="line">        all_a = BeautifulSoup(html.text, <span class="string">'lxml'</span>).find(<span class="string">'div'</span>, class_=<span class="string">'all'</span>).find_all(<span class="string">'a'</span>,href=re.compile(<span class="string">'[0~9]'</span>))</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> all_a:</span><br><span class="line">            title = a.get_text()</span><br><span class="line">            print(<span class="string">'------开始保存：'</span>, title) </span><br><span class="line">            path = str(title).replace(<span class="string">"?"</span>, <span class="string">'_'</span>) <span class="comment">##替换掉带有的？</span></span><br><span class="line">            self.mkdir(path) <span class="comment">##调用mkdir函数创建文件夹！这儿path代表的是标题title</span></span><br><span class="line">            href = a[<span class="string">'href'</span>]</span><br><span class="line">            self.html(href) </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">html</span><span class="params">(self, href)</span>:</span>   <span class="comment">##获得图片的页面地址</span></span><br><span class="line">        html = self.request(href)</span><br><span class="line">        max_span = BeautifulSoup(html.text, <span class="string">'lxml'</span>).find(<span class="string">'div'</span>, class_=<span class="string">'pagenavi'</span>).find_all(<span class="string">'span'</span>)[<span class="number">-2</span>].get_text()</span><br><span class="line">        <span class="comment">#这个上面有提到</span></span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">1</span>, int(max_span) + <span class="number">1</span>):</span><br><span class="line">            page_url = href + <span class="string">'/'</span> + str(page)</span><br><span class="line">            self.img(page_url) <span class="comment">##调用img函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">img</span><span class="params">(self, page_url)</span>:</span> <span class="comment">##处理图片页面地址获得图片的实际地址</span></span><br><span class="line">        img_html = self.request(page_url)</span><br><span class="line">        img_url = BeautifulSoup(img_html.text, <span class="string">'lxml'</span>).find(<span class="string">'div'</span>, class_=<span class="string">'main-image'</span>).find(<span class="string">'img'</span>)[<span class="string">'src'</span>]</span><br><span class="line">        self.save(img_url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, img_url)</span>:</span> <span class="comment">##保存图片</span></span><br><span class="line">        name = img_url[<span class="number">-9</span>:<span class="number">-4</span>]</span><br><span class="line">        img = self.request(img_url)</span><br><span class="line">        f = open(name + <span class="string">'.jpg'</span>, <span class="string">'ab'</span>)</span><br><span class="line">        f.write(img.content)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mkdir</span><span class="params">(self, path)</span>:</span> <span class="comment">##创建文件夹</span></span><br><span class="line">        path = path.strip()</span><br><span class="line">        isExists = os.path.exists(os.path.join(<span class="string">"F:\\download\\photo"</span>, path))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isExists:</span><br><span class="line">            print(<span class="string">'建了一个名字叫做'</span>, path, <span class="string">'的文件夹！'</span>)</span><br><span class="line">            os.makedirs(os.path.join(<span class="string">r"F:\download\photo"</span>, path))</span><br><span class="line">            os.chdir(os.path.join(<span class="string">r"F:\download\photo"</span>, path)) <span class="comment">##切换到目录</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print( path, <span class="string">'文件夹已经存在了！'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self, url)</span>:</span> <span class="comment">##这个函数获取网页的response 然后返回</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.110 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'referer'</span>: <span class="string">"http://www.mzitu.com/100260/2"</span> <span class="comment">#伪造一个访问来源 "http://www.mzitu.com/100260/2"</span></span><br><span class="line">            &#125;</span><br><span class="line">        content = requests.get(url, headers=headers)</span><br><span class="line">        <span class="keyword">return</span> content</span><br><span class="line"><span class="comment">#设置启动函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    Mzitu = mzitu() <span class="comment">##实例化</span></span><br><span class="line">    Mzitu.all_url(<span class="string">'http://www.mzitu.com/all'</span>) <span class="comment">##给函数all_url传入参数  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python3 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫系列(一)---抓取电影评分top100</title>
      <link href="/2018/11/20/pa-chong-xi-lie-yi-zhua-qu-dian-ying-top100/"/>
      <url>/2018/11/20/pa-chong-xi-lie-yi-zhua-qu-dian-ying-top100/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> RequestException</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">抓取猫眼电影网，历史电影评分top100</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHtml</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    获取网页内容</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 我也不知道为什么要加请求头才可以</span></span><br><span class="line">        headers = &#123;<span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.110 Safari/537.36'</span>&#125;</span><br><span class="line">        response = requests.get(url,headers=headers)</span><br><span class="line">        <span class="comment">#print(response.status_code)</span></span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">except</span> RequestException <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseHtml</span><span class="params">(html)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    解析网页,抓取：电影排名，分数，上映时间，主演，封面url</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment">#找到所有 dd 标签</span></span><br><span class="line">    soup = BeautifulSoup(html,<span class="string">"lxml"</span>)</span><br><span class="line">    films = soup.find_all(<span class="string">"dd"</span>)</span><br><span class="line">    outList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> films:</span><br><span class="line">        <span class="comment"># 排名</span></span><br><span class="line">        num = i.find_all(<span class="string">"i"</span>,&#123;<span class="string">"class"</span>:re.compile(<span class="string">"board-index board-index.+\d+"</span>)&#125;)[<span class="number">0</span>].get_text().strip()</span><br><span class="line">        <span class="comment"># 影名</span></span><br><span class="line">        name = i.find_all(<span class="string">"p"</span>,&#123;<span class="string">"class"</span>:<span class="string">"name"</span>&#125;)[<span class="number">0</span>].get_text().strip()</span><br><span class="line">        <span class="comment"># 评分</span></span><br><span class="line">        score = i.find_all(<span class="string">"p"</span>,&#123;<span class="string">"class"</span>:<span class="string">"score"</span>&#125;)[<span class="number">0</span>].get_text().strip()</span><br><span class="line">        <span class="comment">#print(score)</span></span><br><span class="line">        <span class="comment"># 时间</span></span><br><span class="line">        releaseTime = i.find_all(<span class="string">"p"</span>,&#123;<span class="string">"class"</span>:<span class="string">"releasetime"</span>&#125;)[<span class="number">0</span>].get_text().strip()</span><br><span class="line">        <span class="comment"># 主演</span></span><br><span class="line">        star = i.find_all(<span class="string">"p"</span>,&#123;<span class="string">"class"</span>:<span class="string">"star"</span>&#125;)[<span class="number">0</span>].get_text().strip()</span><br><span class="line">        outList.append([num,name,score,releaseTime,star])</span><br><span class="line">    <span class="keyword">return</span> outList</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(index)</span>:</span></span><br><span class="line">    url = <span class="string">f"http://ma oyan.com/board/4?offset=<span class="subst">&#123;index&#125;</span>"</span></span><br><span class="line">    </span><br><span class="line">    html = getHtml(url)</span><br><span class="line">    outList = parseHtml(html)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> outList:</span><br><span class="line">        print(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#pool = Pool()</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        main(i*<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&apos;1&apos;, &apos;霸王别姬&apos;, &apos;9.6&apos;, &apos;上映时间：1993-01-01&apos;, &apos;主演：张国荣,张丰毅,巩俐&apos;]</span><br><span class="line">[&apos;2&apos;, &apos;肖申克的救赎&apos;, &apos;9.5&apos;, &apos;上映时间：1994-10-14(美国)&apos;, &apos;主演：蒂姆·罗宾斯,摩根·弗里曼,鲍勃·冈顿&apos;]</span><br><span class="line">[&apos;3&apos;, &apos;罗马假日&apos;, &apos;9.1&apos;, &apos;上映时间：1953-09-02(美国)&apos;, &apos;主演：格利高里·派克,奥黛丽·赫本,埃迪·艾伯特&apos;]</span><br><span class="line">[&apos;4&apos;, &apos;这个杀手不太冷&apos;, &apos;9.5&apos;, &apos;上映时间：1994-09-14(法国)&apos;, &apos;主演：让·雷诺,加里·奥德曼,娜塔莉·波特曼&apos;]</span><br><span class="line">[&apos;5&apos;, &apos;教父&apos;, &apos;9.3&apos;, &apos;上映时间：1972-03-24(美国)&apos;, &apos;主演：马龙·白兰度,阿尔·帕西诺,詹姆斯·肯恩&apos;]</span><br><span class="line">[&apos;6&apos;, &apos;泰坦尼克号&apos;, &apos;9.5&apos;, &apos;上映时间：1998-04-03&apos;, &apos;主演：莱昂纳多·迪卡普里奥,凯特·温丝莱特,比利·赞恩&apos;]</span><br><span class="line">[&apos;7&apos;, &apos;唐伯虎点秋香&apos;, &apos;9.2&apos;, &apos;上映时间：1993-07-01(中国香港)&apos;, &apos;主演：周星驰,巩俐,郑佩佩&apos;]</span><br><span class="line">[&apos;8&apos;, &apos;千与千寻&apos;, &apos;9.3&apos;, &apos;上映时间：2001-07-20(日本)&apos;, &apos;主演：柊瑠美,入野自由,夏木真理&apos;]</span><br><span class="line">[&apos;9&apos;, &apos;魂断蓝桥&apos;, &apos;9.2&apos;, &apos;上映时间：1940-05-17(美国)&apos;, &apos;主演：费雯·丽,罗伯特·泰勒,露塞尔·沃特森&apos;]</span><br><span class="line">[&apos;10&apos;, &apos;乱世佳人&apos;, &apos;9.1&apos;, &apos;上映时间：1939-12-15(美国)&apos;, &apos;主演：费雯·丽,克拉克·盖博,奥利维娅·德哈维兰&apos;]</span><br><span class="line">(后面省略)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python3 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习实战笔记(五)---决策树(一)</title>
      <link href="/2018/11/19/ji-qi-xue-xi-shi-zhan-bi-ji-wu-jue-ce-shu-yi/"/>
      <url>/2018/11/19/ji-qi-xue-xi-shi-zhan-bi-ji-wu-jue-ce-shu-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h3><p>“信息熵”是度量样本纯合度最常用的的指标。假定当前样本集合D中的第$k$类样本所占的比例为$p_k(k=1,2…|y|)$,则D的信息熵可以定义为：</p><script type="math/tex; mode=display">Ent(D) = -\sum_{k=1}^{|y|}p_klog_2^{p_k}</script><p>Ent(D)越小，表明D的纯度越高，信息熵也称作经验熵</p><h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><p>在划分数据集之前之后信息发生的变化称为<strong>信息增益</strong><br>书中的说法都太正式，通俗的将就是我们将样本集D按照特征A划分后，子集中按照剩余的特征划分后的信息熵乘以各自的权重($\frac{|D^v|}{|D|}$)之和就是<strong>条件熵</strong>，与信息熵的差就是信息增益：</p><script type="math/tex; mode=display">Gain(D,a) = Ent(D) - \sum_{v=1}^{V} \frac{|D^v|}{|D|} Ent(D^v)</script><p>按照不同的特征划分可以得到不同的信息增益，一般来说信息增益越大，分类的纯度提升越大，<br>上式中$v$表示的是按照特征A划分后的第$v$类，共有$V$类，而</p><script type="math/tex; mode=display">\sum_{v=1}^{V} \frac{|D^v|}{|D|} Ent(D^v) = Ent(D|A)</script><h2 id="ID3算法构建决策树"><a href="#ID3算法构建决策树" class="headerlink" title="ID3算法构建决策树"></a>ID3算法构建决策树</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    dataSet = [[<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>]]</span><br><span class="line">    labels = [<span class="string">'no surfacing'</span>,<span class="string">'flippers'</span>]</span><br><span class="line">    <span class="comment">#change to discrete values</span></span><br><span class="line">    <span class="keyword">return</span> dataSet, labels</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTree</span><span class="params">(dataSet,labels)</span>:</span></span><br><span class="line">    classList = [example[<span class="number">-1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == len(classList): </span><br><span class="line">        <span class="keyword">return</span> classList[<span class="number">0</span>]<span class="comment"># 所有类别都相等</span></span><br><span class="line">    <span class="keyword">if</span> len(dataSet[<span class="number">0</span>]) == <span class="number">1</span>: <span class="comment"># 只有一个类别</span></span><br><span class="line">        <span class="keyword">return</span> majorityCnt(classList)</span><br><span class="line">    bestFeat = chooseBestFeatureToSplit(dataSet)</span><br><span class="line">    bestFeatLabel = labels[bestFeat]</span><br><span class="line">    myTree = &#123;bestFeatLabel:&#123;&#125;&#125;</span><br><span class="line">    <span class="keyword">del</span>(labels[bestFeat])</span><br><span class="line">    featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    uniqueVals = set(featValues)</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">        subLabels = labels[:]       <span class="comment">#copy all of labels, so trees don't mess up existing labels</span></span><br><span class="line">        myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value),subLabels)</span><br><span class="line">    <span class="keyword">return</span> myTree                  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityCnt</span><span class="params">(classList)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    选择类别最多的类型</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    classCount=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> vote <span class="keyword">in</span> classList:</span><br><span class="line">        <span class="keyword">if</span> vote <span class="keyword">not</span> <span class="keyword">in</span> classCount.keys(): classCount[vote] = <span class="number">0</span></span><br><span class="line">        classCount[vote] += <span class="number">1</span></span><br><span class="line">    sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitDataSet</span><span class="params">(dataSet, axis, value)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    选取指定列中的指定类别</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    retDataSet = []</span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="keyword">if</span> featVec[axis] == value:</span><br><span class="line">            reducedFeatVec = featVec[:axis]     <span class="comment">#chop out axis used for splitting</span></span><br><span class="line">            reducedFeatVec.extend(featVec[axis+<span class="number">1</span>:])</span><br><span class="line">            retDataSet.append(reducedFeatVec)</span><br><span class="line">    <span class="keyword">return</span> retDataSet</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseBestFeatureToSplit</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    计算条件熵：在选出信息熵最大分类的条件下</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    numFeatures = len(dataSet[<span class="number">0</span>]) - <span class="number">1</span>      <span class="comment">#the last column is used for the labels</span></span><br><span class="line">    baseEntropy = calcShannonEnt(dataSet)</span><br><span class="line">    bestInfoGain = <span class="number">0.0</span>; bestFeature = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numFeatures):        <span class="comment">#iterate over all the features</span></span><br><span class="line">        featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]<span class="comment">#create a list of all the examples of this feature</span></span><br><span class="line">        uniqueVals = set(featList)       <span class="comment">#get a set of unique values</span></span><br><span class="line">        newEntropy = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">            subDataSet = splitDataSet(dataSet, i, value)</span><br><span class="line">            prob = len(subDataSet)/float(len(dataSet))</span><br><span class="line">            newEntropy += prob * calcShannonEnt(subDataSet) <span class="comment"># 经验熵    </span></span><br><span class="line">        infoGain = baseEntropy - newEntropy     <span class="comment"># 计算信息增益</span></span><br><span class="line">        <span class="keyword">if</span> (infoGain &gt; bestInfoGain):       <span class="comment">#compare this to the best gain so far</span></span><br><span class="line">            bestInfoGain = infoGain         <span class="comment">#if better than current best, set to best</span></span><br><span class="line">            bestFeature = i</span><br><span class="line">    <span class="keyword">return</span> bestFeature                      <span class="comment">#returns an integer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcShannonEnt</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    计算信息熵</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    numEntries = len(dataSet) <span class="comment"># 样本数</span></span><br><span class="line">    labelCounts = &#123;&#125; <span class="comment">#　分类数</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet: <span class="comment">#the the number of unique elements and their occurance</span></span><br><span class="line">        currentLabel = featVec[<span class="number">-1</span>] <span class="comment"># 按照最后一列分类</span></span><br><span class="line">        <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys(): labelCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">        labelCounts[currentLabel] += <span class="number">1</span></span><br><span class="line">    shannonEnt = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:</span><br><span class="line">        prob = float(labelCounts[key])/numEntries <span class="comment"># 概率</span></span><br><span class="line">        shannonEnt -= prob * log(prob,<span class="number">2</span>) <span class="comment">#log base 2 # 计算熵。求和 </span></span><br><span class="line">    <span class="keyword">return</span> shannonEnt</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>    :</span><br><span class="line">    dataSet, labels = createDataSet()</span><br><span class="line">    <span class="comment">#print (dataSet)</span></span><br><span class="line">    <span class="comment"># 代码运行结果告诉我们，第0个特征是最好的用于划分数据集的特征</span></span><br><span class="line">    <span class="comment">#print (chooseBestFeatureToSplit(dataSet))</span></span><br><span class="line">    <span class="keyword">print</span> (createTree(dataSet,labels))</span><br><span class="line">    <span class="comment"># &#123;'no surfacing': &#123;0: 'no', 1: &#123;'flippers': &#123;0: 'no', 1: 'yes'&#125;&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="可视化-略"><a href="#可视化-略" class="headerlink" title="可视化(略)"></a>可视化(略)</h3>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python3 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim 进阶版</title>
      <link href="/2018/11/18/linux-xi-lie-vim-2/"/>
      <url>/2018/11/18/linux-xi-lie-vim-2/</url>
      
        <content type="html"><![CDATA[<p><strong>参考链接</strong>: <a href="https://linuxtoy.org/archives/efficient-editing-with-vim.html" target="_blank" rel="noopener">https://linuxtoy.org/archives/efficient-editing-with-vim.html</a></p><h2 id="高效率移动"><a href="#高效率移动" class="headerlink" title="高效率移动"></a>高效率移动</h2><h3 id="在当前行里面有效的移动光标"><a href="#在当前行里面有效的移动光标" class="headerlink" title="在当前行里面有效的移动光标"></a>在当前行里面有效的移动光标</h3><ul><li>fx：移动光标到当前行的下一个 x 处。很明显，x 可以是任意一个字母，而且你可以使用 ; 来重复你的上一个 f 命令。</li><li>tx：和上面的命令类似，但是是移动到 x 的左边一个位置。（这真的很有用）</li><li>Fx：和 fx 类似，不过是往回找。</li><li>w：光标往前移动一个词。</li><li>b：光标往后移动一个词。</li><li>0：移动光标到当前行首。</li><li>^：移动光标到当前行的第一个字母位置。</li><li>$：移动光标到行尾。</li><li>)：移动光标到下一个句子。</li><li>( ：移动光标到上一个句子。</li></ul><h3 id="在整个文件里面有效移动光标"><a href="#在整个文件里面有效移动光标" class="headerlink" title="在整个文件里面有效移动光标"></a>在整个文件里面有效移动光标</h3><ul><li>ctrl+F：向下移动一屏。</li><li>ctrl+B：向上移动一屏。</li><li>G：到文件尾</li><li>numG：移动光标到指定的行（num）。（比如 10G 就是到第 10 行）</li><li>gg：到文件首</li><li>H：移动光标到屏幕上面</li><li>M：移动光标到屏幕中间</li><li>L：移动光标到屏幕下面</li><li>*：读取光标处的字符串，并且移动光标到它再次出现的地方。</li><li><h1 id="：和上面的类似，但是是往反方向寻找。"><a href="#：和上面的类似，但是是往反方向寻找。" class="headerlink" title="：和上面的类似，但是是往反方向寻找。"></a>：和上面的类似，但是是往反方向寻找。</h1></li><li>/text：从当前光标处开始搜索字符串 text，并且到达 text 出现的地方。必须使用回车来开始这个搜索命令。如果想重复上次的搜索的话，按 n。</li><li>？text：和上面类似，但是是反方向。</li><li>ma：在当前光标的位置标记一个书签，名字为 a。书签名只能是小写字母。你看不见书签的存在，但它确实已经在那里了。</li><li>`a：到书签 a 处。注意这个不是单引号，它一般位于大部分键盘的 1 的左边。</li><li>`.：到你上次编辑文件的地方。这个命令很有用，而且你不用自己去标记它。</li></ul><h2 id="高效的输入"><a href="#高效的输入" class="headerlink" title="高效的输入"></a>高效的输入</h2><h3 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h3><p>使用关键词自动完成功能，你只需要输入开始几个字母（比如 iAmAL），然后按 <code>&lt;C-N&gt;</code>（按住 Ctrl，再按 N）或者 <code>&lt;C-P&gt;</code>。如果 Vim 没有给出你想要的词，继续按，直到你满意为止，Vim 会一直循环它找到的匹配的字符串</p><h3 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a>进入插入模式</h3><ul><li>i：在当前字符的左边插入</li><li>I：在当前行首插入</li><li>a：在当前字符的右边插入</li><li>A：在当前行尾插入</li><li>o：在当前行下面插入一个新行</li><li>O：在当前行上面插入一个新行</li><li>c{motion}：删除 motion 命令跨过的字符，并且进入插入模式。比如：c$，这将会删除从光标位置到行尾的字符并且进入插入模式。ct！，这会删除从光标位置到下一个叹号（但不包括），然后进入插入模式。被删除的字符被存在了剪贴板里面，并且可以再粘贴出来。</li><li>d{motion}：和上面差不多，但是不进入插入模式。</li></ul><h2 id="移动大段文本"><a href="#移动大段文本" class="headerlink" title="移动大段文本"></a>移动大段文本</h2><h3 id="可视选择"><a href="#可视选择" class="headerlink" title="可视选择"></a>可视选择</h3><ul><li>v：按字符选择。经常使用的模式，所以亲自尝试一下它。</li><li>V：按行选择。这在你想拷贝或者移动很多行的文本的时候特别有用。</li><li>ctrl+V：按块选择。非常强大，只在很少的编辑器中才有这样的功能。你可以选择一个矩形块，并且在这个矩形里面的文本会被高亮。</li></ul><p>在选择模式的时候使用上面所述的方向键和命令（motion）。比如，vwww，会高亮光标前面的三个词。Vjj 将会高亮当前行以及下面两行。</p><h3 id="在可视选择模式下剪切和拷贝"><a href="#在可视选择模式下剪切和拷贝" class="headerlink" title="在可视选择模式下剪切和拷贝"></a>在可视选择模式下剪切和拷贝</h3><p>一旦你高亮了选区，你或许想进行一些操作：</p><ul><li>d：剪贴选择的内容到剪贴板。</li><li>y：拷贝选择的内容到剪贴板。</li><li>c：剪贴选择的内容到剪贴板并且进入插入模式。</li></ul><h3 id="在非可视选择模式下剪切和拷贝"><a href="#在非可视选择模式下剪切和拷贝" class="headerlink" title="在非可视选择模式下剪切和拷贝"></a>在非可视选择模式下剪切和拷贝</h3><p>如果你很清楚的知道你想拷贝或者剪切什么，那你根本就不需要进入可视选择模式。这样也会节省时间：</p><ul><li>d{motion}：剪切 motion 命令跨过的字符到剪贴板。比如，dw 会剪切一个词而 dfS 会将从当前光标到下一个 S 之间的字符剪切至剪贴板。</li><li>y{motion}：和上面类似，不过是拷贝。</li><li>c{motion}：和 d{motion} 类似，不过最后进入插入模式。</li><li>dd：剪切当前行。</li><li>yy：拷贝当前行。</li><li>cc：剪切当前行并且进入插入模式。</li><li>D：剪切从光标位置到行尾到剪贴板。</li><li>Y：拷贝当前行。</li><li>C：和 D 类似，最后进入插入模式。</li><li>x：剪切当前字符到剪贴板。</li><li>s：和x类似，不过最后进入插入模式。</li></ul><h3 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h3><p>粘贴很简单，按 p。</p><h2 id="避免重复"><a href="#避免重复" class="headerlink" title="避免重复"></a>避免重复</h2><h3 id="令人惊奇的-命令"><a href="#令人惊奇的-命令" class="headerlink" title="令人惊奇的 . 命令"></a>令人惊奇的 . 命令</h3><p>在 Vi 里面，输入 <code>.</code> (小数点符号），将会重复你输入的上一个命令。比如，你上个命令为“dw”（删除一个词），Vi 将会接着再删除一个词。</p><h3 id="使用数字"><a href="#使用数字" class="headerlink" title="使用数字"></a>使用数字</h3><p>使用数字也是 Vim 强大的而且很节省时间的重要特性之一。在很多 Vim 的命令之前都可以使用一个数字，这个数字将会告诉 Vim 这个命令需要执行几次。比如：</p><ul><li>3j: 将会把光标向下移动三行。</li><li>10dd: 将会删除十行。</li><li>y3”: 将会拷贝从当前光标到第三个出现的引号之间的内容到剪贴板。<br>数字是扩展 motion 命令作用域非常有效的方法。</li></ul><h3 id="记录宏"><a href="#记录宏" class="headerlink" title="记录宏"></a>记录宏</h3><p>有时候，你会发现你自己在文章的每段或者每行都重复相同的一系列动作。Vim 允许你记录一个宏来完成你的特殊需要。</p><ul><li>qregister：记录宏到寄存器 register，这里 register 是任意的你的寄存器的名字。比如 qa，将会记录并且把宏存在寄存器 a 里面。</li><li>q：结束宏的记录。</li><li>@register：使用存在寄存器 register 的宏。比如 @a，将会使用存在寄存器 a 里面的宏。</li></ul><p>必须要记住的是，宏只记录了你的系列按键并且重复执行它们。它们不是魔法。因为在 Vim 里面完成目的的方法有很多，所以有时候你要小心选择命令来记录你的宏。因为它们会在所有你要执行它的地方执行。</p><h2 id="用-Vim-写代码"><a href="#用-Vim-写代码" class="headerlink" title="用 Vim 写代码"></a>用 Vim 写代码</h2><p>Vim 是一个用来写代码的绝好编辑器，因为它有一些特性是专门为程序员而设计的。这里是一些常用的：</p><ul><li>]p：和 p 的功能差不多，但是它会自动调整被粘贴的文本的缩进去适应当前代码的位置。试一下！</li><li>%：匹配花括号、方括号、括号等。在一个括号的上面，然后按 %，鼠标就会出现在匹配的另外一半括号处。</li><li><blockquote><blockquote><p>：缩进所有选择的代码</p></blockquote></blockquote></li><li>&lt;&lt;：和上面类似，但是反缩进</li><li>gd：到达光标所在处函数或者变量的定义处。</li><li>K：在 Man 里面查找光标当前所在处的词。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(转)应该知道的LINUX技巧</title>
      <link href="/2018/11/17/linux-xi-lie-zhuan-ni-ying-gai-zhi-dao-de-linux-ji-qiao/"/>
      <url>/2018/11/17/linux-xi-lie-zhuan-ni-ying-gai-zhi-dao-de-linux-ji-qiao/</url>
      
        <content type="html"><![CDATA[<p><em>文章来源：</em><a href="https://coolshell.cn/articles/8883.html?utm_source=qq&amp;utm_medium=social" target="_blank" rel="noopener">https://coolshell.cn/articles/8883.html?utm_source=qq&amp;utm_medium=social</a></p><p><strong>写在开头，此篇文章算是一些Linux系统和命令的总结，可以提升效率。里面的一些教程资源自己还没有读过，在这里记录一下，以后看了会整理出来的。</strong></p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li><p>[ ] 学习 <code>Bash</code> 。你可以<code>man bash</code>来看看<code>bash</code>的东西，并不复杂也并不长。你用别的<code>shell</code>也行，但是<code>bash</code>是很强大的并且也是系统默认的。（学习<code>zsh</code>或<code>tsch</code>只会让你在很多情况下受到限制）</p></li><li><p>[ ] 学习 <code>vim</code> 。在Linux下，基本没有什么可与之竞争的编译辑器（就算你是一个Emacs或Eclipse的重度用户）。你可以看看<a href="https://coolshell.cn/articles/5426.html" target="_blank" rel="noopener">《简明vim攻略》</a>和 <a href="https://coolshell.cn/articles/7166.html" target="_blank" rel="noopener">《Vim的冒险游戏》</a>以及<a href="https://coolshell.cn/articles/5479.html" target="_blank" rel="noopener">《给程序员的Vim速查卡》</a>还有<a href="https://coolshell.cn/articles/894.html" target="_blank" rel="noopener">《把Vim变成一个编程的IDE》</a>等等。</p></li><li><p>[ ] 了解 ssh。明白不需要口令的用户认证（通过<code>ssh-agent</code>, <code>ssh-add</code>），学会用ssh FQ，用scp而不是ftp传文件，等等。你知道吗？scp 远端的时候，你可以按tab键来查看远端的目录和文件（当然，需要无口令的用户认证），这都是bash的功劳。</p></li><li><p>[x] 熟悉bash的作业管理，如： &amp;, Ctrl-Z, Ctrl-C, jobs, fg, bg, kill, 等等。当然，你也要知道Ctrl+\（SIGQUIT）和Ctrl+C （SIGINT）的区别。</p></li><li><p>[x] 简单的文件管理 ： ls 和 ls -l (你最好知道 “ls -l” 的每一列的意思), less, head, tail 和 tail -f, ln 和 ln -s (你知道明白hard link和soft link的不同和优缺点), chown, chmod, du (如果你想看看磁盘的大小 du -sk *), df, mount。当然，原作者忘了find命令。</p></li><li><p>[x] 基础的网络管理： <code>ip</code> 或 <code>ifconfig</code>, <code>dig</code>。当然，原作者还忘了如<code>netstat</code>, <code>ping</code>, <code>traceroute</code>, 等</p></li><li><p>[ ] 理解正则表达式，还有grep/egrep的各种选项。比如： -o, -A, 和 -B 这些选项是很值得了解的。</p></li><li><p>[x] 学习使用 <code>apt-get</code> 和 <code>yum</code> 来查找和安装软件（前者的经典分发包是Ubuntu，后者的经典分发包是Redhat），我还建议你试着从源码编译安装软件。</p></li></ul><h2 id="日常"><a href="#日常" class="headerlink" title="日常"></a>日常</h2><ul><li><p>[x]在 <code>bash</code> 里，使用 <code>Ctrl+r</code> 而不是上下光标键来查找历史命令。</p></li><li><p>[x] 在 <code>bash</code>里，使用 <code>Ctrl+w</code> 来删除最后一个单词，使用 <code>Ctrl+U</code> 来删除一行。请<code>man bash</code>后查找<code>Readline Key Bindings</code>一节来看看<code>bash</code>的默认热键，比如：<code>Alt+.</code> 把上一次命令的最后一个参数打出来，而<code>Alt+*</code> 则列出你可以输入的命令。</p></li><li><p>[x] 回到上一次的工作目录： <code>cd –</code>  （回到home是 <code>cd ~</code>）</p></li><li><p>[ ] 使用 <code>xargs</code>。这是一个很强大的命令。你可以使用<code>-L</code>来限定有多少个命令，也可以用<code>-P</code>来指定并行的进程数。如果你不知道你的命令会变成什么样，你可以使用<code>xargs echo</code>来看看会是什么样。当然， -<code>I{}</code> 也很好用。示例：</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -name \*.py | xargs grep some_function</span><br><span class="line">cat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname</span><br></pre></td></tr></table></figure><ul><li><p>[ ] <code>pstree -p</code> 可以帮你显示进程树。参考<a href="https://coolshell.cn/articles/7965.html" target="_blank" rel="noopener">《一个fork的面试题》</a></p></li><li><p>[ ] 使用 <code>pgrep</code> 和 <code>pkill</code> 来找到或是<code>kill</code> 某个名字的进程。 (<code>-f</code> 选项很有用).</p></li><li><p>[ ] 了解可以发给进程的信号。例如：要挂起一个进程，使用<code>kill -STOP [pid]</code>. 使用 <code>man 7 signal</code> 来查看各种信号，使用<code>kill -l</code> 来查看数字和信号的对应表</p></li><li><p>[x] 使用 <code>nohup</code>或  <code>disown</code> 如果你要让某个进程运行在后台。</p></li><li><p>[ ] 使用<code>netstat -lntp</code>来看看有侦听在网络某端口的进程。当然，也可以使用 <code>lsof</code>。</p></li></ul><ul><li><p>[ ] 在bash的脚本中，你可以使用 <code>set -x</code> 来<code>debug</code>输出。使用 <code>set -e</code> 来当有错误发生的时候abort执行。考虑使用 <code>set -o pipefail</code> 来限制错误。还可以使用<code>trap</code>来截获信号（如截获<code>ctrl+c</code>）。</p></li><li><p>[xx] 在bash 脚本中，subshells (写在圆括号里的) 是一个很方便的方式来组合一些命令。一个常用的例子是临时地到另一个目录中，例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># do something in current dir</span></span><br><span class="line">(<span class="built_in">cd</span> /some/other/dir; other-command)</span><br><span class="line"><span class="comment"># continue in original dir</span></span><br></pre></td></tr></table></figure></li><li><p>[ ] 在 bash 中，注意那里有很多的变量展开。如：</p><ul><li>[ ] 检查一个变量是否存在: <code>${name:?error message}</code>。</li><li>[ ] 如果一个bash的脚本需要一个参数，也许就是这样一个表达式 <code>input_file=${1:?usage: $0 input_file}</code>。</li><li>[ ] 一个计算表达式： <code>i=$(( (i + 1) % 5 ))</code>。</li><li>[ ] 一个序列： <code>{1..10}</code>。 </li><li>[ ] 截断一个字符串： <code>${var%suffix}</code> 和 <code>${var#prefix}</code>。 示例： <code>if var=foo.pdf, then echo ${var%.pdf}.txt prints “foo.txt”</code>.</li></ul></li></ul><ul><li><p>[ ] 通过 <code>&lt;(some command)</code> 可以把某命令当成一个文件。示例：比较一个本地文件和远程文件 <code>/etc/hosts： diff /etc/hosts &lt;(ssh somehost cat /etc/hosts)</code></p></li><li><p>[ ] 了解什么叫 “here documents” ，就是诸如 <code>cat &lt;&lt;EOF</code> 这样的东西。</p></li><li><p>[ ] 在 bash中，使用重定向到标准输出和标准错误。如： <code>some-command &gt;logfile 2&gt;&amp;1</code>。另外，要确认某命令没有把某个打开了的文件句柄重定向给标准输入，最佳实践是加上 “<code>&lt;/dev/null</code>”，把<code>/dev/null</code>重定向到标准输入。</p></li><li><p>[x] 使用 man ascii 来查看 ASCII 表。</p></li><li><p>[ ] 在远端的 ssh 会话里，使用 <code>screen</code> 或 <code>dtach</code> 来保存你的会话。（参看<a href="https://coolshell.cn/articles/7829.html" target="_blank" rel="noopener">《28个Unix/Linux的命令行神器》</a>）</p></li><li><p>[ ] 要来debug Web，试试<code>curl</code> 和 <code>curl -I</code> 或是 <code>wget</code> 。我觉得debug Web的利器是<code>firebug</code>，<code>curl</code>和<code>wget</code>是用来抓网页的</p></li><li><p>[ ] 把 HTML 转成文本： <code>lynx -dump -stdin</code></p></li><li><p>[ ] 如果你要处理XML，使用 <code>xmlstarlet</code></p></li><li><p>[ ] 对于 Amazon S3， <code>s3cmd</code> 是一个很方便的命令（还有点不成熟）</p></li><li><p>[ ] 在 ssh中，知道怎么来使用ssh隧道。通过 <code>-L</code> or <code>-D</code> (还有<code>-R</code>) ，FQ神器。</p></li><li><p>[ ] 你还可以对你的ssh 做点优化。比如，<code>.ssh/config</code> 包含着一些配置：避免链接被丢弃，链接新的host时不需要确认，转发认证，以前使用压缩（如果你要使用scp传文件）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TCPKeepAlive=yes</span><br><span class="line">ServerAliveInterval=15</span><br><span class="line">ServerAliveCountMax=6</span><br><span class="line">StrictHostKeyChecking=no</span><br><span class="line">Compression=yes</span><br><span class="line">ForwardAgent=yes</span><br></pre></td></tr></table></figure></li><li><p>[ ] 如果你有输了个命令行，但是你改变注意了，但你又不想删除它，因为你要在历史命令中找到它，但你也不想执行它。那么，你可以按下 <code>Alt_#</code> ，于是这个命令关就被加了一个#字符，于是就被注释掉了。</p></li></ul><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><ul><li><p>[x] 了解 <code>sort</code> 和 <code>uniq</code> 命令 (包括 <code>uniq</code> 的 <code>-u</code> 和 <code>-d</code> 选项).</p></li><li><p>[x] 了解用 <code>cut</code>, <code>paste</code>, 和 <code>join</code> 命令来操作文本文件。很多人忘了在<code>cut</code>前使用<code>join</code>。</p></li><li><p>[ ]  如果你知道怎么用<code>sort</code>/<code>uniq</code>来做集合交集、并集、差集能很大地促进你的工作效率。假设有两个文本文件a和b已解被 uniq了，那么，用<code>sort</code>/<code>uniq</code>会是最快的方式，无论这两个文件有多大（<code>sort</code>不会被内存所限，你甚至可以使用<code>-T</code>选项，如果你的/tmp目录很小）</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat a b | sort | uniq &gt; c   <span class="comment"># c is a union b 并集</span></span><br><span class="line">cat a b | sort | uniq -d &gt; c   <span class="comment"># c is a intersect b 交集</span></span><br><span class="line">cat a b b | sort | uniq -u &gt; c   <span class="comment"># c is set difference a - b 差集</span></span><br></pre></td></tr></table></figure><ul><li><p>[ ] 了解和字符集相关的命令行工具，包括排序和性能。很多的Linux安装程序都会设置<code>LANG</code> 或是其它和字符集相关的环境变量。这些东西可能会让一些命令（如：<code>sort</code>）的执行性能慢N多倍（注：就算是你用UTF-8编码文本文件，你也可以很安全地使用ASCII来对其排序）。如果你想Disable那个i18n 并使用传统的基于byte的排序方法，那就设置<code>export LC_ALL=C</code> （实际上，你可以把其放在 <code>.bashrc</code>）。如果这设置这个变量，你的<code>sort</code>命令很有可能会是错的。</p></li><li><p>[x] 了解 <code>awk</code> 和 <code>sed</code>，并用他们来做一些简单的数据修改操作。例如：求第三列的数字之和： <code>awk &#39;{ x += $3 } END { print x }&#39;</code>。这可能会比Python快3倍，并比Python的代码少三倍。</p></li><li><p>[ ] 使用 <code>shuf</code> 来打乱一个文件中的行或是选择文件中一个随机的行。</p></li><li><p>[x] 了解<code>sor</code>t命令的选项。了解key是什么（<code>-t</code>和<code>-k</code>）。具体说来，你可以使用<code>-k1,1</code>来对第一列排序，<code>-k1</code>来对全行排序。</p></li><li><p>[ ] Stable <code>sort</code> (<code>sort -s</code>) 会很有用。例如：如果你要想对两例排序，先是以第二列，然后再以第一列，那么你可以这样： <code>sort -k1,1 | sort -s -k2,2</code></p></li><li><p>[ ] 我们知道，在bash命令行下，Tab键是用来做目录文件自动完成的事的。但是如果你想输入一个Tab字符（比如：你想在<code>sort -t</code>选项后输入<code>&lt;tab&gt;</code>字符），你可以先按<code>Ctrl+V</code>，然后再按Tab键，就可以输入<code>&lt;tab&gt;</code>字符了。当然，你也可以使用<code>\t</code>。</p></li><li><p>[ ] 如果你想查看二进制文件，你可以使用<code>hd</code>命令（在CentOS下是<code>hexdump</code>命令），如果你想编译二进制文件，你可以使用bvi命令（<a href="http://bvi.sourceforge.net/" target="_blank" rel="noopener">http://bvi.sourceforge.net/</a> 墙）</p></li><li><p>[ ] 另外，对于二进制文件，你可以使用<code>strings</code>（配合<code>grep</code>等）来查看二进制中的文本。</p></li><li><p>[ ] 对于文本文件转码，你可以试一下 <code>iconv</code>。或是试试更强的 <code>uconv</code> 命令（这个命令支持更高级的Unicode编码）</p></li><li><p>[ ] 如果你要分隔一个大文件，你可以使用<code>split</code>命令（split by size）和<code>csplit</code>命令（split by a pattern）。</p></li></ul><h2 id="系统调试"><a href="#系统调试" class="headerlink" title="系统调试"></a>系统调试</h2><p><em>这部分内容因为用不到，所以看不懂</em></p><ul><li><p>[ ] 如果你想知道磁盘、CPU、或网络状态，你可以使用 <code>iostat</code>, <code>netstat</code>, <code>top</code> (或更好的 <code>htop</code>), 还有 <code>dstat</code> 命令。你可以很快地知道你的系统发生了什么事。关于这方面的命令，还有<code>iftop</code>, <code>iotop</code>等（参看<a href="https://coolshell.cn/articles/7829.html" target="_blank" rel="noopener">《28个Unix/Linux的命令行神器》</a>）</p></li><li><p>[ ] 要了解内存的状态，你可以使用<code>free</code>和<code>vmstat</code>命令。具体来说，你需要注意 “<code>cached</code>” 的值，这个值是Linux内核占用的内存。还有<code>free</code>的值。</p></li><li><p>[ ] Java 系统监控有一个小的技巧是，你可以使用<code>kill -3 &lt;pid&gt;</code> 发一个SIGQUIT的信号给JVM，可以把堆栈信息（包括垃圾回收的信息）dump到stderr/logs。</p></li><li><p>[ ] 使用 <code>mtr</code> 会比使用 <code>traceroute</code> 要更容易定位一个网络问题。<br>如果你要找到哪个socket或进程在使用网络带宽，你可以使用 <code>iftop</code> 或 <code>nethogs</code>。</p></li><li><p>[ ] Apache的一个叫 <code>ab</code> 的工具是一个很有用的，用<code>quick-and-dirty</code>的方式来测试网站服务器的性能负载的工作。如果你需要更为复杂的测试，你可以试试 <code>siege</code>。</p></li><li><p>[ ] 如果你要抓网络包的话，试试 <code>wireshark</code> 或 <code>tshark</code>。</p></li><li><p>[ ] 了解 <code>strace</code> 和 <code>ltrace</code>。这两个命令可以让你查看进程的系统调用，这有助于你分析进程的<code>hang</code>在哪了，怎么<code>crash</code>和<code>failed</code>的。你还可以用其来做性能<code>profile</code>，使用 <code>-c</code> 选项，你可以使用<code>-p</code>选项来<code>attach</code>上任意一个进程。</p></li><li><p>[ ] 了解用<code>ldd</code>命令来检查相关的动态链接库。注意：<a href="https://coolshell.cn/articles/1626.html" target="_blank" rel="noopener"><code>ldd</code>的安全问题</a></p></li><li><p>[ ] 使用<code>gd</code>b来调试一个正在运行的进程或分析core dump文件。参看<a href="https://coolshell.cn/articles/3643.html" target="_blank" rel="noopener">《GDB中应该知道的几个调试方法》</a></p></li><li><p>[ ] 学会到 <code>/proc</code> 目录中查看信息。这是一个Linux内核运行时记录的整个操作系统的运行统计和信息，比如： <code>/proc/cpuinfo</code>, <code>/proc/xxx/cwd,</code> <code>/proc/xxx/exe</code>, <code>/proc/xxx/fd/</code>, <code>/proc/xxx/smaps</code>.</p></li><li><p>[ ] 如果你调试某个东西为什么出错时，<code>sar</code>命令会有用。它可以让你看看 CPU, 内存, 网络, 等的统计信息。</p></li><li><p>[ ] 使用 <code>dmesg</code> 来查看一些硬件或驱动程序的信息或问题。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令：find</title>
      <link href="/2018/11/16/linux-xi-lie-find/"/>
      <url>/2018/11/16/linux-xi-lie-find/</url>
      
        <content type="html"><![CDATA[<p>语法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find *[directory-list]* *[option]* *[expression]*</span><br></pre></td></tr></table></figure></p><p>常用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find dir -name file1</span><br></pre></td></tr></table></figure></p><p><strong>选项：</strong></p><ul><li><p><code>-i</code> 忽略大小写</p></li><li><p><code>-depth</code>：从指定目录下最深层的子目录开始查找； </p></li><li><p><code>-expty</code>：寻找文件大小为0 Byte的文件，或目录下没有任何子目录或文件的空目录</p></li><li><p><code>-name</code>：指定字符串作为寻找文件或目录的范本样式；</p></li><li><p><code>-anewer</code>：查找其存取时间较指定文件或目录的存取时间 更接近现在的文件或目录；</p></li><li><p><code>-newer</code>：查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；</p></li><li><p><code>-maxdepth</code>：设置最大目录层级； </p></li><li><p><code>-mindepth</code>：设置最小目录层级；</p></li><li><p><code>-regex</code>：正则表达式</p></li><li><p><code>-type</code>：只寻找符合指定的文件类型的文件:</p><ul><li><code>b</code> 特殊的块文件</li><li><code>c</code> 特殊的字符文件</li><li><code>d</code> 目录文件</li><li><code>f</code> 普通文件</li><li><code>I</code> 符号链接</li><li><code>p</code> FIFO(命名管道)</li><li><code>s</code> 套接字</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(转)fastp： 一款超快速全功能的FASTQ文件自动化质控+过滤+校正+预处理软件</title>
      <link href="/2018/11/15/fastp/"/>
      <url>/2018/11/15/fastp/</url>
      
        <content type="html"><![CDATA[<p>软件作者简介：陈实富，海普洛斯 联合创始人 / CTO</p><p>文章转载自：<a href="https://zhuanlan.zhihu.com/p/33601691" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33601691</a></p><h2 id="1引言"><a href="#1引言" class="headerlink" title="1引言"></a>1引言</h2><p>各位做生信的小伙伴都知道，对于下机的FASTQ数据需要进行质控和预处理，以保证下游分析输入的数据都是干净可靠的。通常我们都是使用FASTQC等软件进行质控，使用cutadapt软件去除接头，使用Trimmomatic等软件进行剪裁，然后使用一些自已开发的脚本进行过滤。这一过程可能需要使用多个软件，相当繁琐，而且速度较慢，这些软件大多又不支持多线程，遇到较大的FASTQ文件，处理起来可真是让人等得心急如焚。</p><p>所以今天给大家介绍一款新的软件，名字叫fastp，它可以仅仅扫描FASTQ文件一次，就完成比FASTQC+ cutadapt + Trimmomatic 这三个软件加起来的功能还多很多的功能，而且速度上比仅仅使用Trimmomatic一个软件还要快3倍左右，因为它使用C++开发，处处使用了高效算法，而且完美支持多线程！<br>github地址请戳：<a href="https://github.com/OpenGene/fastp" target="_blank" rel="noopener">https://github.com/OpenGene/fastp</a></p><h2 id="2功能特点"><a href="#2功能特点" class="headerlink" title="2功能特点"></a>2功能特点</h2><p>该软件的功能列表：</p><ul><li>对数据自动进行全方位质控，生成人性化的报告。</li><li>过滤功能（低质量，太短，太多N……）。</li><li>对每一个序列的头部或尾部，计算滑动窗内的质量均值，并将均值较低的子序列进行切除（类似Trimmomatic的做法，但是快非常多）。</li><li>全局剪裁 （在头/尾部，不影响去重），对于Illumina下机数据往往最后一到两个cycle需要这样处理。</li><li>去除接头污染。厉害的是，你不用输入接头序列，因为算法会自动识别接头序列并进行剪裁。</li><li>对于双端测序（PE）的数据，软件会自动查找每一对read的重叠区域，并对该重叠区域中不匹配的碱基对进行校正。</li><li>去除尾部的polyG。对于Illumina NextSeq/NovaSeq的测序数据，因为是两色法发光，polyG是常有的事，所以该特性对该两类测序平台默认打开。</li><li>对于PE数据中的overlap区间中不一致的碱基对，依据质量值进行校正</li><li>可以对带分子标签（UMI）的数据进行预处理，不管UMI在插入片段还是在index上，都可以轻松处理。</li><li>可以将输出进行分拆，而且支持两种模式，分别是指定分拆的个数，或者分拆后每个文件的行数。</li></ul><h2 id="3轻松上手"><a href="#3轻松上手" class="headerlink" title="3轻松上手"></a>3轻松上手</h2><p>SE:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastp -i in.fq -o out.fq</span><br></pre></td></tr></table></figure><p>PE:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastp -i in.R1.fq -o out.R1.fq -I in.R2.fq -O out.R2.fq</span><br><span class="line">fastp-i in.R1.fq.gz -I in.R2.fq.gz -o out.R1.fq.gz -O out.R2.fq.gz</span><br></pre></td></tr></table></figure><h2 id="4安装fastp"><a href="#4安装fastp" class="headerlink" title="4安装fastp"></a>4安装fastp</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/OpenGene/fastp.git</span><br><span class="line">cd fastp</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h2 id="5功能介绍"><a href="#5功能介绍" class="headerlink" title="5功能介绍"></a>5功能介绍</h2><h3 id="5-1过滤"><a href="#5-1过滤" class="headerlink" title="5.1过滤"></a>5.1过滤</h3><p>fastp可以对低质量序列，较多N的序列，该功能默认是启用的，但可以使用<code>-Q</code>参数关闭。使用<code>-q</code>参数来指定合格的phred质量值，比如<code>-q 15</code>表示质量值大于等于Q15的即为合格，然后使用<code>-u</code>参数来指定最多可以有多少百分比的质量不合格碱基。比如<code>-q 15 -u 40</code>表示一个read最多只能有40%的碱基的质量值低于Q15，否则会被扔掉。使用<code>-n</code>可以限定一个read中最多能有多少个N。</p><p>fastp还默认启用了read长度过滤，但可以使用<code>-L</code>参数关闭。使用<code>-l</code>参数指定最低要求一个read有多长，比如<code>-l 30</code>表示低于30个碱基的read会被扔掉。这个功能可以用于实现常用的discard模式，以保证所有输出的序列都一样长。<br>在fastp的HTML报告中，最头上的Summary表格很清楚地显示了过滤的统计信息，如下图所示：<br><img src="https://pic2.zhimg.com/80/v2-6920178b4b210ff1e37089ff8e1b289d_hd.jpg" alt="5.1"></p><h3 id="5-2接头处理"><a href="#5-2接头处理" class="headerlink" title="5.2接头处理"></a>5.2接头处理</h3><p>接头（adapter）污染的处理是FASTQ文件预处理中很重要的一步。fastp默认启用了接头处理，但是可以使用<code>-A</code>命令来关掉。fastp可以自动化地查找接头序列并进行剪裁，也就是说你可以不输入任何的接头序列，fastp全自动搞定了！对于SE数据，你还是可以<code>-a</code>参数来输入你的接头，而对于PE数据则完全没有必要，fastp基于PE数据的overlap分析可以更准确地查找接头，去得更干净，而且对于一些接头本身就有碱基不匹配情况处理得更好。fastp对于接头去除会有一个汇总的报告，如下图所示：<br><img src="https://pic1.zhimg.com/80/v2-202f214ad93c99a305f6b3510ddf3f78_hd.jpg" alt="5.2"></p><h3 id="5-3滑窗质量剪裁"><a href="#5-3滑窗质量剪裁" class="headerlink" title="5.3滑窗质量剪裁"></a>5.3滑窗质量剪裁</h3><p>很多时候，一个read的低质量序列都是集中在read的末端，也有少部分是在read的开头。fastp支持像Trimmomatic那样对滑动窗口中的碱基计算平均质量值，然后将不符合的滑窗直接剪裁掉。使用<code>-5</code>参数开启在5’端，也就是read的开头的剪裁，使用<code>-3</code>参数开启在3’端，也就是read的末尾的剪裁。使用<code>-W</code>参数指定滑动窗大小，默认是4，使用<code>-M</code>参数指定要求的平均质量值，默认是20，也就是Q20。</p><h3 id="5-4-PE数据的碱基校正"><a href="#5-4-PE数据的碱基校正" class="headerlink" title="5.4 PE数据的碱基校正"></a>5.4 PE数据的碱基校正</h3><p>fastp支持对PE数据的每一对read进行分析，查找它们的overlap区间，然后对于overlap区间中不一致的碱基，如果发现其中一个质量非常高，而另一个非常低，则可以将非常低质量的碱基改为相应的非常高质量值的碱基值，如下图所示：<br><img src="https://pic4.zhimg.com/80/v2-78e31fe48bbdc53f5c1a1427b6170a53_hd.jpg" alt="5.4"></p><p>上图中所示的标红的T碱基是低质量序列，和高质量的A不匹配，它会被校正为A。该校正功能默认没有开启使用<code>-c</code>参数可以启用，对于一些对噪声容忍度低的应用，比如液体活检，建议开启。</p><h3 id="5-5全局剪裁"><a href="#5-5全局剪裁" class="headerlink" title="5.5全局剪裁"></a>5.5全局剪裁</h3><p>fastp可以对所有read在头部和尾部进行统一剪裁，该功能在去除一些测序质量不好的cycle比较有用，比如151*2的PE测序中，最后一个cycle通常质量是非常低的，需要剪裁掉。使用<code>-f</code>和<code>-t</code>分别指定read1的头部和尾部的剪裁，使用<code>-F</code>和<code>-T</code>分别指定read2的头部和尾部的剪裁。</p><h3 id="5-6-polyG剪裁"><a href="#5-6-polyG剪裁" class="headerlink" title="5.6 polyG剪裁"></a>5.6 polyG剪裁</h3><p>对于两色发光法的Illumina设备（NextSeq /NovaSeq），因为在没有光信号情况下base calling的结果会返回G，所以在序列的尾端可能会出现较多的polyG，需要被去除。fastp会自动化地识别NextSeq / NovaSeq的数据，然后进行polyG识别和剪裁。如果你想强制开启该功能，可以指定<code>-g</code>参数，如果想强制关闭该功能，则可以指定<code>-G</code>参数。</p><h3 id="5-7分子标签UMI处理"><a href="#5-7分子标签UMI处理" class="headerlink" title="5.7分子标签UMI处理"></a>5.7分子标签UMI处理</h3><p>UMI在处理ctDNA类似的超低频突变检测应用中是十分有用的，为了更好地对带UMI的FASTQ文件进行预处理，fastp也很好地支持了UMI预处理功能。该功能默认没有启用，需要使用<code>-U</code>参数开启，另外需要使用<code>--umi_loc</code>来指定UMI所在的位置，它可以是（index1、 index2、 read1、 read2、 per_index、 per_read ）中的一种，分别表示UMI是在index位置上，还是在插入片段中。如果指定了是在插入序列中，还需要使用 <code>--umi_len</code> 参数来指定UMI所占的碱基长度。</p><h3 id="5-8输出文件切分"><a href="#5-8输出文件切分" class="headerlink" title="5.8输出文件切分"></a>5.8输出文件切分</h3><p>很多时候我们需要对输出的FASTQ进行切分，分成大小均匀的多个文件，这样可以使用比对软件并行地比对，提高并行处理的速度。fastp软件也提供了相应的功能，并且支持了两种模式，分别是使用参数<code>-s</code>指定切分后文件的个数，或者使用<code>-S</code>参数指定每个切分后文件的行数。</p><h2 id="6质控报告解读"><a href="#6质控报告解读" class="headerlink" title="6质控报告解读"></a>6质控报告解读</h2><p>接下来，我们再看一下如何理解fastp生成的质控报告。fastp的报告在单一文件中同时包含了过滤前和过滤后的统计结果，如果是PE数据，则同时包含了read1和read2的统计结果。之前我们已经说过了，fastp会生成HTML的报告和JSON格式的报告。HTML报告的默认文件名是fastp.html，但是可以通过-h参数修改，JSON报告的默认文件名是fastp.json，但是可以通过-j参数修改。而且fastp报告还有一个标题，默认是fastp report，这个也可以通过-R参数修改为你想要的标题。JSON格式的报告是优化过的，人机皆可读，适合进阶的用户使用程序解析，而这里我们重点关注HTML格式的报告。</p><h3 id="6-1质量分布曲线图"><a href="#6-1质量分布曲线图" class="headerlink" title="6.1质量分布曲线图"></a>6.1质量分布曲线图</h3><p>我们第一关注的当然是质量，所以fastp提供了质量分布曲线，即每一个cycle的平均质量值，而且fastp同时提供了A/T/C/G四种不同碱基的平均质量，以及总的平均质量，如下图所示：<br><img src="https://pic3.zhimg.com/80/v2-ee5358c3a2a93af49171459278aa751e_hd.jpg" alt="6.1"><br><img src="https://pic3.zhimg.com/80/v2-ee5358c3a2a93af49171459278aa751e_hd.jpg" alt="6.1_1"></p><p>从上图我们可以看到，一共有5条曲线，分别是A/T/C/G和mean。而且HTML报告中的每一个项目和分项目都是可以点击进行隐藏和展开的。</p><h3 id="6-2碱基含量分布曲线"><a href="#6-2碱基含量分布曲线" class="headerlink" title="6.2碱基含量分布曲线"></a>6.2碱基含量分布曲线</h3><p>和质量分布曲线类似，碱基含量分布曲线也是按照每一个cycle来的，显示了每一个位置的碱基含量。如下图所示：<br><img src="https://pic2.zhimg.com/80/v2-c2ca5f1b36bf7c9010d43773dffaf66d_hd.jpg" alt="6.2"><br><img src="https://pic2.zhimg.com/80/v2-4d30aaf1dfe395d89d36d9ae5c3e135d_hd.jpg" alt="6.2_1"></p><p>从图中可以看到，fastp同时显示了A/T/C/G/N/GC的每一个位置的比例和总的比例。而且如果你觉得头部那里比较乱看不清的话，可以用鼠标拉一个框，它就放大了</p><h3 id="6-3-KMER统计表格"><a href="#6-3-KMER统计表格" class="headerlink" title="6.3 KMER统计表格"></a>6.3 KMER统计表格</h3><p>fastp对5个碱基长度的所有组合的出现次数进行了统计，然后把它放在了一张表格中，表格的每一个元素为深背景白字，背景越深，则表示重复次数越多。这样，一眼望去，就可以发现有哪一些异常的信息。<br><img src="https://pic3.zhimg.com/80/v2-a69e014cd516d44ac2bb0d3cb8d6d67e_hd.jpg" alt="6.3"></p><p>从上面的KMER表格中，我们可以发现，GGGGG的颜色特别深，从鼠标移上去之后显示的信息中我们可以发现它的出现次数是平均次数的12.8倍，这是不正常的，因为GGGGG的正常倍数应该在1倍左右。幸好我们有fastp，它可以过滤掉这种polyG，让数值较多地回归正常。</p><h3 id="6-4过表达序列-overrepresented-sequence"><a href="#6-4过表达序列-overrepresented-sequence" class="headerlink" title="6.4过表达序列(overrepresented sequence)"></a>6.4过表达序列(overrepresented sequence)</h3><p>fastp的最新版本（v0.12）提供了overrepresetned<br>sequence的分析，而且不但提供了这些overrepresented sequence的序列个数和占比，还提供了他们在测序cycles中的分布情况，这有利于分析各种问题</p><h2 id="7-完整参数"><a href="#7-完整参数" class="headerlink" title="7 完整参数"></a>7 完整参数</h2><p>使用示例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastp -i R1.fastq.gz -I R2.clean.fastq.gz -o R1.clean.fastq.gz -O R2.clean.fastq.gz -f 5 -F 5 -3 -W 8 -M 25 -q 20 -u 25 -n 3 -l 50 -c -g --poly_g_min_len 6 -x -y -Y 20 -j out.json -h out.html --adapter_sequence GATCGGAAGAGCACACGTCTGAACTCCAGTCAC --adapter_sequence_r2 AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGT &gt; fastp.log</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$fastp</span><br><span class="line">fastp: an ultra-fast all-in-one FASTQ preprocessor</span><br><span class="line">version 0.19.3</span><br><span class="line">usage: fastp --in1=string [options] ...</span><br><span class="line">options:</span><br><span class="line">  -i, --in1                            read1 input file name (string)</span><br><span class="line">  -o, --out1                           read1 output file name (string [=])</span><br><span class="line">  -I, --in2                            read2 input file name (string [=])</span><br><span class="line">  -O, --out2                           read2 output file name (string [=])</span><br><span class="line">  -6, --phred64                        indicate the input is using phred64 scoring (it&apos;ll be converted to phred33, so the output will still be phred33)</span><br><span class="line">  -z, --compression                    compression level for gzip output (1 ~ 9). 1 is fastest, 9 is smallest, default is 4. (int [=4])</span><br><span class="line">      --stdout                         stream passing-filters reads to STDOUT. This option will result in interleaved FASTQ output for paired-end input. Disabled by defaut.</span><br><span class="line">      --interleaved_in                 indicate that &lt;in1&gt; is an interleaved FASTQ which contains both read1 and read2. Disabled by defaut.</span><br><span class="line">      --reads_to_process               specify how many reads/pairs to be processed. Default 0 means process all reads. (int [=0])</span><br><span class="line">      --dont_overwrite                 don&apos;t overwrite existing files. Overwritting is allowed by default.</span><br><span class="line">  -V, --verbose                        output verbose log information (i.e. when every 1M reads are processed).</span><br><span class="line">  -A, --disable_adapter_trimming       adapter trimming is enabled by default. If this option is specified, adapter trimming is disabled</span><br><span class="line">  -a, --adapter_sequence               the adapter for read1. For SE data, if not specified, the adapter will be auto-detected. For PE data, this is used if R1/R2 are found not overlapped. (string [=auto])</span><br><span class="line">      --adapter_sequence_r2            the adapter for read2 (PE data only). This is used if R1/R2 are found not overlapped. If not specified, it will be the same as &lt;adapter_sequence&gt; (string [=])</span><br><span class="line">  -f, --trim_front1                    trimming how many bases in front for read1, default is 0 (int [=0])</span><br><span class="line">  -t, --trim_tail1                     trimming how many bases in tail for read1, default is 0 (int [=0])</span><br><span class="line">  -F, --trim_front2                    trimming how many bases in front for read2. If it&apos;s not specified, it will follow read1&apos;s settings (int [=0])</span><br><span class="line">  -T, --trim_tail2                     trimming how many bases in tail for read2. If it&apos;s not specified, it will follow read1&apos;s settings (int [=0])</span><br><span class="line">  -g, --trim_poly_g                    force polyG tail trimming, by default trimming is automatically enabled for Illumina NextSeq/NovaSeq data</span><br><span class="line">      --poly_g_min_len                 the minimum length to detect polyG in the read tail. 10 by default. (int [=10])</span><br><span class="line">  -G, --disable_trim_poly_g            disable polyG tail trimming, by default trimming is automatically enabled for Illumina NextSeq/NovaSeq data</span><br><span class="line">  -x, --trim_poly_x                    enable polyX trimming in 3&apos; ends.</span><br><span class="line">      --poly_x_min_len                 the minimum length to detect polyX in the read tail. 10 by default. (int [=10])</span><br><span class="line">  -5, --cut_by_quality5                enable per read cutting by quality in front (5&apos;), default is disabled (WARNING: this will interfere deduplication for both PE/SE data)</span><br><span class="line">  -3, --cut_by_quality3                enable per read cutting by quality in tail (3&apos;), default is disabled (WARNING: this will interfere deduplication for SE data)</span><br><span class="line">  -W, --cut_window_size                the size of the sliding window for sliding window trimming, default is 4 (int [=4])</span><br><span class="line">  -M, --cut_mean_quality               the bases in the sliding window with mean quality below cutting_quality will be cut, default is Q20 (int [=20])</span><br><span class="line">  -Q, --disable_quality_filtering      quality filtering is enabled by default. If this option is specified, quality filtering is disabled</span><br><span class="line">  -q, --qualified_quality_phred        the quality value that a base is qualified. Default 15 means phred quality &gt;=Q15 is qualified. (int [=15])</span><br><span class="line">  -u, --unqualified_percent_limit      how many percents of bases are allowed to be unqualified (0~100). Default 40 means 40% (int [=40])</span><br><span class="line">  -n, --n_base_limit                   if one read&apos;s number of N base is &gt;n_base_limit, then this read/pair is discarded. Default is 5 (int [=5])</span><br><span class="line">  -L, --disable_length_filtering       length filtering is enabled by default. If this option is specified, length filtering is disabled</span><br><span class="line">  -l, --length_required                reads shorter than length_required will be discarded, default is 15. (int [=15])</span><br><span class="line">      --length_limit                   reads longer than length_limit will be discarded, default 0 means no limitation. (int [=0])</span><br><span class="line">  -y, --low_complexity_filter          enable low complexity filter. The complexity is defined as the percentage of base that is different from its next base (base[i] != base[i+1]).</span><br><span class="line">  -Y, --complexity_threshold           the threshold for low complexity filter (0~100). Default is 30, which means 30% complexity is required. (int [=30])</span><br><span class="line">      --filter_by_index1               specify a file contains a list of barcodes of index1 to be filtered out, one barcode per line (string [=])</span><br><span class="line">      --filter_by_index2               specify a file contains a list of barcodes of index2 to be filtered out, one barcode per line (string [=])</span><br><span class="line">      --filter_by_index_threshold      the allowed difference of index barcode for index filtering, default 0 means completely identical. (int [=0])</span><br><span class="line">  -c, --correction                     enable base correction in overlapped regions (only for PE data), default is disabled</span><br><span class="line">      --overlap_len_require            the minimum length of the overlapped region for overlap analysis based adapter trimming and correction. 30 by default. (int [=30])</span><br><span class="line">      --overlap_diff_limit             the maximum difference of the overlapped region for overlap analysis based adapter trimming and correction. 5 by default. (int [=5])</span><br><span class="line">  -U, --umi                            enable unique molecular identifer (UMI) preprocessing</span><br><span class="line">      --umi_loc                        specify the location of UMI, can be (index1/index2/read1/read2/per_index/per_read, default is none (string [=])</span><br><span class="line">      --umi_len                        if the UMI is in read1/read2, its length should be provided (int [=0])</span><br><span class="line">      --umi_prefix                     if specified, an underline will be used to connect prefix and UMI (i.e. prefix=UMI, UMI=AATTCG, final=UMI_AATTCG). No prefix by default (string [=])</span><br><span class="line">      --umi_skip                       if the UMI is in read1/read2, fastp can skip several bases following UMI, default is 0 (int [=0])</span><br><span class="line">  -p, --overrepresentation_analysis    enable overrepresented sequence analysis.</span><br><span class="line">  -P, --overrepresentation_sampling    one in (--overrepresentation_sampling) reads will be computed for overrepresentation analysis (1~10000), smaller is slower, default is 20. (int [=20])</span><br><span class="line">  -j, --json                           the json format report file name (string [=fastp.json])</span><br><span class="line">  -h, --html                           the html format report file name (string [=fastp.html])</span><br><span class="line">  -R, --report_title                   should be quoted with &apos; or &quot;, default is &quot;fastp report&quot; (string [=fastp report])</span><br><span class="line">  -w, --thread                         worker thread number, default is 2 (int [=2])</span><br><span class="line">  -s, --split                          split output by limiting total split file number with this option (2~999), a sequential number prefix will be added to output name ( 0001.out.fq, 0002.out.fq...), disabled by default (int [=0])</span><br><span class="line">  -S, --split_by_lines                 split output by limiting lines of each file with this option(&gt;=1000), a sequential number prefix will be added to output name ( 0001.out.fq, 0002.out.fq...), disabled by default (long [=0])</span><br><span class="line">  -d, --split_prefix_digits            the digits for the sequential number padding (1~10), default is 4, so the filename will be padded as 0001.xxx, 0 to disable padding (int[=4])</span><br><span class="line">  -?, --help                           print this message</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 生信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生信理论基础 </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 标准库系列(五)---subprocess</title>
      <link href="/2018/11/14/python3-biao-zhun-ku-xi-lie-wu-subprocess/"/>
      <url>/2018/11/14/python3-biao-zhun-ku-xi-lie-wu-subprocess/</url>
      
        <content type="html"><![CDATA[<p>subprocess模块是用来执行外部命令，下面介绍两种主要的用法。</p><h2 id="subprocess-run"><a href="#subprocess-run" class="headerlink" title="subprocess.run"></a><code>subprocess.run</code></h2><p> 这里<code>call</code>, <code>check_call</code>, <code>check_output</code>, 与其功能性相似，就不展开介绍了</p><p>常用参数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">subprocess.run (args，*,</span><br><span class="line">stdin = <span class="keyword">None</span>,</span><br><span class="line">input = <span class="keyword">None</span>,</span><br><span class="line">stdout = <span class="keyword">None</span>,</span><br><span class="line">stderr = <span class="keyword">None</span>,</span><br><span class="line">shell = <span class="keyword">False</span>,</span><br><span class="line">cwd = <span class="keyword">None</span>,</span><br><span class="line">timeout = <span class="keyword">None</span>,</span><br><span class="line">check = <span class="keyword">False</span>,</span><br><span class="line">encoding = <span class="keyword">None</span>,</span><br><span class="line">errors = <span class="keyword">None</span>,</span><br><span class="line">env = <span class="keyword">None</span> )</span><br></pre></td></tr></table></figure><p>默认不会捕获stdout或stderr</p><p>如果check为true，并且进程以非零退出代码退出， CalledProcessError则会引发异常。该异常的属性包含参数，退出代码以及stdout和stderr（如果它们被捕获）,</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里捕获了stdout,stderr</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = subprocess.run([<span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="string">"/dev/null"</span>],stdout=subprocess.PIPE,stderr=subprocess.PIPE)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.stdout</span><br><span class="line"><span class="string">b'crw-rw-rw-. 1 root root 1, 3 8\xe6\x9c\x88   3 13:24 /dev/null\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.stdout</span><br><span class="line"><span class="string">b'crw-rw-rw-. 1 root root 1, 3 8\xe6\x9c\x88   3 13:24 /dev/null\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.stdout.decode(<span class="string">"utf-8"</span>)</span><br></pre></td></tr></table></figure><p>如果我们使用了check参数的话，如果执行错误，就会引发异常，这里什么都捕获不到</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = subprocess.run([<span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="string">"/null"</span>], check=<span class="keyword">True</span>,stdout=subprocess.PIPE,stderr=subprocess.PIPE)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/share/chg2master/prod/Other/zhongjw/miniconda3/lib/python3.6/subprocess.py"</span>, line <span class="number">418</span>, <span class="keyword">in</span> run</span><br><span class="line">    output=stdout, stderr=stderr)</span><br><span class="line">subprocess.CalledProcessError: Command <span class="string">'['</span>ls<span class="string">', '</span>-l<span class="string">', '</span>/null<span class="string">']'</span> returned non-zero exit status <span class="number">2.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(b)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'b'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><p><em>python3.7里新增了<code>capture_output</code>参数,如果设置为true，则将捕获stdout和stderr。 使用时，将使用stdout = PIPE和stderr = PIPE自动创建内部Popen对象。 也可能不使用stdout和stderr参数。那么Popen对象的stdout、stderr与上面示例里的有什么不同呢？</em></p><h2 id="subprocess-Popen"><a href="#subprocess-Popen" class="headerlink" title="subprocess.Popen"></a><code>subprocess.Popen</code></h2><p>subprocess中更底层的进程创建和管理可以通过Popen类实现。它提供了更多的灵活性，程序员通过它能处理更多复杂的情况。</p><p>常用参数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">subprocess.Popen(args, </span><br><span class="line">bufsize=<span class="number">-1</span>, </span><br><span class="line">executable=<span class="keyword">None</span>, </span><br><span class="line">stdin=<span class="keyword">None</span>, </span><br><span class="line">stdout=<span class="keyword">None</span>, </span><br><span class="line">stderr=<span class="keyword">None</span>, </span><br><span class="line">preexec_fn=<span class="keyword">None</span>, </span><br><span class="line">close_fds=<span class="keyword">True</span>, </span><br><span class="line">shell=<span class="keyword">False</span>, </span><br><span class="line">cwd=<span class="keyword">None</span>, </span><br><span class="line">env=<span class="keyword">None</span>, </span><br><span class="line">universal_newlines=<span class="keyword">False</span>, </span><br><span class="line">startupinfo=<span class="keyword">None</span>, </span><br><span class="line">creationflags=<span class="number">0</span>, </span><br><span class="line">restore_signals=<span class="keyword">True</span>, </span><br><span class="line">start_new_session=<span class="keyword">False</span>, </span><br><span class="line">pass_fds=(), *, </span><br><span class="line">encoding=<span class="keyword">None</span>, </span><br><span class="line">errors=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = subprocess.Popen([<span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="string">"/null"</span>], stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.stderr.read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="string">'ls: 无法访问/null: 没有那个文件或目录\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.stderr.read().decode(<span class="string">"utf-8"</span>)</span><br></pre></td></tr></table></figure><p>从上面示例中可以看出Popen对象的stdout、stderr获取的是数据流，而run捕获的stdout、stderr是字符串格式</p><p>当然官方文档说是不建议使用<code>.stdin.write</code>,<code>.stdout.read</code> 或者 <code>.stderr.read</code>，而是用<code>.communicate</code>方法，该方法会造成阻塞，以防止其他进程读取数据流造成死锁</p><p><code>.communicate()</code>方法如果同时有<code>.stdout</code>和 <code>.stderr</code>, 返回的是一个元组, 用下标可以访问捕获的<code>stdout</code>和 <code>stderr</code>。</p><p>还要补充一点就是如果不捕获输出的话，是不会造成阻塞的，如果要等待子进程运行完可以使用<code>.wait</code>方法，而<code>subprocesee.run</code>方法会造成主程序的阻塞，因为要获取子进程运行状态。</p><p>Popen对象的主要方法有：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">'communicate'</span>, <span class="string">'kill'</span>, <span class="string">'pid'</span>, <span class="string">'poll'</span>, <span class="string">'returncode'</span>, <span class="string">'send_signal'</span>, <span class="string">'stderr'</span>, <span class="string">'stdin'</span>, <span class="string">'stdout'</span>, <span class="string">'terminate'</span>, <span class="string">'universal_newlines'</span>, <span class="string">'wait'</span>]</span><br></pre></td></tr></table></figure><p>如果有需要使用其他的参数和方法请查阅<a href="https://docs.python.org/3.6/library/subprocess.html#module-subprocess" target="_blank" rel="noopener">官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim 用法大全</title>
      <link href="/2018/11/13/linux-xi-lie-vim/"/>
      <url>/2018/11/13/linux-xi-lie-vim/</url>
      
        <content type="html"><![CDATA[<p>打开/退出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim -R file1 只读打开</span><br><span class="line">:qall 退出所有文件</span><br><span class="line">:wq 写入并退出</span><br><span class="line">:q! 强制退出</span><br></pre></td></tr></table></figure><p>插入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i 在当前位置生前插入</span><br><span class="line">I 在当前行首插入</span><br><span class="line">a 在当前位置后插入</span><br><span class="line">A 在当前行尾插入</span><br><span class="line">o 在当前行之后插入一行</span><br><span class="line">O 在当前行之前插入一行</span><br></pre></td></tr></table></figure><p>移动</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h 左移一个字符</span><br><span class="line">l 右移一个字符</span><br><span class="line">k 上移一个字符</span><br><span class="line">j 下移一个字符</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dd 删除当前行</span><br><span class="line">dj 删除当前行和上一行</span><br><span class="line">dk 删除当前行和下一行</span><br><span class="line">10dd 删除当前行开始的共10行</span><br><span class="line">D 删除当前字符至行尾</span><br></pre></td></tr></table></figure><p>跳转</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gg 跳转到文件头</span><br><span class="line">G 跳转到文件尾</span><br><span class="line">gg=G自动缩进 （非常有用）</span><br><span class="line">Ctrl + d 向下滚动半屏</span><br><span class="line">Ctrl + u 向上滚动半屏</span><br><span class="line">Ctrl + f 向下滚动一屏</span><br><span class="line">Ctrl + b 向上滚动一屏</span><br><span class="line">冒号+行号，跳转到指定行；比如:120，跳转到120行；</span><br><span class="line">$ 跳转到行尾</span><br><span class="line">0 跳转到行首</span><br></pre></td></tr></table></figure><p>编辑</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u 撤销</span><br><span class="line">Ctrl + r 重做</span><br><span class="line">yy 复制当前行</span><br><span class="line">按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制任意部分</span><br><span class="line">p 粘贴在当前位置</span><br><span class="line">另外，删除在vim里面就是剪切的意思，所以dd就是剪切当前行，可以用v或V选择特定部分再按d就是任意剪切了</span><br></pre></td></tr></table></figure><p>查找</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/text　　查找text，按n健查找下一个，按N健查找前一个</span><br><span class="line">?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个</span><br><span class="line">:set ignorecase　　忽略大小写的查找</span><br><span class="line">:set noignorecase　　不忽略大小写的查找</span><br></pre></td></tr></table></figure><p>替换</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:s/old/new/ 用old替换new，替换当前行的第一个匹配</span><br><span class="line">:s/old/new/g 用old替换new，替换当前行的所有匹配</span><br><span class="line">:%s/old/new/ 用old替换new，替换所有行的第一个匹配</span><br><span class="line">:%s/old/new/g 用old替换new，替换整个文件的所有匹配</span><br><span class="line">也可以用v或V选择指定行，然后执行</span><br></pre></td></tr></table></figure><p>多文件操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim file1 file2 file3 ... 同时编辑多个文件</span><br><span class="line">:split 将窗口分成上下两个子窗口，对应两个不同的文件</span><br><span class="line">:vsplit 将窗口分成左右两个子窗口，对应两个不同的文件</span><br><span class="line">:open file4 打开新文件</span><br><span class="line">:bn 切换到下一个文件（当前窗口）</span><br><span class="line">:bp 切换到上一个文件（当前窗口）</span><br><span class="line">Ctrl-w h    移动到窗口左边</span><br><span class="line">Ctrl-w j    移动到窗口下边</span><br><span class="line">Ctrl-w k    移动到窗口上边</span><br><span class="line">Ctrl-w l    移动到窗口右边</span><br></pre></td></tr></table></figure><p><em>未完待续……</em></p><p>参考链接：<a href="https://www.cnblogs.com/linyx/p/4131699.html" target="_blank" rel="noopener">https://www.cnblogs.com/linyx/p/4131699.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>perl 脚本模板</title>
      <link href="/2018/11/13/perl-jiao-ben-mo-ban/"/>
      <url>/2018/11/13/perl-jiao-ben-mo-ban/</url>
      
        <content type="html"><![CDATA[<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl -w</span></span><br><span class="line"><span class="keyword">use</span> strict;</span><br><span class="line"><span class="keyword">use</span> Getopt::Long;</span><br><span class="line"><span class="keyword">use</span> File::Basename;</span><br><span class="line"><span class="keyword">use</span> FindBin <span class="string">qw($Bin $Script)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $USAGE = <span class="string">qq&#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Fuction：</span></span><br><span class="line"><span class="string">        test</span></span><br><span class="line"><span class="string">Useage:</span></span><br><span class="line"><span class="string">        perl $0 [Options]</span></span><br><span class="line"><span class="string">Options:</span></span><br><span class="line"><span class="string">        -h|help         Print this help</span></span><br><span class="line"><span class="string">        -i| input       &lt;str&gt;  input input file</span></span><br><span class="line"><span class="string">        -o|output       &lt;str&gt;  output output file</span></span><br><span class="line"><span class="string">Other:</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">&#125;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> ($help,$input,$output);</span><br><span class="line"></span><br><span class="line">GetOptions(<span class="comment"># 冒号为设置参数类型</span></span><br><span class="line"><span class="string">"help:s"</span>=&gt;\$help,</span><br><span class="line"><span class="string">"input:s"</span>=&gt;\$input,</span><br><span class="line"><span class="string">"output:s"</span>=&gt;\$output</span><br><span class="line">);</span><br><span class="line"><span class="keyword">die</span> <span class="string">"$USAGE\n"</span> <span class="keyword">unless</span> ($input &amp;&amp; $output);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> perl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> perl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 cookbook笔记： 第八章 类与对象(二)</title>
      <link href="/2018/11/12/python3cook-xi-lie-bi-ji-ba/"/>
      <url>/2018/11/12/python3cook-xi-lie-bi-ji-ba/</url>
      
        <content type="html"><![CDATA[<p><em>本节介绍property装饰器的用法</em></p><p><code>proprety</code>的作用是可以将方法变成属性，那它到底是怎么实现的呢？让我们先来看一个例子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">self.first_name = name</span><br><span class="line"><span class="comment"># Getter 方法</span></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_name</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> self._first_name</span><br><span class="line"><span class="comment"># Setter 方法</span></span><br><span class="line"><span class="meta">@first_name.setter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_name</span><span class="params">(self, value)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, str):</span><br><span class="line"><span class="keyword">raise</span> TypeError(<span class="string">'Expected a string'</span>)</span><br><span class="line">self._first_name = value</span><br><span class="line"><span class="comment"># Deleter 方法(可选)</span></span><br><span class="line"><span class="meta">@first_name.deleter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_name</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">raise</span> AttributeError(<span class="string">"Can't delete attribute"</span>)</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Person(<span class="string">'Guido'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.first_name <span class="comment"># 调用getter方法</span></span><br><span class="line"><span class="string">'Guido'</span></span><br></pre></td></tr></table></figure><p>当我们进行赋值操作时<code>a = Person(&#39;Guido&#39;)</code>就创建了实例，在构造函数中的赋值语句<code>self.first_name</code>就会自动调用<code>first_name</code>的<code>getter</code>、<code>setter</code>、<code>deleter</code>方法(实质上是调用了<code>__get__()</code> 、<code>__set__()</code>和<code>__delete__()</code> 方法)。</p><p>而将等号右边的<code>name</code>参数传入到<code>@first_name.setter</code>下面的方法中，书中是用的<code>first_name</code>变量名字，其实这里设置成其他的变量名比较好，要不然容易混淆参数与方法函数。</p><p>因此装饰器<code>property</code>将原来的<code>first_name()</code>方法，变成了<code>self.first_name</code>属性,一开始我们要调用方法是<code>var.mothed()</code>,现在变成了属性，只用<code>.</code>运算符就可以, 括号就不需要了</p><p>接下来我们来看另一中形式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self._name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(value, str):</span><br><span class="line">            self._name = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._name = <span class="string">'to getter '</span></span><br></pre></td></tr></table></figure><p>这里在构造函数中并没有调用<code>getter</code>、<code>setter</code>方法，那么，<code>self._name</code>，<code>self.name</code>其实是两个不同的属性，只是<code>self._name</code>属性依赖于<code>self.name</code>:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Animal(<span class="string">'black dog'</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.name <span class="comment"># 此时其实是没有调用setter方法的，只调用了 getter方法</span></span><br><span class="line"><span class="string">'black dog'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a._name <span class="comment"># 因为没有调用setter方法，所以self._name值也没有修改</span></span><br><span class="line"><span class="string">'black dog'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.name = <span class="number">1</span> <span class="comment"># 调用了setter方法，但是不是字符串类型的，所以执行 self._name = 'to getter '，然后调用getter方法，返回self._name的值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.name</span><br><span class="line"><span class="string">'to getter '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a._name <span class="comment"># 因为进行了赋值操作，因此self._name的值也进行了修改</span></span><br><span class="line"><span class="string">'to getter '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.name = <span class="string">"white55k"</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.name</span><br><span class="line"><span class="string">'white55k'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a._name</span><br><span class="line"><span class="string">'white55k'</span></span><br></pre></td></tr></table></figure><p>这里要说明的一点是<code>__init__</code>函数的参数<code>name</code>只是执行了<code>self._name = name</code>赋值操作，由于并没有调用<code>setter</code>方法，因此<code>def name(self, value)</code>需要重新传入参数(赋值)</p><p>在看另一种用法，只设置<code>getter</code>方法，变成只读属性，实现编程接口：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._birth</span><br><span class="line"></span><br><span class="line"><span class="meta">    @birth.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._birth = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2018</span> - self._birth</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=Student() <span class="comment"># 创建实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.birth=<span class="number">1990</span> <span class="comment"># setter</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.birth <span class="comment"># getter</span></span><br><span class="line"><span class="number">1990</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.age <span class="comment"># 只有 getter</span></span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.age=<span class="number">2</span> <span class="comment"># 调用setter方法，会报错</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: can<span class="string">'t set attribute</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令：tar</title>
      <link href="/2018/11/11/linux-xi-lie-tar/"/>
      <url>/2018/11/11/linux-xi-lie-tar/</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -cvf log.tar log2018.log    #仅打包，不压缩！</span><br><span class="line"></span><br><span class="line">tar -zcvf log.tar.gz log2018.log   #打包后，以 gzip 压缩</span><br><span class="line">tar -jcvf log.tar.bz2 log2018.log  #打包后，以 bzip2 压缩</span><br><span class="line"></span><br><span class="line">tar -zxvf /opt/soft/test/log.tar.gz # 解压gz</span><br><span class="line">tar -jxvf /opt/soft/test/log.tar.bz2 # 解压bz2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>perl 命令行中打印单引号</title>
      <link href="/2018/11/11/perl-ming-ling-xing-da-yin-dan-yin-hao/"/>
      <url>/2018/11/11/perl-ming-ling-xing-da-yin-dan-yin-hao/</url>
      
        <content type="html"><![CDATA[<p>一开始我以为在单行命令中打印单引号是这样的：</p>  <figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">  perl -e <span class="string">'print "\'";'</span></span><br><span class="line">  <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">后来发现这样写是不行的，在第二个单号的时候就会与第一个引号匹配，而被当作这命令未结束。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">因为反斜杠对符号做了转义，这样的命令解释成：perl -e 'print ';' (双引号内一个单引号，它被当作了括住命令的单引号了)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">搜索了一波才知道要这样写：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  `</span><span class="string">``</span>perl</span><br><span class="line">  perl -e <span class="string">'print "'</span>\<span class="string">''</span><span class="string">";'</span></span><br></pre></td></tr></table></figure><p>双引号内是 单引号 反斜杠 单引号 ，这样经过双引号代换后变成：</p>  <figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">perl -e <span class="string">'print \' '</span></span><br></pre></td></tr></table></figure><p>也就是说，在命令行中要使用反转义线’\’, 就必须带（单？）引号,这样才会被Perl语言解释成反转义线，要不然会被shell捕获成反转义线</p>]]></content>
      
      
      <categories>
          
          <category> perl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> perl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 cookbook笔记： 第八章 类与对象(一)</title>
      <link href="/2018/11/09/python3cook-xi-lie-bi-ji-qi/"/>
      <url>/2018/11/09/python3cook-xi-lie-bi-ji-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类 定义了一组属性，这些属性与一组叫做<strong>实例</strong>的对象相关且由其共享。类通常是由函数（称为<strong>方法</strong> ，method）、变量（称为<strong>类变量</strong> ，class variable）和计算出的属性（称为<strong>特性</strong> ，property）组成的集合</p><h3 id="class-语句"><a href="#class-语句" class="headerlink" title="class 语句"></a>class 语句</h3><p>使用<code>class</code>语句可定义类。类主体包含一系列在类定义时执行的语句，例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span><span class="params">(object)</span>:</span></span><br><span class="line">　　 num_accounts = <span class="number">0</span></span><br><span class="line">　　 <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,balance)</span>:</span></span><br><span class="line">　　　　 self.name = name</span><br><span class="line">　　　　 self.balance = balance</span><br><span class="line">　　　　 Account.num_accounts += <span class="number">1</span></span><br><span class="line">　　 <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">　　　　 Account.num_accounts -= <span class="number">1</span></span><br><span class="line">　　 <span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(self,amt)</span>:</span></span><br><span class="line">　　　　 self.balance = self.balance + amt</span><br><span class="line">　　 <span class="function"><span class="keyword">def</span> <span class="title">withdraw</span><span class="params">(self,amt)</span>:</span></span><br><span class="line">　　　　 self.balance = self.balance - amt</span><br><span class="line">　　 <span class="function"><span class="keyword">def</span> <span class="title">inquiry</span><span class="params">(self)</span>:</span></span><br><span class="line">　　　　 <span class="keyword">return</span> self.balance</span><br></pre></td></tr></table></figure><p>在类主体执行期间创建的值放在类对象中，这个对象充当着命名空间，与模块极为相似。例如，访问Account 类成员的方式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Account.num_accounts</span><br><span class="line">Account.__init__</span><br><span class="line">Account.__del__</span><br><span class="line">Account.deposit</span><br><span class="line">Account.withdraw</span><br><span class="line">Account.inquiry</span><br></pre></td></tr></table></figure><p>需要注意的是，class 语句本身并不创建该类的任何实例（例如，上一个例子实际上不会创建任何账户）。类仅设置将在以后创建的所有实例使用的属性。从这种意义上讲，可以将类看作一个蓝图。</p><p>类中定义的函数称为<strong>实例方法</strong> 。实例方法是一种在类的实例上进行操作的函数，类实例作为第一个参数传递。根据约定，这个参数称为<code>self</code> ，尽管所有合法的标识符都可以使用。在前面的例子中，<code>deposit()</code> 、<code>withdraw()</code>和<code>inquiry()</code> 都是实例方法。</p><p><strong>类变量</strong>（如<code>num_accounts</code> ）是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。上例中的<code>num_accounts</code> 变量用于跟踪存在多少个Account 实例。</p><h3 id="类实例"><a href="#类实例" class="headerlink" title="类实例"></a>类实例</h3><p>类的实例是以函数形式调用类对象来创建的。这种方法将创建一个新实例，然后将该实例传递给类的<code>__init__()</code>方法。<code>__init__()</code> 方法的参数包括新创建的实例self 和在调用类对象时提供的参数。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一些账户</span></span><br><span class="line">a = Account(<span class="string">"Guido"</span>, <span class="number">1000.00</span>)　 </span><br><span class="line"><span class="comment"># 调用Account.__init__(a,"Guido",1000.00)</span></span><br><span class="line">b = Account(<span class="string">"Bill"</span>, <span class="number">10.00</span>)</span><br></pre></td></tr></table></figure><p>在<code>__init__()</code> 内，通过将属性分配给self 来将其保存到实例中。上例中，<code>self.name =  &quot;Guido&quot;</code>。</p><p><strong>上面创建了两个实例</strong>，然后用(<code>.</code>)运算符即可访问属性：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.deposit(<span class="number">100.00</span>)　　　</span><br><span class="line"><span class="comment"># 调用Account.deposit(a,100.00)</span></span><br><span class="line"><span class="comment"># self.balance已经通过__init__实例化,即self.balance = 1000.00</span></span><br><span class="line"><span class="comment"># 所以访问deposit属性后：</span></span><br><span class="line"><span class="comment"># self.balance = 1000.00 + 100.00</span></span><br><span class="line">b.withdraw(<span class="number">50.00</span>)　　　<span class="comment"># 调用Account.withdraw(b,50.00)</span></span><br><span class="line">name = a.name　　　　　<span class="comment"># 获取账户名</span></span><br></pre></td></tr></table></figure><h2 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h2><ul><li>默认的字符串显示是<code>__str__()</code>方法，我们可以自定义<code>__repr__()</code> 和<code>__str__()</code>来是的交互更加友好</li><li><code>format()</code> 函数实际上是调用的<code>__formait__()</code>方法</li><li><code>with</code>语句是调用的<code>__enter__()</code> 和<code>__exit__()</code> 方法,我们可以在定义类的时候定义这两个方法，就能使对象支持<code>witg</code>上下文管理</li></ul>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, AF_INET, SOCK_STREAM</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyConnection</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, address, family=AF_INET, type=SOCK_STREAM)</span>:</span></span><br><span class="line">        self.address = address</span><br><span class="line">        self.family = family</span><br><span class="line">        self.type = type</span><br><span class="line">        self.sock = <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.sock <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">'Already connected'</span>)</span><br><span class="line">        self.sock = socket(self.family, self.type)</span><br><span class="line">        self.sock.connect(self.address)</span><br><span class="line">        <span class="keyword">return</span> self.sock</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_ty, exc_val, tb)</span>:</span></span><br><span class="line">        self.sock.close()</span><br><span class="line">        self.sock = <span class="keyword">None</span></span><br></pre></td></tr></table></figure><ul><li>类添加<code>__slots__</code>属性来极大的减少实例所占的内存,但使用后我们不能再给实例添加新的属性了，只能使用在<code>__slots__</code> 中定义的那些属性名。</li><li>约定是任何以单下划线<code>_</code> 开头的名字都应该是内部实现</li><li><p>使用双下划线开始会导致访问名称变成其他形式:</p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__private = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__private_method</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public_method</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        self.__private_method()</span><br></pre></td></tr></table></figure></li></ul><p>比如，在前面的类<code>B</code> 中，私有属性会被分别重命名为<code>_B__private</code> 和<code>_B__private_method</code> 。这时候你可能会问这样重命名的目的是什么，答案就是继承——这种属性通过继承是无法被覆盖的。比如：</p><pre><code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.__private = <span class="number">1</span> <span class="comment"># Does not override B.__private</span></span><br><span class="line">    <span class="comment"># Does not override B.__private_method()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__private_method</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></code></pre><p>这里，私有名称<code>__private</code> 和<code>__private_method</code> 被重命名为<code>_C__private</code> 和<code>_C__private_method</code> ，这个跟父类<code>B</code> 中的名称是完全不同的。</p><ul><li>有时候你定义的一个变量和某个保留关键字冲突，这时候可以使用单下划线作为后缀</li></ul>]]></content>
      
      
      <categories>
          
          <category> python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 标准库系列(四)---logging</title>
      <link href="/2018/11/08/python3-biao-zhun-ku-xi-lie-si-logging/"/>
      <url>/2018/11/08/python3-biao-zhun-ku-xi-lie-si-logging/</url>
      
        <content type="html"><![CDATA[<p><code>logging</code>模块可以给脚本添加日志功能。</p><p>下面是一个输出日志的简单版：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># levelname 输出等级</span></span><br><span class="line"><span class="comment"># asctime 时间</span></span><br><span class="line"><span class="comment"># lineno 所在行</span></span><br><span class="line"><span class="comment"># module 所在模块名</span></span><br><span class="line"><span class="comment"># filename 日志输出函数的模块的文件名，注意不是参数 filename</span></span><br><span class="line"><span class="comment"># message 输出的内容</span></span><br><span class="line">logging.basicConfig(format=<span class="string">'%(levelname)s %(asctime)s,line %(lineno)s:\t%(message)s'</span>,</span><br><span class="line">                    level=logging.INFO,</span><br><span class="line">                    datefmt=<span class="string">'%Y-%m-%d %H:%M:%S'</span>) <span class="comment"># 可以加filename=logfile参数将日志输出到文件中</span></span><br><span class="line"></span><br><span class="line">logging.critical(<span class="string">'当发生严重错误，导致应用程序不能继续运行时记录的信息'</span>)</span><br><span class="line">logging.error(<span class="string">'由于一个更严重的问题导致某些功能不能正常运行时记录的信息'</span>)</span><br><span class="line">logging.warning(<span class="string">'当某些不期望的事情发生时记录的信息（如，磁盘可用空间较低），但是此时应用程序还是正常运行的'</span>)</span><br><span class="line">logging.info(<span class="string">'信息详细程度仅次于DEBUG，通常只记录关键节点信息，用于确认一切都是按照我们预期的那样进行工作'</span>)</span><br><span class="line">logging.debug(<span class="string">'最详细的日志信息，典型应用场景是 问题诊断'</span>)</span><br></pre></td></tr></table></figure><p>日志调用（<code>critical()</code>, <code>error()</code>, <code>warning()</code>, <code>info()</code>, <code>debug()</code>）以降序方式表示不同的严重级别,默认是<code>warning</code>。</p><p>下面的是一个自己用的以天为单位的输出日志的函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> logging.handlers <span class="keyword">import</span> TimedRotatingFileHandler</span><br><span class="line"><span class="keyword">from</span> logging.handlers <span class="keyword">import</span> RotatingFileHandler</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_init</span><span class="params">(logfile)</span>:</span></span><br><span class="line">    log_fmt = <span class="string">'%(asctime)s\tFile \"%(filename)s\",line %(lineno)s\t%(levelname)s: %(message)s'</span></span><br><span class="line">    formatter = logging.Formatter(log_fmt)</span><br><span class="line">    <span class="comment"># 可以设置间隔时间，这里是一天生成一个文件</span></span><br><span class="line">    log_file_handler = TimedRotatingFileHandler(filename=logfile, when=<span class="string">"D"</span>, interval=<span class="number">1</span>, backupCount=<span class="number">7</span>)</span><br><span class="line">    log_file_handler.suffix = <span class="string">"%Y-%m-%d.log"</span></span><br><span class="line">    <span class="comment"># filehanlder.suffix的格式必须这么写，才能自动删除旧文件</span></span><br><span class="line">    <span class="comment"># 如果设定是天，就必须写成“%Y-%m-%d.log”，写成其他格式会导致删除旧文件不生效</span></span><br><span class="line"></span><br><span class="line">    log_file_handler.setFormatter(formatter)</span><br><span class="line">    <span class="comment"># log_file_handler.setLevel(logging.DEBUG)</span></span><br><span class="line">    logging.getLogger().setLevel(logging.DEBUG)</span><br><span class="line">    logging.getLogger().addHandler(log_file_handler)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    这里是需要运行的程序，需要按照文件格式删除log文件，需要启用 extMatch、removeHandle函数</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># logging.info('this is a loggging info message')</span></span><br><span class="line">    <span class="comment"># logging.debug('this is a loggging debug message')</span></span><br><span class="line">    <span class="comment"># logging.warning('this is loggging a warning message')</span></span><br><span class="line">    <span class="comment"># logging.error('this is an loggging error message')</span></span><br><span class="line">    <span class="comment"># logging.critical('this is a loggging critical message')</span></span><br></pre></td></tr></table></figure><p>修改所调用的模块中的日志设置：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># somelib.py</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">log = logging.getLogger(__name__) <span class="comment"># 默认就是： __name__ 只的当前的模块</span></span><br><span class="line">log.addHandler(logging.NullHandler())</span><br><span class="line"><span class="comment"># Example function (for testing)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    log.critical(<span class="string">'A Critical Error!'</span>)</span><br><span class="line">    log.debug(<span class="string">'A debug message'</span>)</span><br></pre></td></tr></table></figure><p>下面我们调用这个模块：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> logging</span><br><span class="line"><span class="comment"># 这是当前脚本的日志设置</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>logging.basicConfig(level=logging.ERROR)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> somelib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>somelib.func()</span><br><span class="line">CRITICAL:somelib:A Critical Error!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 指定模块名，改变该模块的输出级别</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>logging.getLogger(<span class="string">'somelib'</span>).level=logging.DEBUG</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>somelib.func()</span><br><span class="line">CRITICAL:somelib:A Critical Error!</span><br><span class="line">DEBUG:somelib:A debug message</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>在这里，根日志被配置成仅仅输出<code>ERROR</code> 或更高级别的消息。不过，<code>somelib</code> 的日志级别被单独配置成可以输出debug 级别的消息，它的优先级比全局配置高。像这<br>样更改单独模块的日志配置对于调试来讲是很方便的，因为你无需去更改任何的全局日志配置——只需要修改你想要更多输出的模块的日志等级。</p>]]></content>
      
      
      <categories>
          
          <category> python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 cookbook笔记：第四章 文件与IO</title>
      <link href="/2018/11/07/python3cook-xi-lie-bi-ji-liu/"/>
      <url>/2018/11/07/python3cook-xi-lie-bi-ji-liu/</url>
      
        <content type="html"><![CDATA[<p>所有程序都要处理输入和输出。这一章将涵盖处理不同类型的文件，包括文本和二进制文件，文件编码和其他相关的内容。对文件名和目录的操作也会涉及到。</p><p>文本打开模式：</p><div class="table-container"><table><thead><tr><th style="text-align:center">模式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">t</td><td style="text-align:left">文本模式(默认)</td></tr><tr><td style="text-align:center">r</td><td style="text-align:left">以只读方式打开文件。这是默认模式。</td></tr><tr><td style="text-align:center">rb</td><td style="text-align:left">读取二进制文件</td></tr><tr><td style="text-align:center">w</td><td style="text-align:left">写入文件</td></tr><tr><td style="text-align:center">wb</td><td style="text-align:left">写入二进制到文件中</td></tr><tr><td style="text-align:center">a</td><td style="text-align:left">追加形式写入文件</td></tr><tr><td style="text-align:center">w+</td><td style="text-align:left">打开文件用于读写，文件指针在开始</td></tr><tr><td style="text-align:center">a+</td><td style="text-align:left">打开文件用于读写，追加模式</td></tr></tbody></table></div><ul><li><code>open()</code> 函数默认是以”utf-8“编码打开文件，<code>encoding</code>参数可以指定编码：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.txt'</span>, <span class="string">'rt'</span>, encoding=<span class="string">'latin-1'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><em>ps:我们都指定写入文件是用的<code>f.write()</code>,但是<code>print()</code>函数也可以指定<code>file</code>参数来输出内容到文件中：</em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'d:/work/test.txt'</span>, <span class="string">'wt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(<span class="string">'Hello World!'</span>, file=f)</span><br></pre></td></tr></table></figure><p><code>newline</code>参数可以指定行分隔符。默认情况下，Python 会以统一模式处理换行符(，在Unix 和Windows 中是不一样的,分别是\n 和\r\n ):</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.txt'</span>, <span class="string">'rt'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> f:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><ul><li>读写一个gzip 或bz2 格式的压缩文件，跟普通读写差别不是很大，直接看示例就好。</li></ul><p>读取压缩文件：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gzip compression</span></span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">with</span> gzip.open(<span class="string">'somefile.gz'</span>, <span class="string">'rt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    text = f.read()</span><br><span class="line"><span class="comment"># bz2 compression</span></span><br><span class="line"><span class="keyword">import</span> bz2</span><br><span class="line"><span class="keyword">with</span> bz2.open(<span class="string">'somefile.bz2'</span>, <span class="string">'rt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    text = f.read()</span><br></pre></td></tr></table></figure><p>写入压缩文件：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> gzip.open(<span class="string">'somefile.gz'</span>, <span class="string">'wt'</span>, compresslevel=<span class="number">5</span>) <span class="keyword">as</span> f:</span><br><span class="line">f.write(text)</span><br></pre></td></tr></table></figure><p><code>compresslevel</code>参数是指定压缩级别，默认的等级是9，也是最高的压缩等级。等级越低性能越好，但是数据压缩程度也越低。</p><ul><li>获取固定长度，而不是一行一行迭代：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line">RECORD_SIZE = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.data'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    records = iter(partial(f.read, RECORD_SIZE), <span class="string">b''</span>)</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> records:</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><ul><li>本章也介绍了<code>os.path</code>模块的使用，请参见<strong>python3标准库系列笔记</strong></li><li>创建临时文件和文件夹，使用完以后会自动销毁：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryFile</span><br><span class="line"><span class="comment"># 创建临时文件</span></span><br><span class="line"><span class="keyword">with</span> TemporaryFile(<span class="string">'w+t'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># Read/write to the file</span></span><br><span class="line">    f.write(<span class="string">'Hello World\n'</span>)</span><br><span class="line">    f.write(<span class="string">'Testing\n'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 回到文件开始，读取文件</span></span><br><span class="line">    f.seek(<span class="number">0</span>)</span><br><span class="line">    data = f.read()</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = TemporaryFile(<span class="string">'w+t'</span>)</span><br><span class="line"><span class="comment"># Use the temporary file</span></span><br><span class="line">...</span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># File is destroyed</span></span><br></pre></td></tr></table></figure><p>在大多数Unix 系统上，通过<code>TemporaryFile()</code> 创建的文件都是匿名的，甚至连目录都没有。如果你想打破这个限制，可以使用<code>NamedTemporaryFile()</code> 来代替。比如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> NamedTemporaryFile</span><br><span class="line"><span class="keyword">with</span> NamedTemporaryFile(<span class="string">'w+t'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(<span class="string">'filename is:'</span>, f.name)</span><br><span class="line">    ...</span><br><span class="line"><span class="comment"># File automatically destroyed</span></span><br></pre></td></tr></table></figure><p>这里，被打开文件的<code>f.name</code> 属性包含了该临时文件的文件名。当你需要将文件<br>名传递给其他代码来打开这个文件的时候，这个就很有用了。和<code>TemporaryFile()</code> 一样，结果<strong>文件关闭</strong>时会被自动删除掉。如果你不想这么做，可以传递一个关键字参数<code>delete=False</code> 即可。比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with NamedTemporaryFile(&apos;w+t&apos;, delete=False) as f:</span><br><span class="line">    print(&apos;filename is:&apos;, f.name)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>为了创建一个临时目录，可以使用<code>tempfile.TemporaryDirectory()</code> 。比如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryDirectory</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> TemporaryDirectory() <span class="keyword">as</span> dirname:</span><br><span class="line">    print(<span class="string">'dirname is:'</span>, dirname)</span><br><span class="line">    <span class="comment"># Use the directory</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment"># Directory and all contents destroyed</span></span><br></pre></td></tr></table></figure><ul><li>序列化Python 对象</li></ul><p>以下内容来源于廖老师的<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener"><strong>python教程</strong></a>,非常感谢廖老师出了如此优秀的入门教程</p><p>在程序运行的过程中，所有的变量都是在内存中，比如，定义一个<code>dict</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = dict(name=<span class="string">'Bob'</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</span><br></pre></td></tr></table></figure><p>可以随时修改变量，比如把<code>name</code>改成<code>&#39;Bill&#39;</code>，但是一旦程序结束，变量所占用的内存就被操作系统全部回收。如果没有把修改后的<code>&#39;Bill&#39;</code>存储到磁盘上，下次重新运行程序，变量又被初始化为<code>&#39;Bob&#39;</code>。</p><p>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫<code>pickling</code>，在其他语言中也被称之为<code>serialization</code>，<code>marshalling</code>，<code>flattening</code>等等，都是一个意思。</p><p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p><p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即<code>unpickling</code>。</p><p>Python提供两个模块来实现序列化：<code>cPickle</code>和<code>pickle</code>。这两个模块功能是一样的，区别在于<code>cPickle</code>是C语言写的，速度快，<code>pickle</code>是纯Python写的，速度慢，跟<code>cStringIO</code>和<code>StringIO</code>一个道理。用的时候，先尝试导入<code>cPickle</code>，如果失败，再导入<code>pickle</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> cPickle <span class="keyword">as</span> pickle</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> pickle</span><br></pre></td></tr></table></figure><p>首先，我们尝试把一个对象序列化并写入文件：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = dict(name=<span class="string">'Bob'</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.dumps(d)</span><br><span class="line"><span class="string">"(dp0\nS'age'\np1\nI20\nsS'score'\np2\nI88\nsS'name'\np3\nS'Bob'\np4\ns."</span></span><br></pre></td></tr></table></figure><p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>str</code>，然后，就可以把这个<code>str</code>写入文件。或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个<code>file-like Object</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'dump.txt'</span>, <span class="string">'wb'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.dump(d, f)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br></pre></td></tr></table></figure><p>看看写入的<code>dump.txt</code>文件，一堆乱七八糟的内容，这些都是Python保存的对象内部信息。</p><p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个<code>str</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象。我们打开另一个Python命令行来反序列化刚才保存的对象：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'dump.txt'</span>, <span class="string">'rb'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = pickle.load(f)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'score'</span>: <span class="number">88</span>, <span class="string">'name'</span>: <span class="string">'Bob'</span>&#125;</span><br></pre></td></tr></table></figure><p>变量的内容又回来了！</p><p>当然，这个变量和原来的变量是完全不相干的对象，它们只是内容相同而已。</p><p><em>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</em></p><p>为了从字节流中恢复一个对象，使用<code>picle.load()</code> 或<code>pickle.loads()</code> 函数。比如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Restore from a file</span></span><br><span class="line">f = open(<span class="string">'somefile'</span>, <span class="string">'rb'</span>)</span><br><span class="line">data = pickle.load(f)</span><br><span class="line"><span class="comment"># Restore from a string</span></span><br><span class="line">data = pickle.loads(s)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 标准库系列(二)---argparse 模块</title>
      <link href="/2018/11/07/python3-biao-zhun-ku-xi-lie-er-argparse/"/>
      <url>/2018/11/07/python3-biao-zhun-ku-xi-lie-er-argparse/</url>
      
        <content type="html"><![CDATA[<p><code>argparse</code> 模块是标准库中最大的模块之一，拥有大量的配置选项，本章只列出了一些常用的选项：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'Search some files'</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(dest=<span class="string">'filenames'</span>,metavar=<span class="string">'filename'</span>, nargs=<span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'-p'</span>, <span class="string">'--pat'</span>,metavar=<span class="string">'pattern'</span>, required=<span class="keyword">True</span>,dest=<span class="string">'patterns'</span>, action=<span class="string">'append'</span>,help=<span class="string">'text pattern to search for'</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'-v'</span>, dest=<span class="string">'verbose'</span>, action=<span class="string">'store_true'</span>,help=<span class="string">'verbose mode'</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'-o'</span>, dest=<span class="string">'outfile'</span>, action=<span class="string">'store'</span>,help=<span class="string">'output file'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--speed'</span>, dest=<span class="string">'speed'</span>, action=<span class="string">'store'</span>,choices=&#123;<span class="string">'slow'</span>,<span class="string">'fast'</span>&#125;, default=<span class="string">'slow'</span>,help=<span class="string">'search speed'</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="comment"># 使用方法</span></span><br><span class="line">print(args.filenames)</span><br><span class="line">print(args.patterns)</span><br><span class="line">print(args.verbose)</span><br><span class="line">print(args.outfile)</span><br><span class="line">print(args.speed)</span><br></pre></td></tr></table></figure><p>为了解析命令行选项， 你首先要创建一个<code>ArgumentParser</code> 实例，并使用<code>add_argument()</code>方法声明你想要支持的选项。</p><p>在每个<code>add_argument()</code> 调用中，</p><ul><li><p><code>dest</code>参数指定解析结果被指派给属性的名字。</p></li><li><p><code>metavar</code> 参数被用来生成帮助信息(<code>metavar</code>仅更改显示的名称，<code>parse_args()</code>对象上属性的名称仍由<code>dest</code>值确定)。</p></li><li><p><code>action</code>参数指定跟属性对应的处理逻辑，通常的值为<code>store</code> , 被用来存储某个值或将多个参数值收集到一个列表中。其他参数：<code>store_true</code>,<code>store_false</code>:</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'store_true'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--bar'</span>, action=<span class="string">'store_false'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--baz'</span>, action=<span class="string">'store_false'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'--foo --bar'</span>.split())</span><br><span class="line">Namespace(foo=<span class="keyword">True</span>, bar=<span class="keyword">False</span>, baz=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>下面的参数收集所有剩余的命令行参数到一个列表中。在本例中它被用来构造一个文件名列表：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser.add_argument(dest=<span class="string">'filenames'</span>,metavar=<span class="string">'filename'</span>, nargs=<span class="string">'*'</span>)</span><br></pre></td></tr></table></figure><p>下面的参数根据参数是否存在来设置一个Boolean 标志：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'-v'</span>, dest=<span class="string">'verbose'</span>, action=<span class="string">'store_true'</span>,help=<span class="string">'verbose mode'</span>)</span><br></pre></td></tr></table></figure><p>下面的参数接受一个单独值并将其存储为一个字符串：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'-o'</span>, dest=<span class="string">'outfile'</span>, action=<span class="string">'store'</span>,help=<span class="string">'output file'</span>)</span><br></pre></td></tr></table></figure><ul><li><p>如果要接收多个值，可以使用<code>nargs</code>参数，其支持的值有：</p><ul><li>N  (整数), 检测命令行的该参数值的个数，只接收N个值</li><li>* , 也就是说参数可以接收任意个数值</li><li>+,  与‘*’ 一样，但是如果少于一个值，会生成错误信息，有点像通配符</li><li>？，如果传入了参数就使用参数给定的值，如果没有，就用默认值,这个需要设置默认值</li><li><code>argparse.REMAINDER</code>所有剩余的命令行参数都收集到一个列表中:</li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'command'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'args'</span>, nargs=argparse.REMAINDER)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(parser.parse_args(<span class="string">'--foo B cmd --arg1 XX ZZ'</span>.split()))</span><br><span class="line">Namespace(args=[<span class="string">'--arg1'</span>, <span class="string">'XX'</span>, <span class="string">'ZZ'</span>], command=<span class="string">'cmd'</span>, foo=<span class="string">'B'</span>)</span><br></pre></td></tr></table></figure><ul><li>下面的参数说明接受一个值，但是会将其和可能的选择值做比较，以检测其合法性：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--speed'</span>, dest=<span class="string">'speed'</span>, action=<span class="string">'store'</span>,choices=&#123;<span class="string">'slow'</span>,<span class="string">'fast'</span>&#125;, default=<span class="string">'slow'</span>,help=<span class="string">'search speed'</span>)</span><br></pre></td></tr></table></figure><p>也就是说只能选择<code>choices</code>参数中的值，否则会报错</p><p>其他一些参数：</p><ul><li><code>default</code>: 设置默认值</li><li><code>type</code>: 设置接收的内置类型，如<code>float</code>或<code>int</code>,(常见的内置类型和<strong>函数</strong>可以直接用作type参数的值)</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'foo'</span>, type=int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, type=open)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'2 temp.txt'</span>.split())</span><br><span class="line">Namespace(bar=&lt;_io.TextIOWrapper name=<span class="string">'temp.txt'</span> encoding=<span class="string">'UTF-8'</span>&gt;, foo=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li><code>required</code>: 设置为必须参数</li></ul><p><code>ArgumentParser.add_argument_group</code>可以参数设置分组：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>, add_help=<span class="keyword">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group = parser.add_argument_group(<span class="string">'group'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group.add_argument(<span class="string">'--foo'</span>, help=<span class="string">'foo help'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group.add_argument(<span class="string">'bar'</span>, help=<span class="string">'bar help'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [--foo FOO] bar</span><br><span class="line"></span><br><span class="line">group:</span><br><span class="line">  bar    bar help</span><br><span class="line">  --foo FOO  foo help</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>, add_help=<span class="keyword">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group1 = parser.add_argument_group(<span class="string">'group1'</span>, <span class="string">'group1 description'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group1.add_argument(<span class="string">'foo'</span>, help=<span class="string">'foo help'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group2 = parser.add_argument_group(<span class="string">'group2'</span>, <span class="string">'group2 description'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group2.add_argument(<span class="string">'--bar'</span>, help=<span class="string">'bar help'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [--bar BAR] foo</span><br><span class="line"></span><br><span class="line">group1:</span><br><span class="line">  group1 description</span><br><span class="line"></span><br><span class="line">  foo    foo help</span><br><span class="line"></span><br><span class="line">group2:</span><br><span class="line">  group2 description</span><br><span class="line"></span><br><span class="line">  --bar BAR  bar help</span><br></pre></td></tr></table></figure><ul><li><code>ArgumentParser.add_mutually_exclusive_group(required=False)</code> 可以设置一组互斥的参数组，即在该组中参数只能选零个或一个,当<code>required=True</code>时，标准该参数组必须选组中的一个参数：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group = parser.add_mutually_exclusive_group(required=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'store_true'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group.add_argument(<span class="string">'--bar'</span>, action=<span class="string">'store_false'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([]) </span><br><span class="line"><span class="comment"># 如果required=False,那么这里不会报错</span></span><br><span class="line"><span class="comment"># Namespace(bar=True, foo=False)</span></span><br><span class="line">usage: PROG [-h] (--foo | --bar)</span><br><span class="line">PROG: error: one of the arguments --foo --bar <span class="keyword">is</span> required</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 标准库系列(三)---os.path</title>
      <link href="/2018/11/07/python3-biao-zhun-ku-xi-lie-san-os.path/"/>
      <url>/2018/11/07/python3-biao-zhun-ku-xi-lie-san-os.path/</url>
      
        <content type="html"><![CDATA[<p><code>os.path</code>模块比较简单，先记住下面这些常用的用就可以了：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>path = <span class="string">'/Users/beazley/Data/data.csv'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 获取文件名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.basename(path)</span><br><span class="line"><span class="string">'data.csv'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 获取文件所在目录名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.dirname(path)</span><br><span class="line"><span class="string">'/Users/beazley/Data'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 多个元素拼接成一个链接</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">'tmp'</span>, <span class="string">'data'</span>, os.path.basename(path))</span><br><span class="line"><span class="string">'tmp/data/data.csv'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 将家目录符号~换成真实链接</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>path = <span class="string">'~/Data/data.csv'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.expanduser(path)</span><br><span class="line"><span class="string">'/Users/beazley/Data/data.csv'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 获取文件扩展名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.splitext(path)</span><br><span class="line">(<span class="string">'~/Data/data'</span>, <span class="string">'.csv'</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="comment"># 检查文件或目录是否存在</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.exists(<span class="string">'/etc/passwd'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 检测是不是文件类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isfile(<span class="string">'/etc/passwd'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 检测是不是目录类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isdir(<span class="string">'/etc/passwd'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 检测是不是符号链接</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.islink(<span class="string">'/usr/local/bin/python3'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 返回一个绝对路径</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.realpath(<span class="string">'/usr/local/bin/python3'</span>)</span><br><span class="line"><span class="string">'/usr/local/bin/python3.3'</span></span><br><span class="line">&gt;&gt;&gt;<span class="comment"># 获取文件大小</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.getsize(<span class="string">'/etc/passwd'</span>)</span><br><span class="line"><span class="number">3669</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 获取文件修改日期</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.getmtime(<span class="string">'/etc/passwd'</span>)</span><br><span class="line"><span class="number">1272478234.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> time</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.ctime(os.path.getmtime(<span class="string">'/etc/passwd'</span>))</span><br><span class="line"><span class="string">'Wed Apr 28 13:10:34 2010'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 获取指定目录下的文件列表 </span></span><br><span class="line">&gt;&gt;&gt;os.listdir(<span class="string">'somedir'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 cookbook笔记：第四章 迭代器与生成器</title>
      <link href="/2018/11/05/python3cook-xi-lie-bi-ji-wu/"/>
      <url>/2018/11/05/python3cook-xi-lie-bi-ji-wu/</url>
      
        <content type="html"><![CDATA[<p>可迭代对象是一个比较新的词汇，而迭代是Python 最强大的功能之一。初看起来，你可能会简单的认为迭代只不过是处理序列中元素的一种方法。然而，绝非仅仅就是如此，还有很多你可能不知道的，比如创建你自己的迭代器对象，在itertools 模块中使用有用的迭代模式，构造生成器函数等等。</p><ol><li><p>使用<code>next()</code>可以实现手动手动迭代，其实任何迭代内部都是调用了<code>__next__()</code>方法迭代结束标识是在结尾处捕获了<code>StopIteration</code></p></li><li><p><code>yield</code> 语句可是创建一个可迭代对象</p></li><li><p>函数<code>itertools.islice()</code>用于在迭代器和生成器上做切片操作:</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    &gt;&gt;&gt; <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">yield</span> n</span><br><span class="line"><span class="meta">... </span>            n += <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = count(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="number">10</span>:<span class="number">20</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'generator'</span> object <span class="keyword">is</span> <span class="keyword">not</span> subscriptable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Now using islice()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> itertools.islice(c, <span class="number">10</span>, <span class="number">20</span>):</span><br><span class="line"><span class="meta">... </span>print(x)</span><br><span class="line">...</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p> 迭代器和生成器不能使用标准的切片操作，因为它们的长度事先我们并不知道(并且也没有实现索引)。函数islice() 返回一个可以生成指定元素的迭代器，它通过遍<br>历并丢弃直到切片开始索引位置的所有元素。然后才开始一个个的返回元素，并直到切片结束索引位置。<br> 这里要着重强调的一点是islice() 会消耗掉传入的迭代器中的数据。必须考虑到迭代器是不可逆的这个事实。所以如果你需要之后再次访问这个迭代器的话，那你就得<br>先将它里面的数据放入一个列表中。</p></li><li><p><code>itertools.dropwhile()</code> 函数,你给它传递一个函数对象和一个可迭代对象。它会返回一个迭代器对象，丢弃原有序列中直到函数返回Flase 之前的所有元素，然后返回后<br>面所有元素。</p></li><li><p><strong>排列组合的迭代：</strong>迭代遍历一个集合中元素的所有可能的排列或组合。<br><code>itertools.permutations()</code>函数接受一个集合并产生一个元组序列，序列包括了集合中所有的排列组合(顺序不同也算是一种组合)：</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> p <span class="keyword">in</span> permutations(items):</span><br><span class="line"><span class="meta">... </span>print(p)</span><br><span class="line">...</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>)</span><br><span class="line">(<span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>)</span><br><span class="line">(<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>)</span><br><span class="line">(<span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">(<span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p> 如果你想得到指定长度的所有排列，你可以传递一个可选的长度参数:</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> p <span class="keyword">in</span> permutations(items, <span class="number">2</span>):</span><br><span class="line"><span class="meta">... </span>print(p)</span><br><span class="line">...</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'c'</span>)</span><br><span class="line">(<span class="string">'b'</span>, <span class="string">'a'</span>)</span><br><span class="line">(<span class="string">'b'</span>, <span class="string">'c'</span>)</span><br><span class="line">(<span class="string">'c'</span>, <span class="string">'a'</span>)</span><br><span class="line">(<span class="string">'c'</span>, <span class="string">'b'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p> <code>itertools.combinations()</code>函数也是返回排列组合，但是忽略顺序，即，组合(‘a’,’b’) 跟(‘b’, ‘a’)</p></li><li><p>内置的<code>enumerate() 函数</code>返回索引跟对应的元素</p></li><li><p><code>zip()</code> 函数可以同时迭代多喝序列：</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>xpts = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ypts = [<span class="number">101</span>, <span class="number">78</span>, <span class="number">37</span>, <span class="number">15</span>, <span class="number">62</span>, <span class="number">99</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> zip(xpts, ypts):</span><br><span class="line"><span class="meta">... </span>    print(x,y)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">101</span></span><br><span class="line"><span class="number">5</span> <span class="number">78</span></span><br><span class="line"><span class="number">4</span> <span class="number">37</span></span><br><span class="line"><span class="number">2</span> <span class="number">15</span></span><br><span class="line"><span class="number">10</span> <span class="number">62</span></span><br><span class="line"><span class="number">7</span> <span class="number">99</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>isinstance(x, Iterable)</code> 检查某个元素是否是可迭代的</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 cookbook笔记：第二章 字符串和文本</title>
      <link href="/2018/11/02/python3cook-xi-lie-bi-ji-si/"/>
      <url>/2018/11/02/python3cook-xi-lie-bi-ji-si/</url>
      
        <content type="html"><![CDATA[<p>本章介绍了几种字符串的操作方式，python提供了大量的内置的操作函数，若果还解决不了问题就需要用正则表达式。</p><p>由于自己对这部分处理没有需求，就只是大概看了看，而且后面几个小节没有看懂，因此这部分就暂时不整理了。</p><p>等以后有文字处理这方面的需求再回过头来复习</p><p><code>startswith()</code> 和<code>endswith()</code> 方法提供了一个非常方便的方式去做字符串开头和结尾的检查,这里就不举例了。</p><p><strong>正则表达式</strong></p><pre><code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.compile() <span class="comment"># 编译匹配模式</span></span><br><span class="line">re.match() <span class="comment"># 匹配开头</span></span><br><span class="line">re.search() <span class="comment"># 任意位置,但只匹配一次</span></span><br><span class="line">re.findall() <span class="comment"># 匹配多次，返回元组</span></span><br><span class="line">re.finditer() <span class="comment"># 匹配多次，返回迭代器</span></span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      <categories>
          
          <category> python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 标准库系列(一)---email模块</title>
      <link href="/2018/11/02/python3-biao-zhun-ku-xi-lie-yi-email/"/>
      <url>/2018/11/02/python3-biao-zhun-ku-xi-lie-yi-email/</url>
      
        <content type="html"><![CDATA[<p>自己写的一个发邮件的类，自己用的时候，省的自己再到处翻教程</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#-*-coding:utf-8-*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.image <span class="keyword">import</span> MIMEImage</span><br><span class="line"><span class="keyword">from</span> email <span class="keyword">import</span> encoders</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> parseaddr, formataddr</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">发送邮件：</span></span><br><span class="line"><span class="string">文本，网页，附件，图片</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sendemail</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,mailToList,mailHost,mailUser,mailPass,sub)</span>:</span></span><br><span class="line">        self.mailToList = mailToList  <span class="comment"># 邮件接收方的邮件地址，传入的必须是list类型</span></span><br><span class="line">        self.mailHost = mailHost    <span class="comment"># 邮件传送协议服务器: smtp.qiye.163.com</span></span><br><span class="line">        self.mailUser = mailUser  <span class="comment"># 邮件发送方的邮箱账号: xxxx@xxxx.org</span></span><br><span class="line">        self.mailPass = mailPass  <span class="comment"># 邮件发送方的邮箱密码: ****</span></span><br><span class="line">        self.sub = sub <span class="comment"># 邮件名</span></span><br><span class="line">        <span class="comment">#self.content = content # 内容</span></span><br><span class="line">        <span class="comment">#self.subtype = subtype # 发送类型 plain(文字)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_formatAddr</span><span class="params">(self,s)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">            处理发件人的名字，防止有带中文名的发件人</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        name, addr = parseaddr(s)</span><br><span class="line">        <span class="keyword">return</span> formataddr((Header(name, <span class="string">'utf-8'</span>).encode(), addr))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sendEmail</span><span class="params">(self,content,subtype)</span>:</span></span><br><span class="line">        msg = MIMEMultipart(<span class="string">'mixed'</span>) <span class="comment">#　默认就是　mixed类型</span></span><br><span class="line">        me = re.split(<span class="string">'@'</span>,self.mailUser)[<span class="number">0</span>]+<span class="string">"&lt;"</span>+self.mailUser+<span class="string">"&gt;"</span></span><br><span class="line">        msg[<span class="string">'Subject'</span>] = self.sub</span><br><span class="line">        msg[<span class="string">'From'</span>] = self._formatAddr(me)</span><br><span class="line">        msg[<span class="string">'To'</span>] = <span class="string">','</span>.join(self.mailToList)  <span class="comment"># 多个收件人以“,”分隔</span></span><br><span class="line">        text = MIMEText(content, _subtype=subtype, _charset=<span class="string">'utf-8'</span>)</span><br><span class="line">        msg.attach(text)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            server = smtplib.SMTP()</span><br><span class="line">            server.connect(self.mailHost)</span><br><span class="line">            server.login(self.mailUser, self.mailPass)</span><br><span class="line">            server.sendmail(me, self.mailToList, msg.as_string())</span><br><span class="line">            server.quit()</span><br><span class="line">            print(<span class="string">"发送成功"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (e)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sendFile</span><span class="params">(self,file)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        发送附件'''</span></span><br><span class="line">        msg = MIMEMultipart(<span class="string">'mixed'</span>) <span class="comment">#　默认就是　mixed类型</span></span><br><span class="line">        me = re.split(<span class="string">'@'</span>,self.mailUser)[<span class="number">0</span>]+<span class="string">"&lt;"</span>+self.mailUser+<span class="string">"&gt;"</span></span><br><span class="line">        msg[<span class="string">'Subject'</span>] = self.sub</span><br><span class="line">        msg[<span class="string">'From'</span>] = self._formatAddr(me)</span><br><span class="line">        msg[<span class="string">'To'</span>] = <span class="string">','</span>.join(self.mailToList)</span><br><span class="line">        </span><br><span class="line">        sendfile=open(file,<span class="string">'rb'</span>).read()</span><br><span class="line">        text_att = MIMEText(sendfile, <span class="string">'base64'</span>, <span class="string">'utf-8'</span>) </span><br><span class="line">        text_att[<span class="string">"Content-Type"</span>] = <span class="string">'application/octet-stream'</span>  </span><br><span class="line">        <span class="comment"># 设置附件名字，如果是windows下的中文文件名需要以gbk编码，这里默认是再Linux上的中文名字的文件</span></span><br><span class="line">        text_att.add_header(<span class="string">'Content-Disposition'</span>, <span class="string">'attachment'</span>, filename=(<span class="string">"utf-8"</span>, <span class="string">""</span>,os.path.basename(file)))</span><br><span class="line">        <span class="comment">#return text_att</span></span><br><span class="line">        </span><br><span class="line">        msg.attach(text_att)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            server = smtplib.SMTP()</span><br><span class="line">            server.connect(self.mailHost)</span><br><span class="line">            server.login(self.mailUser, self.mailPass)</span><br><span class="line">            server.sendmail(me, self.mailToList, msg.as_string())</span><br><span class="line">            server.quit()</span><br><span class="line">            print(<span class="string">"发送成功"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (e)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    mailToList = [<span class="string">"xxx@xx.com"</span>,<span class="string">"xxx@xxx.com"</span>]  <span class="comment"># 邮件接收方的邮件地址，传入的必须是list类型</span></span><br><span class="line">    mailHost = <span class="string">"smtp.qiye.163.com"</span>    <span class="comment"># 邮件传送协议服务器: smtp.qiye.163.com</span></span><br><span class="line">    mailUser = <span class="string">"xxx@xxx.com"</span>  <span class="comment"># 邮件发送方的邮箱账号: xxxx@xxxx.com</span></span><br><span class="line">    mailPass = <span class="string">"xxxx"</span>  <span class="comment"># 邮件发送方的邮箱密码: ****</span></span><br><span class="line">    sub = <span class="string">"测试邮件"</span> <span class="comment"># 邮件名</span></span><br><span class="line">    s = Sendemail(mailToList,mailHost,mailUser,mailPass,sub)</span><br><span class="line">    <span class="comment">#content  内容/文件路径</span></span><br><span class="line">    <span class="comment">#subtype  发送类型 plain(文字) html(网页) 正文图片(目前只能实现插入一张图) 附件</span></span><br><span class="line">    content = <span class="string">"test"</span></span><br><span class="line">    subtype = <span class="string">"plain"</span></span><br><span class="line">    <span class="comment"># 如果发送的是附件用这个函数，暂时不支持邮件正文中发图片，因为比较麻烦，就是把图片插入网页格式中</span></span><br><span class="line">    s.sendFile(<span class="string">"filepath"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 cookbook笔记：第一章 数据结构和算法(三)---字典的用法(续)</title>
      <link href="/2018/11/01/python3cook-xi-lie-bi-ji-san/"/>
      <url>/2018/11/01/python3cook-xi-lie-bi-ji-san/</url>
      
        <content type="html"><![CDATA[<p><strong>写在开头：感谢译者们的对本书的翻译！非常棒的一本提升python技能的书，项目地址：<a href="https://github.com/yidao620c/python3-cookbook" target="_blank" rel="noopener">https://github.com/yidao620c/python3-cookbook</a></strong> </p><ol><li><p><code>itertools.groupby()</code>可以根据指定字段来分组：</p><pre><code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rows = [</span><br><span class="line">&#123;<span class="string">'address'</span>: <span class="string">'5412 N CLARK'</span>, <span class="string">'date'</span>: <span class="string">'07/01/2012'</span>&#125;,</span><br><span class="line">&#123;<span class="string">'address'</span>: <span class="string">'5148 N CLARK'</span>, <span class="string">'date'</span>: <span class="string">'07/04/2012'</span>&#125;,</span><br><span class="line">&#123;<span class="string">'address'</span>: <span class="string">'5800 E 58TH'</span>, <span class="string">'date'</span>: <span class="string">'07/02/2012'</span>&#125;,</span><br><span class="line">&#123;<span class="string">'address'</span>: <span class="string">'2122 N CLARK'</span>, <span class="string">'date'</span>: <span class="string">'07/03/2012'</span>&#125;,</span><br><span class="line">&#123;<span class="string">'address'</span>: <span class="string">'5645 N RAVENSWOOD'</span>, <span class="string">'date'</span>: <span class="string">'07/02/2012'</span>&#125;,</span><br><span class="line">&#123;<span class="string">'address'</span>: <span class="string">'1060 W ADDISON'</span>, <span class="string">'date'</span>: <span class="string">'07/02/2012'</span>&#125;,</span><br><span class="line">&#123;<span class="string">'address'</span>: <span class="string">'4801 N BROADWAY'</span>, <span class="string">'date'</span>: <span class="string">'07/01/2012'</span>&#125;,</span><br><span class="line">&#123;<span class="string">'address'</span>: <span class="string">'1039 W GRANVILLE'</span>, <span class="string">'date'</span>: <span class="string">'07/04/2012'</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></code></pre><p> 我们按照date来分组：</p><pre><code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</span><br><span class="line"><span class="comment"># Sort by the desired field first</span></span><br><span class="line">rows.sort(key=itemgetter(<span class="string">'date'</span>))</span><br><span class="line"><span class="comment"># Iterate in groups</span></span><br><span class="line"><span class="keyword">for</span> date, items <span class="keyword">in</span> groupby(rows, key=itemgetter(<span class="string">'date'</span>)):</span><br><span class="line">print(date)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> items:</span><br><span class="line">print(<span class="string">' '</span>, i)</span><br></pre></td></tr></table></figure></code></pre><p> 输出：</p><pre><code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">07</span>/<span class="number">01</span>/<span class="number">2012</span></span><br><span class="line">        &#123;<span class="string">'date'</span>: <span class="string">'07/01/2012'</span>, <span class="string">'address'</span>: <span class="string">'5412 N CLARK'</span>&#125;</span><br><span class="line">&#123;<span class="string">'date'</span>: <span class="string">'07/01/2012'</span>, <span class="string">'address'</span>: <span class="string">'4801 N BROADWAY'</span>&#125;</span><br><span class="line"><span class="number">07</span>/<span class="number">02</span>/<span class="number">2012</span></span><br><span class="line">        &#123;<span class="string">'date'</span>: <span class="string">'07/02/2012'</span>, <span class="string">'address'</span>: <span class="string">'5800 E 58TH'</span>&#125;</span><br><span class="line">        &#123;<span class="string">'date'</span>: <span class="string">'07/02/2012'</span>, <span class="string">'address'</span>: <span class="string">'5645 N RAVENSWOOD'</span>&#125;</span><br><span class="line">        &#123;<span class="string">'date'</span>: <span class="string">'07/02/2012'</span>, <span class="string">'address'</span>: <span class="string">'1060 W ADDISON'</span>&#125;</span><br><span class="line"><span class="number">07</span>/<span class="number">03</span>/<span class="number">2012</span></span><br><span class="line">        &#123;<span class="string">'date'</span>: <span class="string">'07/03/2012'</span>, <span class="string">'address'</span>: <span class="string">'2122 N CLARK'</span>&#125;</span><br><span class="line"><span class="number">07</span>/<span class="number">04</span>/<span class="number">2012</span></span><br><span class="line">        &#123;<span class="string">'date'</span>: <span class="string">'07/04/2012'</span>, <span class="string">'address'</span>: <span class="string">'5148 N CLARK'</span>&#125;</span><br><span class="line">        &#123;<span class="string">'date'</span>: <span class="string">'07/04/2012'</span>, <span class="string">'address'</span>: <span class="string">'1039 W GRANVILLE'</span>&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><p><code>groupby()</code> 函数扫描整个序列并且查找连续相同值（或者根据指定key 函数返回值相同）的元素序列。在每次迭代的时候，它会返回一个值和一个迭代器对象，这个迭代器对象可以生成元素值全部等于上面那个值的组中所有对象。</p><p>还有一个非常重要的准备步骤是要根据指定的字段将数据排序</p><ol><li><code>itertools.compress()</code>,它以一个iterable对象和一个相对应的Boolean 选择器序列作为输入参数。然后输出iterable 对象中对<br>应选择器为True 的元素.</li></ol><p>示例：</p><pre><code>    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">addresses = [</span><br><span class="line"><span class="string">'5412 N CLARK'</span>,</span><br><span class="line"><span class="string">'5148 N CLARK'</span>,</span><br><span class="line"><span class="string">'5800 E 58TH'</span>,</span><br><span class="line"><span class="string">'2122 N CLARK'</span>,</span><br><span class="line"><span class="string">'5645 N RAVENSWOOD'</span>,</span><br><span class="line"><span class="string">'1060 W ADDISON'</span>,</span><br><span class="line"><span class="string">'4801 N BROADWAY'</span>,</span><br><span class="line"><span class="string">'1039 W GRANVILLE'</span>,</span><br><span class="line">]</span><br><span class="line">counts = [ <span class="number">0</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> compress</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>more5 = [n &gt; <span class="number">5</span> <span class="keyword">for</span> n <span class="keyword">in</span> counts]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>more5</span><br><span class="line">[<span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">True</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">True</span>, <span class="keyword">True</span>, <span class="keyword">False</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(compress(addresses, more5))</span><br><span class="line">[<span class="string">'5800 E 58TH'</span>, <span class="string">'1060 W ADDISON'</span>, <span class="string">'4801 N BROADWAY'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></code></pre><ol><li><p><code>collections.namedtuple()</code> 函数对元组进行命名：</p><pre><code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Subscriber = namedtuple(<span class="string">'Subscriber'</span>, [<span class="string">'addr'</span>, <span class="string">'joined'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sub = Subscriber(<span class="string">'jonesy@example.com'</span>, <span class="string">'2012-10-19'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sub</span><br><span class="line">Subscriber(addr=<span class="string">'jonesy@example.com'</span>, joined=<span class="string">'2012-10-19'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sub.addr</span><br><span class="line"><span class="string">'jonesy@example.com'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sub.joined</span><br><span class="line"><span class="string">'2012-10-19'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ol><p>命名元组另一个用途就是作为字典的替代，因为字典存储需要更多的内存空间。如果你需要构建一个非常大的包含字典的数据结构，那么使用命名元组会更加高效。但是需要注意的是，不像字典那样，一个命名元组是不可更改的</p><ol><li><p><code>sum()</code> , <code>min()</code> , <code>max()</code>等函数可以接收迭代器作为参数：</p><pre><code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = sum((x * x <span class="keyword">for</span> x <span class="keyword">in</span> nums)) <span class="comment"># 显示的传递一个生成器表达式对象</span></span><br><span class="line">s = sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> nums) <span class="comment"># 更加优雅的实现方式，省略了括号,而且省去了一个新建列表的命名空间</span></span><br></pre></td></tr></table></figure></code></pre></li><li><p>合并多个字典或映射,先看示例：</p><pre><code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'z'</span>: <span class="number">3</span> &#125;</span><br><span class="line">b = &#123;<span class="string">'y'</span>: <span class="number">2</span>, <span class="string">'z'</span>: <span class="number">4</span> &#125;</span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line">c = ChainMap(a,b)</span><br><span class="line">print(c[<span class="string">'x'</span>]) <span class="comment"># Outputs 1 (from a)</span></span><br><span class="line">print(c[<span class="string">'y'</span>]) <span class="comment"># Outputs 2 (from b)</span></span><br><span class="line">print(c[<span class="string">'z'</span>]) <span class="comment"># Outputs 3 (from a)</span></span><br></pre></td></tr></table></figure></code></pre></li></ol><p>一个<code>ChainMap</code> 接受多个字典并将它们在逻辑上变为一个字典。然后，这些字典并不是真的合并在一起了，<code>ChainMap</code> 类只是在内部创建了一个容纳这些字典的列表并重新定义了一些常见的字典操作来遍历这个列表.</p><p>如果出现重复键，那么第一次出现的映射值会被返回。因此，例子程序中的c[‘z’],总是会返回字典a 中对应的值，而不是b 中对应的值。</p><p>因此，对于字典的更新或删除操作总是影响的是列表中第一个字典。</p><p>与<code>update</code>不同，<code>ChainMap</code> 使用原来的字典，它自己不创建新的字典</p><p><strong>第一章完，下一章：字符串和文本</strong></p>]]></content>
      
      
      <categories>
          
          <category> python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 cookbook笔记：第一章 数据结构和算法(二)---字典的用法</title>
      <link href="/2018/10/31/python3cook-xi-lie-bi-ji-er/"/>
      <url>/2018/10/31/python3cook-xi-lie-bi-ji-er/</url>
      
        <content type="html"><![CDATA[<p><strong>写在开头：感谢译者们的对本书的翻译！非常棒的一本提升python技能的书，项目地址：<a href="https://github.com/yidao620c/python3-cookbook" target="_blank" rel="noopener">https://github.com/yidao620c/python3-cookbook</a></strong> </p><ol><li><p><code>collections</code> 模块中的<code>defaultdict</code>函数能够构造一个值为列表的字典：</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">d = defaultdict(list)</span><br><span class="line">d[<span class="string">'a'</span>].append(<span class="number">1</span>)</span><br><span class="line">d[<span class="string">'a'</span>].append(<span class="number">2</span>)</span><br><span class="line">d[<span class="string">'b'</span>].append(<span class="number">4</span>)</span><br><span class="line">d = defaultdict(set)</span><br><span class="line">d[<span class="string">'a'</span>].add(<span class="number">1</span>)</span><br><span class="line">d[<span class="string">'a'</span>].add(<span class="number">2</span>)</span><br><span class="line">d[<span class="string">'b'</span>].add(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p> 简化版：</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> pairs:</span><br><span class="line">d[key].append(value)</span><br></pre></td></tr></table></figure></li><li><p>字段的键存储是无序的，如果想要一个键顺序是一定的字典，可以这样做：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import OrderedDict</span><br><span class="line">d = OrderedDict()</span><br></pre></td></tr></table></figure><p> 但这样做内存占用比较大</p></li><li><p>如果你在一个字典上执行普通的数学运算，你会发现它们仅仅作用于键，而不是值：</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prices = &#123;</span><br><span class="line"><span class="string">'ACME'</span>: <span class="number">45.23</span>,</span><br><span class="line"><span class="string">'AAPL'</span>: <span class="number">612.78</span>,</span><br><span class="line"><span class="string">'IBM'</span>: <span class="number">205.55</span>,</span><br><span class="line"><span class="string">'HPQ'</span>: <span class="number">37.20</span>,</span><br><span class="line"><span class="string">'FB'</span>: <span class="number">10.75</span></span><br><span class="line">&#125;</span><br><span class="line">min(prices) <span class="comment"># Returns 'AAPL'</span></span><br><span class="line">max(prices) <span class="comment"># Returns 'IBM'</span></span><br></pre></td></tr></table></figure><p> 想要对值进行操作，可以这样：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min(prices, key=lambda k: prices[k]) # Returns &apos;FB&apos;</span><br><span class="line">max(prices, key=lambda k: prices[k]) # Returns &apos;AAPL&apos;</span><br></pre></td></tr></table></figure></li><li><p>对两个字典进行运算：</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Find keys in common</span></span><br><span class="line">a.keys() &amp; b.keys() <span class="comment"># &#123; 'x', 'y' &#125;</span></span><br><span class="line"><span class="comment"># Find keys in a that are not in b</span></span><br><span class="line">a.keys() - b.keys() <span class="comment"># &#123; 'z' &#125;</span></span><br><span class="line"><span class="comment"># Find (key,value) pairs in common</span></span><br><span class="line">a.items() &amp; b.items() <span class="comment"># &#123; ('y', 2) &#125;</span></span><br></pre></td></tr></table></figure><p> <del>ps：如果想要对列表消除重复元素可以转换位集合：</del></p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set(a)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">9</span>&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p> 如果想要对一个复杂类型的列表去重复，就要用到一个稍微复杂一点的函数：</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dedupe</span><span class="params">(items, key=None)</span>:</span></span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        val = item <span class="keyword">if</span> key <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">else</span> key(item)</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">            seen.add(val)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [ &#123;<span class="string">'x'</span>:<span class="number">1</span>, <span class="string">'y'</span>:<span class="number">2</span>&#125;, &#123;<span class="string">'x'</span>:<span class="number">1</span>, <span class="string">'y'</span>:<span class="number">3</span>&#125;, &#123;<span class="string">'x'</span>:<span class="number">1</span>, <span class="string">'y'</span>:<span class="number">2</span>&#125;, &#123;<span class="string">'x'</span>:<span class="number">2</span>, <span class="string">'y'</span>:<span class="number">4</span>&#125;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(dedupe(a, key=<span class="keyword">lambda</span> d: (d[<span class="string">'x'</span>],d[<span class="string">'y'</span>])))</span><br><span class="line">[&#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">3</span>&#125;, &#123;<span class="string">'x'</span>: <span class="number">2</span>, <span class="string">'y'</span>: <span class="number">4</span>&#125;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(dedupe(a, key=<span class="keyword">lambda</span> d: d[<span class="string">'x'</span>]))</span><br><span class="line">[&#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'x'</span>: <span class="number">2</span>, <span class="string">'y'</span>: <span class="number">4</span>&#125;]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li><li><p>按照关键字对字典进行排序：</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rows = [</span><br><span class="line">&#123;<span class="string">'fname'</span>: <span class="string">'Brian'</span>, <span class="string">'lname'</span>: <span class="string">'Jones'</span>, <span class="string">'uid'</span>: <span class="number">1003</span>&#125;,</span><br><span class="line">&#123;<span class="string">'fname'</span>: <span class="string">'David'</span>, <span class="string">'lname'</span>: <span class="string">'Beazley'</span>, <span class="string">'uid'</span>: <span class="number">1002</span>&#125;,</span><br><span class="line">&#123;<span class="string">'fname'</span>: <span class="string">'John'</span>, <span class="string">'lname'</span>: <span class="string">'Cleese'</span>, <span class="string">'uid'</span>: <span class="number">1001</span>&#125;,</span><br><span class="line">&#123;<span class="string">'fname'</span>: <span class="string">'Big'</span>, <span class="string">'lname'</span>: <span class="string">'Jones'</span>, <span class="string">'uid'</span>: <span class="number">1004</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line">rows_by_fname = sorted(rows, key=itemgetter(<span class="string">'fname'</span>))</span><br><span class="line">rows_by_uid = sorted(rows, key=itemgetter(<span class="string">'uid'</span>))</span><br><span class="line">print(rows_by_fname)</span><br><span class="line">print(rows_by_uid)</span><br></pre></td></tr></table></figure></li></ol><p><code>itemgetter()</code> 有时候也可以用<code>lambda</code> 表达式代替，比如：</p><pre><code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">rows_by_fname = sorted(rows, key=<span class="keyword">lambda</span> r: r[<span class="string">'fname'</span>])</span><br><span class="line">rows_by_lfname = sorted(rows, key=<span class="keyword">lambda</span> r: (r[<span class="string">'lname'</span>],r[<span class="string">'fname'</span>]))</span><br></pre></td></tr></table></figure></code></pre><p>理论上讲，<code>operator.attrgetter()</code>与 <code>itemgetter()</code> 函数的作用是一样，书中说<strong>排序不支持原生比较的对象</strong>要用<code>attrgetter()</code>函数，反正我也不知道什么是<strong>不支持原生比较的对象</strong></p><p><strong>下一节：字典的用法(续)</strong></p>]]></content>
      
      
      <categories>
          
          <category> python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习实战笔记(六)---kNN算法</title>
      <link href="/2018/10/30/ji-qi-xue-xi-shi-zhan-bi-ji-liu-knn-suan-fa-yi/"/>
      <url>/2018/10/30/ji-qi-xue-xi-shi-zhan-bi-ji-liu-knn-suan-fa-yi/</url>
      
        <content type="html"><![CDATA[<p>工作原理是：有一组已经分类好的数据。输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。</p><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">对未知类别属性的数据集中的每个点依次执行以下操作：</span></span><br><span class="line"><span class="string">(1) 计算已知类别数据集中的点与当前点之间的距离；</span></span><br><span class="line"><span class="string">(2) 按照距离递增次序排序；</span></span><br><span class="line"><span class="string">(3) 选取与当前点距离最小的k个点；</span></span><br><span class="line"><span class="string">(4) 确定前k个点所在类别的出现频率；</span></span><br><span class="line"><span class="string">(5) 返回前k个点出现频率最高的类别作为当前点的预测分类。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify0</span><span class="params">(inX, dataSet, labels, k)</span>:</span></span><br><span class="line">    <span class="comment"># 返回行数</span></span><br><span class="line">    dataSetSize = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 在列向量方向上重复inX共1次(横向)，行向量方向上重复inX共dataSetSize次(纵向)</span></span><br><span class="line">    diffMat = np.tile(inX, (dataSetSize,<span class="number">1</span>)) - dataSet</span><br><span class="line">    sqDiffMat = diffMat**<span class="number">2</span></span><br><span class="line">    <span class="comment"># sum()所有元素相加，sum(0)列相加，sum(1)行相加</span></span><br><span class="line">    sqDistances = sqDiffMat.sum(axis=<span class="number">1</span>)</span><br><span class="line">    distances = sqDistances**<span class="number">0.5</span></span><br><span class="line">    <span class="comment"># 返回distances中元素从小到大排序后的索引值 </span></span><br><span class="line">    sortedDistIndicies = distances.argsort()</span><br><span class="line">    <span class="comment">#print(sortedDistIndicies)  </span></span><br><span class="line">    classCount=&#123;&#125;          </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        <span class="comment">#print(sortedDistIndicies[i]) # 1,0,3</span></span><br><span class="line">        <span class="comment">#print(labels[sortedDistIndicies[i]]) # A,A,B</span></span><br><span class="line">        voteIlabel = labels[sortedDistIndicies[i]]  </span><br><span class="line">        classCount[voteIlabel] = classCount.get(voteIlabel,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="comment">#python3中用items()替换python2中的iteritems()</span></span><br><span class="line">    <span class="comment">#key=operator.itemgetter(1)根据字典的值进行排序</span></span><br><span class="line">    <span class="comment">#key=operator.itemgetter(0)根据字典的键进行排序</span></span><br><span class="line">    <span class="comment">#reverse降序排序字典        </span></span><br><span class="line">    sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    group = np.array([[<span class="number">1.0</span>,<span class="number">1.1</span>],[<span class="number">1.0</span>,<span class="number">1.0</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0.1</span>]])</span><br><span class="line">    labels = [<span class="string">'A'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'B'</span>]</span><br><span class="line">    <span class="keyword">return</span> group, labels</span><br><span class="line"><span class="comment">#[[1.  1.1]</span></span><br><span class="line"> <span class="comment">#[1.  1. ]</span></span><br><span class="line"> <span class="comment">#[0.  0. ]</span></span><br><span class="line"> <span class="comment">#[0.  0.1]]</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    group, labels = createDataSet()</span><br><span class="line">    result = classify0([<span class="number">0</span>,<span class="number">0</span>], group, labels, <span class="number">3</span>)</span><br><span class="line">    print(result) <span class="comment"># B</span></span><br></pre></td></tr></table></figure><p>计算$(x_1,y_1)$与$(x_2,y_2)$距离公式：</p><script type="math/tex; mode=display">\sqrt{(x_1 - x_2)^2+(y_1-y_2)^2}</script><p>这个距离也叫欧式距离。<br>上述代码的<code>classify0</code>函数中17~21行就是计算距离的方法</p><h2 id="示例一：改进约会网站的配对效果"><a href="#示例一：改进约会网站的配对效果" class="headerlink" title="示例一：改进约会网站的配对效果"></a>示例一：改进约会网站的配对效果</h2><p><em>为了保证代码完整性，保留了<code>classify0</code>,<code>createDataSet</code>,是下列代码能够作为一个脚本单独运行，同时将多余的注释删除，节省空间</em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> listdir</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.lines <span class="keyword">as</span> mlines</span><br><span class="line"><span class="keyword">from</span> matplotlib.font_manager <span class="keyword">import</span> FontProperties</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify0</span><span class="params">(inX, dataSet, labels, k)</span>:</span></span><br><span class="line">    dataSetSize = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">    diffMat = np.tile(inX, (dataSetSize,<span class="number">1</span>)) - dataSet</span><br><span class="line">    sqDiffMat = diffMat**<span class="number">2</span></span><br><span class="line">    sqDistances = sqDiffMat.sum(axis=<span class="number">1</span>)</span><br><span class="line">    distances = sqDistances**<span class="number">0.5</span></span><br><span class="line">    sortedDistIndicies = distances.argsort()</span><br><span class="line">    classCount=&#123;&#125;          </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        voteIlabel = labels[sortedDistIndicies[i]]  </span><br><span class="line">        classCount[voteIlabel] = classCount.get(voteIlabel,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    group = np.array([[<span class="number">1.0</span>,<span class="number">1.1</span>],[<span class="number">1.0</span>,<span class="number">1.0</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0.1</span>]])</span><br><span class="line">    labels = [<span class="string">'A'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'B'</span>]</span><br><span class="line">    <span class="keyword">return</span> group, labels</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file2matrix</span><span class="params">(filename)</span>:</span></span><br><span class="line">    love_dictionary=&#123;<span class="string">'largeDoses'</span>:<span class="number">3</span>, <span class="string">'smallDoses'</span>:<span class="number">2</span>, <span class="string">'didntLike'</span>:<span class="number">1</span>&#125;</span><br><span class="line">    fr = open(filename)</span><br><span class="line">    arrayOLines = fr.readlines()</span><br><span class="line">    numberOfLines = len(arrayOLines)            <span class="comment">#get the number of lines in the file</span></span><br><span class="line">    returnMat = np.zeros((numberOfLines,<span class="number">3</span>))        <span class="comment">#prepare matrix to return</span></span><br><span class="line">    classLabelVector = []                       <span class="comment">#prepare labels return   </span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> arrayOLines:</span><br><span class="line">        line = line.strip()</span><br><span class="line">        listFromLine = line.split(<span class="string">'\t'</span>)</span><br><span class="line">        returnMat[index,:] = listFromLine[<span class="number">0</span>:<span class="number">3</span>] <span class="comment"># 学习numpy之路任重道远啊</span></span><br><span class="line">        <span class="keyword">if</span>(listFromLine[<span class="number">-1</span>].isdigit()):</span><br><span class="line">            classLabelVector.append(int(listFromLine[<span class="number">-1</span>]))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            classLabelVector.append(love_dictionary.get(listFromLine[<span class="number">-1</span>])) <span class="comment"># 最后一列就是标签</span></span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> returnMat,classLabelVector</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">autoNorm</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    minVals = dataSet.min(<span class="number">0</span>)</span><br><span class="line">    maxVals = dataSet.max(<span class="number">0</span>)</span><br><span class="line">    ranges = maxVals - minVals</span><br><span class="line">    normDataSet = np.zeros(np.shape(dataSet))</span><br><span class="line">    m = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">    normDataSet = dataSet - np.tile(minVals, (m,<span class="number">1</span>))</span><br><span class="line">    normDataSet = normDataSet/np.tile(ranges, (m,<span class="number">1</span>))   <span class="comment">#element wise divide</span></span><br><span class="line">    <span class="keyword">return</span> normDataSet, ranges, minVals</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">datingClassTest</span><span class="params">()</span>:</span></span><br><span class="line">    hoRatio = <span class="number">0.50</span>      <span class="comment">#hold out 10%</span></span><br><span class="line">    datingDataMat,datingLabels = file2matrix(<span class="string">'datingTestSet2.txt'</span>)       <span class="comment">#load data setfrom file</span></span><br><span class="line">    normMat, ranges, minVals = autoNorm(datingDataMat)</span><br><span class="line">    m = normMat.shape[<span class="number">0</span>]</span><br><span class="line">    numTestVecs = int(m*hoRatio)</span><br><span class="line">    errorCount = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numTestVecs):</span><br><span class="line">    <span class="comment">#前numTestVecs个数据作为测试集,后m-numTestVecs个数据作为训练集</span></span><br><span class="line">        classifierResult = classify0(normMat[i,:],normMat[numTestVecs:m,:],datingLabels[numTestVecs:m],<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"the classifier came back with: %d, the real answer is: %d"</span> % (classifierResult, datingLabels[i]))</span><br><span class="line">        <span class="keyword">if</span> (classifierResult != datingLabels[i]): errorCount += <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"the total error rate is: %f"</span> % (errorCount/float(numTestVecs)))</span><br><span class="line">    <span class="keyword">print</span> (errorCount)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classifyPerson</span><span class="params">()</span>:</span></span><br><span class="line">    resultList = [<span class="string">'not at all'</span>, <span class="string">'in small doses'</span>, <span class="string">'in large doses'</span>]</span><br><span class="line">    percentTats = float(input(\</span><br><span class="line">                                  <span class="string">"percentage of time spent playing video games?"</span>))</span><br><span class="line">    ffMiles = float(input(<span class="string">"frequent flier miles earned per year?"</span>))</span><br><span class="line">    iceCream = float(input(<span class="string">"liters of ice cream consumed per year?"</span>))</span><br><span class="line">    datingDataMat, datingLabels = file2matrix(<span class="string">'datingTestSet2.txt'</span>)</span><br><span class="line">    normMat, ranges, minVals = autoNorm(datingDataMat)</span><br><span class="line">    inArr = np.array([ffMiles, percentTats, iceCream, ])</span><br><span class="line">    classifierResult = classify0((inArr - \</span><br><span class="line">                                  minVals)/ranges, normMat, datingLabels, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"You will probably like this person: %s"</span> % resultList[classifierResult - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showdatas</span><span class="params">(datingDataMat, datingLabels)</span>:</span></span><br><span class="line">    <span class="comment">#设置汉字格式</span></span><br><span class="line">    font = FontProperties(fname=<span class="string">r"c:\windows\fonts\simsun.ttc"</span>, size=<span class="number">12</span>)</span><br><span class="line">    <span class="comment">#将fig画布分隔成1行1列,不共享x轴和y轴,fig画布的大小为(13,8)</span></span><br><span class="line">    <span class="comment">#当nrow=2,nclos=2时,代表fig画布被分为四个区域,axs[0][0]表示第一行第一个区域</span></span><br><span class="line">    fig, axs = plt.subplots(nrows=<span class="number">2</span>, ncols=<span class="number">2</span>,sharex=<span class="keyword">False</span>, sharey=<span class="keyword">False</span>, figsize=(<span class="number">13</span>,<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#numberOfLabels = len(datingLabels)</span></span><br><span class="line">    LabelsColors = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> datingLabels:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">            LabelsColors.append(<span class="string">'black'</span>)</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">2</span>:</span><br><span class="line">            LabelsColors.append(<span class="string">'orange'</span>)</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">3</span>:</span><br><span class="line">            LabelsColors.append(<span class="string">'red'</span>)</span><br><span class="line">    <span class="comment">#画出散点图,以datingDataMat矩阵的第一(飞行常客例程)、第二列(玩游戏)数据画散点数据,散点大小为15,透明度为0.5</span></span><br><span class="line">    axs[<span class="number">0</span>][<span class="number">0</span>].scatter(x=datingDataMat[:,<span class="number">0</span>], y=datingDataMat[:,<span class="number">1</span>], color=LabelsColors,s=<span class="number">15</span>, alpha=<span class="number">.5</span>)</span><br><span class="line">    <span class="comment">#设置标题,x轴label,y轴label</span></span><br><span class="line">    axs0_title_text = axs[<span class="number">0</span>][<span class="number">0</span>].set_title(<span class="string">u'每年获得的飞行常客里程数与玩视频游戏所消耗时间占比'</span>,FontProperties=font)</span><br><span class="line">    axs0_xlabel_text = axs[<span class="number">0</span>][<span class="number">0</span>].set_xlabel(<span class="string">u'每年获得的飞行常客里程数'</span>,FontProperties=font)</span><br><span class="line">    axs0_ylabel_text = axs[<span class="number">0</span>][<span class="number">0</span>].set_ylabel(<span class="string">u'玩视频游戏所消耗时间占'</span>,FontProperties=font)</span><br><span class="line">    plt.setp(axs0_title_text, size=<span class="number">9</span>, weight=<span class="string">'bold'</span>, color=<span class="string">'red'</span>) </span><br><span class="line">    plt.setp(axs0_xlabel_text, size=<span class="number">7</span>, weight=<span class="string">'bold'</span>, color=<span class="string">'black'</span>) </span><br><span class="line">    plt.setp(axs0_ylabel_text, size=<span class="number">7</span>, weight=<span class="string">'bold'</span>, color=<span class="string">'black'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#画出散点图,以datingDataMat矩阵的第一(飞行常客例程)、第三列(冰激凌)数据画散点数据,散点大小为15,透明度为0.5</span></span><br><span class="line">    axs[<span class="number">0</span>][<span class="number">1</span>].scatter(x=datingDataMat[:,<span class="number">0</span>], y=datingDataMat[:,<span class="number">2</span>], color=LabelsColors,s=<span class="number">15</span>, alpha=<span class="number">.5</span>)</span><br><span class="line">    <span class="comment">#设置标题,x轴label,y轴label</span></span><br><span class="line">    axs1_title_text = axs[<span class="number">0</span>][<span class="number">1</span>].set_title(<span class="string">u'每年获得的飞行常客里程数与每周消费的冰激淋公升数'</span>,FontProperties=font)</span><br><span class="line">    axs1_xlabel_text = axs[<span class="number">0</span>][<span class="number">1</span>].set_xlabel(<span class="string">u'每年获得的飞行常客里程数'</span>,FontProperties=font)</span><br><span class="line">    axs1_ylabel_text = axs[<span class="number">0</span>][<span class="number">1</span>].set_ylabel(<span class="string">u'每周消费的冰激淋公升数'</span>,FontProperties=font)</span><br><span class="line">    plt.setp(axs1_title_text, size=<span class="number">9</span>, weight=<span class="string">'bold'</span>, color=<span class="string">'red'</span>) </span><br><span class="line">    plt.setp(axs1_xlabel_text, size=<span class="number">7</span>, weight=<span class="string">'bold'</span>, color=<span class="string">'black'</span>) </span><br><span class="line">    plt.setp(axs1_ylabel_text, size=<span class="number">7</span>, weight=<span class="string">'bold'</span>, color=<span class="string">'black'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#画出散点图,以datingDataMat矩阵的第二(玩游戏)、第三列(冰激凌)数据画散点数据,散点大小为15,透明度为0.5</span></span><br><span class="line">    axs[<span class="number">1</span>][<span class="number">0</span>].scatter(x=datingDataMat[:,<span class="number">1</span>], y=datingDataMat[:,<span class="number">2</span>], color=LabelsColors,s=<span class="number">15</span>, alpha=<span class="number">.5</span>)</span><br><span class="line">    <span class="comment">#设置标题,x轴label,y轴label</span></span><br><span class="line">    axs2_title_text = axs[<span class="number">1</span>][<span class="number">0</span>].set_title(<span class="string">u'玩视频游戏所消耗时间占比与每周消费的冰激淋公升数'</span>,FontProperties=font)</span><br><span class="line">    axs2_xlabel_text = axs[<span class="number">1</span>][<span class="number">0</span>].set_xlabel(<span class="string">u'玩视频游戏所消耗时间占比'</span>,FontProperties=font)</span><br><span class="line">    axs2_ylabel_text = axs[<span class="number">1</span>][<span class="number">0</span>].set_ylabel(<span class="string">u'每周消费的冰激淋公升数'</span>,FontProperties=font)</span><br><span class="line">    plt.setp(axs2_title_text, size=<span class="number">9</span>, weight=<span class="string">'bold'</span>, color=<span class="string">'red'</span>) </span><br><span class="line">    plt.setp(axs2_xlabel_text, size=<span class="number">7</span>, weight=<span class="string">'bold'</span>, color=<span class="string">'black'</span>) </span><br><span class="line">    plt.setp(axs2_ylabel_text, size=<span class="number">7</span>, weight=<span class="string">'bold'</span>, color=<span class="string">'black'</span>)</span><br><span class="line">    <span class="comment">#设置图例</span></span><br><span class="line">    didntLike = mlines.Line2D([], [], color=<span class="string">'black'</span>, marker=<span class="string">'.'</span>,</span><br><span class="line">                      markersize=<span class="number">6</span>, label=<span class="string">'didntLike'</span>)</span><br><span class="line">    smallDoses = mlines.Line2D([], [], color=<span class="string">'orange'</span>, marker=<span class="string">'.'</span>,</span><br><span class="line">                      markersize=<span class="number">6</span>, label=<span class="string">'smallDoses'</span>)</span><br><span class="line">    largeDoses = mlines.Line2D([], [], color=<span class="string">'red'</span>, marker=<span class="string">'.'</span>,</span><br><span class="line">                      markersize=<span class="number">6</span>, label=<span class="string">'largeDoses'</span>)</span><br><span class="line">    <span class="comment">#添加图例</span></span><br><span class="line">    axs[<span class="number">0</span>][<span class="number">0</span>].legend(handles=[didntLike,smallDoses,largeDoses])</span><br><span class="line">    axs[<span class="number">0</span>][<span class="number">1</span>].legend(handles=[didntLike,smallDoses,largeDoses])</span><br><span class="line">    axs[<span class="number">1</span>][<span class="number">0</span>].legend(handles=[didntLike,smallDoses,largeDoses])</span><br><span class="line">    <span class="comment">#显示图片</span></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 文件有4列 </span></span><br><span class="line">    <span class="comment"># 每年获得的飞行常客里程数</span></span><br><span class="line">    <span class="comment"># 玩视频游戏所耗时间百分比</span></span><br><span class="line">    <span class="comment"># 每周消费的冰淇淋公升数</span></span><br><span class="line">    <span class="comment"># 不喜欢的人 魅力一般的人 极具魅力的人</span></span><br><span class="line">    <span class="comment">#datingDataMat, datingLabels = file2matrix(r'F:\download\machinelearninginaction-master\Ch02\datingTestSet.txt')</span></span><br><span class="line">    <span class="comment">#showdatas(datingDataMat, datingLabels)</span></span><br><span class="line">    <span class="comment">#datingClassTest</span></span><br><span class="line">    classifyPerson()</span><br></pre></td></tr></table></figure><p>下面我们来进行代码解析，<code>showdatas</code>函数是从网上看到的实质上就是将数据可视化，看不懂可以暂时先不管。<br>首先是<code>file2matrix</code>函数读取数据转换成矩阵格式，最后一列就是标签<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># print(datingDataMat)</span><br><span class="line">[[4.0920000e+04 8.3269760e+00 9.5395200e-01]</span><br><span class="line"> [1.4488000e+04 7.1534690e+00 1.6739040e+00]</span><br><span class="line"> [2.6052000e+04 1.4418710e+00 8.0512400e-01]</span><br><span class="line"> ...</span><br><span class="line"> [2.6575000e+04 1.0650102e+01 8.6662700e-01]</span><br><span class="line"> [4.8111000e+04 9.1345280e+00 7.2804500e-01]</span><br><span class="line"> [4.3757000e+04 7.8826010e+00 1.3324460e+00]]</span><br><span class="line"># print(datingLabels)</span><br><span class="line">[3, 2, 1, 1, 1, 1, 3, 3, 1, 3, 1, 1, 2, 1, 1, 1, 1, 1, 2, 3, 2, 1, 2, 3, 2, 3, 2, 3, 2, 1, 3, 1, 3, 1, 2, 1, 1, 2, 3, 3, 1, 2, 3, 3, 3, 1...</span><br></pre></td></tr></table></figure></p><p>可视化后应该是计算两点间的距离，但是，三个数值之间的差异很大，也就是说飞行的里程数占的比重比其他的要大，但是我们在这里认为这三个因素都应该是平等的，因此就要对数据进行归一化处理，所以就有了<code>autoNorm</code>函数。</p><p>此函数用到的算法是</p><script type="math/tex; mode=display">new = (old-min)/(max-min)</script><p>这样就将里程数这个特征值控制在0~1之内，以保证三个特征值的取值范围是一样的，即都有一样的权重。(<em>好像对特征值进行缩放会有损失，暂时先不管</em>)</p><p>最后我们就要去验证这个算法的可靠性了，也就是最后一个函数<code>classifyPerson</code></p><p>这个示例是用了90%的样本来训练，然后用剩下的10%去做验证，后面的算法中也有更高级的数据分组。这也就是<code>datingClassTest</code>函数的功能了</p><hr><h2 id="示例二：手写识别系统"><a href="#示例二：手写识别系统" class="headerlink" title="示例二：手写识别系统"></a>示例二：手写识别系统</h2><p>为了使用前面两个例子的分类器，书中将一个32×32的二进制图像变成了文本存储，这里只附上代码，由于方法都一样，就不在赘述<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import operator</span><br><span class="line">from os import listdir</span><br><span class="line">from numpy import zeros</span><br><span class="line"></span><br><span class="line">def classify0(inX, dataSet, labels, k):</span><br><span class="line">    dataSetSize = dataSet.shape[0]</span><br><span class="line">    diffMat = np.tile(inX, (dataSetSize,1)) - dataSet</span><br><span class="line">    sqDiffMat = diffMat**2</span><br><span class="line">    sqDistances = sqDiffMat.sum(axis=1)</span><br><span class="line">    distances = sqDistances**0.5</span><br><span class="line">    sortedDistIndicies = distances.argsort()</span><br><span class="line">    classCount=&#123;&#125;          </span><br><span class="line">    for i in range(k):</span><br><span class="line">        #print(sortedDistIndicies[i])</span><br><span class="line">        #print(labels[sortedDistIndicies[i]]) </span><br><span class="line">        voteIlabel = labels[sortedDistIndicies[i]]  </span><br><span class="line">        classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1</span><br><span class="line">    sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True)</span><br><span class="line">    return sortedClassCount[0][0]</span><br><span class="line"></span><br><span class="line">def img2vector(filename):</span><br><span class="line">    returnVect = zeros((1,1024))</span><br><span class="line">    fr = open(filename)</span><br><span class="line">    for i in range(32):</span><br><span class="line">        lineStr = fr.readline()</span><br><span class="line">        for j in range(32):</span><br><span class="line">            returnVect[0,32*i+j] = int(lineStr[j])</span><br><span class="line">    return returnVect</span><br><span class="line"></span><br><span class="line">def handwritingClassTest():</span><br><span class="line">    hwLabels = []</span><br><span class="line">    trainingFileList = listdir(r&apos;F:\download\machinelearninginaction-master\Ch02\digits\trainingDigits&apos;)           #load the training set</span><br><span class="line">    m = len(trainingFileList)</span><br><span class="line">    trainingMat = zeros((m,1024))</span><br><span class="line">    for i in range(m):</span><br><span class="line">        fileNameStr = trainingFileList[i]</span><br><span class="line">        fileStr = fileNameStr.split(&apos;.&apos;)[0]     #take off .txt</span><br><span class="line">        classNumStr = int(fileStr.split(&apos;_&apos;)[0])</span><br><span class="line">        hwLabels.append(classNumStr)</span><br><span class="line">        trainingMat[i,:] = img2vector(&apos;F:\\download\\machinelearninginaction-master\\Ch02\digits\\trainingDigits/%s&apos; % fileNameStr)</span><br><span class="line">    testFileList = listdir(r&apos;F:\download\machinelearninginaction-master\Ch02\digits\testDigits&apos;)        #iterate through the test set</span><br><span class="line">    errorCount = 0.0</span><br><span class="line">    mTest = len(testFileList)</span><br><span class="line">    for i in range(mTest):</span><br><span class="line">        fileNameStr = testFileList[i]</span><br><span class="line">        fileStr = fileNameStr.split(&apos;.&apos;)[0]     #take off .txt</span><br><span class="line">        classNumStr = int(fileStr.split(&apos;_&apos;)[0])</span><br><span class="line">        vectorUnderTest = img2vector(&apos;F:\\download\\machinelearninginaction-master\\Ch02\\digits\\testDigits/%s&apos; % fileNameStr)</span><br><span class="line">        classifierResult = classify0(vectorUnderTest, trainingMat, hwLabels, 3)</span><br><span class="line">        print (&quot;the classifier came back with: %d, the real answer is: %d&quot; % (classifierResult, classNumStr))</span><br><span class="line">        if (classifierResult != classNumStr): errorCount += 1.0</span><br><span class="line">    print (&quot;\nthe total number of errors is: %d&quot; % errorCount)</span><br><span class="line">    print (&quot;\nthe total error rate is: %f&quot; % (errorCount/float(mTest)))</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    handwritingClassTest()</span><br></pre></td></tr></table></figure></p><h2 id="Sklearn简介-重点"><a href="#Sklearn简介-重点" class="headerlink" title="Sklearn简介(重点)"></a>Sklearn简介(重点)</h2><p><a href="http://scikit-learn.org/stable/modules/classes.html#module-sklearn.neighbors" target="_blank" rel="noopener"><code>sklearn.neighbors</code></a>模块就是k-近邻算法，这里只介绍一个函数<a href="http://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html#sklearn.neighbors.KNeighborsClassifier" target="_blank" rel="noopener"><code>KNeighborsClassifier</code></a></p><p>其他函数和参数等有时间再补充</p><p> KNneighborsClassifier参数说明：</p><ul><li><code>n_neighbors</code>：默认为5，就是k-NN的k的值，选取最近的k个点。 </li><li><code>weights</code>：默认是uniform，参数可以是uniform、distance，也可以是用户自己定义的函数。uniform是均等的权重，就说所有的邻近点的权重都是相等的。distance是不均等的权重，距离近的点比距离远的点的影响大。用户自定义的函数，接收距离的数组，返回一组维数相同的权重。</li><li><code>algorithm</code>：快速k近邻搜索算法，默认参数为auto，可以理解为算法自己决定合适的搜索算法。除此之外，用户也可以自己指定搜索算法ball_tree、kd_tree、brute方法进行搜索，brute是蛮力搜索，也就是线性扫描，当训练集很大时，计算非常耗时。kd_tree，构造kd树存储数据以便对其进行快速检索的树形数据结构，kd树也就是数据结构中的二叉树。以中值切分构造的树，每个结点是一个超矩形，在维数小于20时效率高。ball tree是为了克服kd树高纬失效而发明的，其构造过程是以质心C和半径r分割样本空间，每个节点是一个超球体。</li><li><code>leaf_size</code>：默认是30，这个是构造的kd树和ball树的大小。这个值的设置会影响树构建的速度和搜索速度，同样也影响着存储树所需的内存大小。需要根据问题的性质选择最优的大小。</li><li><code>metric</code>：用于距离度量，默认度量是minkowski，也就是p=2的欧氏距离(欧几里德度量)。</li><li><code>p</code>：距离度量公式。在上小结，我们使用欧氏距离公式进行距离度量。除此之外，还有其他的度量方法，例如曼哈顿距离。这个参数默认为2，也就是默认使用欧式距离公式进行距离度量。也可以设置为1，使用曼哈顿距离公式进行距离度量。</li><li><code>metric_params</code>：距离公式的其他关键参数，这个可以不管，使用默认的None即可。</li><li><code>n_jobs</code>：并行处理设置。默认为1，临近点搜索并行工作数。如果为-1，那么CPU的所有cores都用于并行工作。</li></ul><p>完整代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> listdir</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier <span class="keyword">as</span> kNN</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数说明:将32x32的二进制图像转换为1x1024向量。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    filename - 文件名</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    returnVect - 返回的二进制图像的1x1024向量</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Modify:</span></span><br><span class="line"><span class="string">    2017-07-15</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img2vector</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="comment">#创建1x1024零向量</span></span><br><span class="line">    returnVect = np.zeros((<span class="number">1</span>, <span class="number">1024</span>))</span><br><span class="line">    <span class="comment">#打开文件</span></span><br><span class="line">    fr = open(filename)</span><br><span class="line">    <span class="comment">#按行读取</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">        <span class="comment">#读一行数据</span></span><br><span class="line">        lineStr = fr.readline()</span><br><span class="line">        <span class="comment">#每一行的前32个元素依次添加到returnVect中</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            returnVect[<span class="number">0</span>, <span class="number">32</span>*i+j] = int(lineStr[j])</span><br><span class="line">    <span class="comment">#返回转换后的1x1024向量</span></span><br><span class="line">    <span class="keyword">return</span> returnVect</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数说明:手写数字分类测试</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    无</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    无</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Modify:</span></span><br><span class="line"><span class="string">    2017-07-15</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handwritingClassTest</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#测试集的Labels</span></span><br><span class="line">    hwLabels = []</span><br><span class="line">    <span class="comment">#返回trainingDigits目录下的文件名</span></span><br><span class="line">    trainingFileList = listdir(<span class="string">r'E:\workspace\python\机器学习实战笔记\kNN\Ch02\digits\trainingDigits'</span>)</span><br><span class="line">    <span class="comment">#返回文件夹下文件的个数</span></span><br><span class="line">    m = len(trainingFileList)</span><br><span class="line">    <span class="comment">#初始化训练的Mat矩阵,测试集</span></span><br><span class="line">    trainingMat = np.zeros((m, <span class="number">1024</span>))</span><br><span class="line">    <span class="comment">#从文件名中解析出训练集的类别</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="comment">#获得文件的名字</span></span><br><span class="line">        fileNameStr = trainingFileList[i]</span><br><span class="line">        <span class="comment">#获得分类的数字</span></span><br><span class="line">        classNumber = int(fileNameStr.split(<span class="string">'_'</span>)[<span class="number">0</span>])</span><br><span class="line">        <span class="comment">#将获得的类别添加到hwLabels中</span></span><br><span class="line">        hwLabels.append(classNumber)</span><br><span class="line">        <span class="comment">#将每一个文件的1x1024数据存储到trainingMat矩阵中</span></span><br><span class="line">        trainingMat[i,:] = img2vector(<span class="string">'E:\\workspace\\python\\机器学习实战笔记\\kNN\\Ch02\\digits\\trainingDigits/%s'</span> % (fileNameStr))</span><br><span class="line">    <span class="comment">#构建kNN分类器</span></span><br><span class="line">    neigh = kNN(n_neighbors = <span class="number">3</span>, algorithm = <span class="string">'auto'</span>)</span><br><span class="line">    <span class="comment">#拟合模型, trainingMat为测试矩阵,hwLabels为对应的标签</span></span><br><span class="line">    neigh.fit(trainingMat, hwLabels)</span><br><span class="line">    <span class="comment">#返回testDigits目录下的文件列表</span></span><br><span class="line">    testFileList = listdir(<span class="string">r'E:\workspace\python\机器学习实战笔记\kNN\Ch02\digits\testDigits'</span>)</span><br><span class="line">    <span class="comment">#错误检测计数</span></span><br><span class="line">    errorCount = <span class="number">0.0</span></span><br><span class="line">    <span class="comment">#测试数据的数量</span></span><br><span class="line">    mTest = len(testFileList)</span><br><span class="line">    <span class="comment">#从文件中解析出测试集的类别并进行分类测试</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(mTest):</span><br><span class="line">        <span class="comment">#获得文件的名字</span></span><br><span class="line">        fileNameStr = testFileList[i]</span><br><span class="line">        <span class="comment">#获得分类的数字</span></span><br><span class="line">        classNumber = int(fileNameStr.split(<span class="string">'_'</span>)[<span class="number">0</span>])</span><br><span class="line">        <span class="comment">#获得测试集的1x1024向量,用于训练</span></span><br><span class="line">        vectorUnderTest = img2vector(<span class="string">'E:\\workspace\\python\\机器学习实战笔记\\kNN\\Ch02\\digits\\testDigits/%s'</span> % (fileNameStr))</span><br><span class="line">        <span class="comment">#获得预测结果</span></span><br><span class="line">        <span class="comment"># classifierResult = classify0(vectorUnderTest, trainingMat, hwLabels, 3)</span></span><br><span class="line">        classifierResult = neigh.predict(vectorUnderTest)</span><br><span class="line">        print(<span class="string">"分类返回结果为%d\t真实结果为%d"</span> % (classifierResult, classNumber))</span><br><span class="line">        <span class="keyword">if</span>(classifierResult != classNumber):</span><br><span class="line">            errorCount += <span class="number">1.0</span></span><br><span class="line">    print(<span class="string">"总共错了%d个数据\n错误率为%f%%"</span> % (errorCount, errorCount/mTest * <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数说明:main函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    无</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    无</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Modify:</span></span><br><span class="line"><span class="string">    2017-07-15</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    handwritingClassTest()</span><br></pre></td></tr></table></figure><hr><p><strong>参考链接：</strong><a href="http://blog.csdn.net/c406495762" target="_blank" rel="noopener">http://blog.csdn.net/c406495762</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python3 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 cookbook笔记：第一章 数据结构和算法(一)---解压列表</title>
      <link href="/2018/10/30/python3cook-xi-lie-bi-ji-yi/"/>
      <url>/2018/10/30/python3cook-xi-lie-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[<p><strong>写在开头：感谢译者们的对本书的翻译！非常棒的一本提升python技能的书，项目地址：<a href="https://github.com/yidao620c/python3-cookbook" target="_blank" rel="noopener">https://github.com/yidao620c/python3-cookbook</a></strong> </p><p>在python中任何可迭代的对象(<strong>列表，元组，字符串，文件，迭代器，生成器等</strong>)都可以直接进行解压并赋值，<strong>只要保证</strong>前后的元素是一样的，比如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; p=(4,5)</span><br><span class="line">&gt;&gt;&gt; x,y=p</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">5</span><br><span class="line"># 嵌套序列也一样</span><br><span class="line">&gt;&gt;&gt; data = [ &apos;ACME&apos;, 50, 91.1, (2012, 12, 21) ]</span><br><span class="line">&gt;&gt;&gt; name, shares, price, date = data</span><br><span class="line">&gt;&gt;&gt; name</span><br><span class="line">&apos;ACME&apos;</span><br><span class="line">&gt;&gt;&gt; date</span><br><span class="line">(2012, 12, 21)</span><br><span class="line">&gt;&gt;&gt; name, shares, price, (year, mon, day) = data</span><br><span class="line">&gt;&gt;&gt; name</span><br><span class="line">&apos;ACME&apos;</span><br><span class="line">&gt;&gt;&gt; year</span><br><span class="line">2012</span><br><span class="line">&gt;&gt;&gt; mon</span><br><span class="line">12</span><br><span class="line">&gt;&gt;&gt; day</span><br><span class="line">21</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>如果只想要部分，可以中<code>_</code>占位一个变量，<code>*_</code>占位多个变量(返回一个列表)，这些变量最后会被丢弃：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; record = (&apos;ACME&apos;, 50, 123.45, (12, 18, 2012))</span><br><span class="line">&gt;&gt;&gt; name, *_, (*_, year) = record</span><br><span class="line">&gt;&gt;&gt; name</span><br><span class="line">&apos;ACME&apos;</span><br><span class="line">&gt;&gt;&gt; year</span><br><span class="line">2012</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>当然<code>*_</code>这个模式也可以不用下划线占位，而是给定一个变量名字，来获取剩余变量的列表：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; items = [1, 10, 7, 4, 5, 9]</span><br><span class="line">&gt;&gt;&gt; head, *tail = items</span><br><span class="line">&gt;&gt;&gt; head</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; tail</span><br><span class="line">[10, 7, 4, 5, 9]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><p><em>拓展阅读：</em></p><p>实现一个优先级队列:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import heapq</span><br><span class="line"></span><br><span class="line">class PriorityQueue:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._queue = []</span><br><span class="line">        self._index = 0</span><br><span class="line">    def push(self, item, priority):</span><br><span class="line">        heapq.heappush(self._queue, (-priority, self._index, item))</span><br><span class="line">        self._index += 1</span><br><span class="line">    def pop(self):</span><br><span class="line">        return heapq.heappop(self._queue)[-1]</span><br></pre></td></tr></table></figure></p><p>使用方式：<br><em>小声bb：这本书喜欢用类，自己要抓紧补一下类的知识了</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class Item:</span><br><span class="line">...     def __init__(self, name):</span><br><span class="line">...         self.name = name</span><br><span class="line">...     def __repr__(self):</span><br><span class="line">...         return &apos;Item(&#123;!r&#125;)&apos;.format(self.name)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; q = PriorityQueue()</span><br><span class="line"># 传入：元素，优先级</span><br><span class="line">&gt;&gt;&gt; q.push(Item(&apos;foo&apos;), 1)</span><br><span class="line">&gt;&gt;&gt; q.push(Item(&apos;bar&apos;), 5)</span><br><span class="line">&gt;&gt;&gt; q.push(Item(&apos;spam&apos;), 4)</span><br><span class="line">&gt;&gt;&gt; q.push(Item(&apos;grok&apos;), 1)</span><br><span class="line">&gt;&gt;&gt; q.pop()</span><br><span class="line">Item(&apos;bar&apos;)</span><br><span class="line">&gt;&gt;&gt; q.pop()</span><br><span class="line">Item(&apos;spam&apos;)</span><br><span class="line">&gt;&gt;&gt; q.pop()</span><br><span class="line">Item(&apos;foo&apos;)</span><br><span class="line">&gt;&gt;&gt; q.pop()</span><br><span class="line">Item(&apos;grok&apos;)</span><br></pre></td></tr></table></figure></p><p><strong>下一节：字典的用法</strong></p>]]></content>
      
      
      <categories>
          
          <category> python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生新基础教程(一)：fastq格式</title>
      <link href="/2018/07/07/sheng-xin-ji-chu-jiao-cheng-yi-fastq-ge-shi/"/>
      <url>/2018/07/07/sheng-xin-ji-chu-jiao-cheng-yi-fastq-ge-shi/</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>转载请注明出处</em></p></blockquote><p><strong>FASTQ格式</strong>是一种保存生物序列（通常为核酸序列）及其测序质量得分信息的文本格式。序列与质量得分皆由单个ASCII字符表示。</p><p><strong>格式</strong></p><p>FASTQ格式通常每个序列使用四行：</p><ul><li>第一行以“@”字符开头，后面是序列标识符和其他描述。</li><li>第二行是序列</li><li>第三行以“+”也是序列标识符和描述（可选）</li><li>第四行是序列的质量得分信息，与第二行的碱基一一对应</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@A00262:122:H5FW3DSXX:3:1101:1561:1031 1:N:0:CCGTGAGA</span><br><span class="line">CNACCCCAAAAATGCTTTTGAAATCCTGAGATGTGATCAGTGAAATATGCAGCCAAGGCAAGGGGAAACTGTCCGCAAGTTAAAAAGATTTATTGCTATTCCAGGCTTCAAATGAGCCCAGAACTCAGGGCTGGTGTGTGTTTCAGAAGT</span><br><span class="line">+</span><br><span class="line">F#FFFFFFFFFFFFFFFFFFFFFFFFFFFFF,F:FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:FFFFFFFFF:FFFFFFFFFFFFFFFFFFF:FFFFFFFFFF:FFFFFFFFFFF:FF,FFFFF:FFFFFFF</span><br></pre></td></tr></table></figure><p><strong>Illumina 测序仪标识符</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">A00262</th><th style="text-align:center">测序仪编号</th></tr></thead><tbody><tr><td style="text-align:center">122</td><td style="text-align:center">运行id</td></tr><tr><td style="text-align:center">H5FW3DSXX</td><td style="text-align:center">flowcell id</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">lane 编号</td></tr><tr><td style="text-align:center">1101</td><td style="text-align:center">tile编号</td></tr><tr><td style="text-align:center">1561</td><td style="text-align:center">tile x坐标</td></tr><tr><td style="text-align:center">1031</td><td style="text-align:center">tile y坐标</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">单端测序为1，双端为2</td></tr><tr><td style="text-align:center">N</td><td style="text-align:center">Y过滤reads(reads质量较差),否则为N</td></tr></tbody></table></div><blockquote><p><strong>ps</strong>: 每个flowcell有8个泳道，一个泳道称为一个Lane，每条Lane上有两列，每列有多个有小格子，叫一个tile。(见下图)</p><p><img src="/myphoto/flowcell.jpg" alt="flowcell"></p></blockquote><p><strong>质量评分</strong></p><p>第四行表示序列的质量值,用<a href="https://en.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">ACSII码</a>表示。<br>测序仪一般是按照荧光信号来判断所测序的碱基是哪一种的，例如红黄蓝绿分别对应ATCG，因此对每个结果的判断都是一个概率的问题：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Phred Quality Score(Q值)</th><th style="text-align:center">错误率</th><th style="text-align:center">碱基准确率</th></tr></thead><tbody><tr><td style="text-align:center">10</td><td style="text-align:center">0.1</td><td style="text-align:center">90%</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">0.01</td><td style="text-align:center">99%</td></tr><tr><td style="text-align:center">30</td><td style="text-align:center">0.001</td><td style="text-align:center">99.9%</td></tr><tr><td style="text-align:center">40</td><td style="text-align:center">0.0001</td><td style="text-align:center">99.99%</td></tr><tr><td style="text-align:center">50</td><td style="text-align:center">0.00001</td><td style="text-align:center">99.999%</td></tr></tbody></table></div><p>一般都是以Q值来衡量read碱基质量，Sanger中心用的换算公式如下，其中P为错误率，</p><script type="math/tex; mode=display">Q=-10logP</script><p>Solexa系列测序仪使用不同的公示来计算质量值：$Q=-10log(P/1-P)$<br>不同的测序平台Q值所能表示的范围不一样，因此要想用对应的ACSII编码，必须加上一个数值(33或者64)<br>以上面的那条Illumina测序仪产生的read为例，<code>F</code>对应的十进制数是70，Q值就是36，也就是说这个碱基的准确率在99.99%以上</p><p><strong>参考链接:</strong></p><ul><li><a href="http://boyun.sh.cn/bio/?p=1901" target="_blank" rel="noopener">http://boyun.sh.cn/bio/?p=1901</a></li><li><a href="https://en.wikipedia.org/wiki/FASTQ_format" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/FASTQ_format</a></li><li><a href="https://blog.csdn.net/godsunshine/article/details/51946314" target="_blank" rel="noopener">https://blog.csdn.net/godsunshine/article/details/51946314</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 生信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件格式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用python3的matplotlib模块画条形图</title>
      <link href="/2018/05/13/yong-python3-de-matplotlib-mo-kuai-hua-tiao-xing-tu/"/>
      <url>/2018/05/13/yong-python3-de-matplotlib-mo-kuai-hua-tiao-xing-tu/</url>
      
        <content type="html"><![CDATA[<p>文章来源：<a href="https://www.kesci.com/apps/home/project/59ed8d7418ec724555a9b4c0" target="_blank" rel="noopener">https://www.kesci.com/apps/home/project/59ed8d7418ec724555a9b4c0</a></p><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">GDP = [12406.8,13908.57,9386.87,9143.64]</span><br><span class="line"># 中文乱码的处理</span><br><span class="line">plt.rcParams[&apos;font.sans-serif&apos;] =[&apos;SimHei&apos;]</span><br><span class="line">plt.rcParams[&apos;axes.unicode_minus&apos;] = False</span><br><span class="line"></span><br><span class="line"># 绘图</span><br><span class="line">plt.bar(range(4), GDP, align = &apos;center&apos;,color=&apos;steelblue&apos;, alpha = 0.8)</span><br><span class="line"># 添加轴标签</span><br><span class="line">plt.ylabel(&apos;GDP&apos;)</span><br><span class="line"># 添加标题</span><br><span class="line">plt.title(&apos;四个直辖市GDP大比拼&apos;)</span><br><span class="line"># 添加刻度标签</span><br><span class="line">plt.xticks(range(4),[&apos;北京市&apos;,&apos;上海市&apos;,&apos;天津市&apos;,&apos;重庆市&apos;])</span><br><span class="line"># 设置Y轴的刻度范围</span><br><span class="line">plt.ylim([5000,15000])</span><br><span class="line"></span><br><span class="line"># 为每个条形图添加数值标签</span><br><span class="line">for x,y in enumerate(GDP):</span><br><span class="line">    plt.text(x,y+100,&apos;%s&apos; %round(y,1),ha=&apos;center&apos;)  # round函数 ，返回y保留1位小数的四舍五入的值</span><br><span class="line">            # 坐标，文字，对齐方式</span><br><span class="line"># 显示图形</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="\myphoto\Figure_1.png" alt="示例一"></p><hr><h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入绘图模块</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line"># 构建数据</span><br><span class="line">Y2016 = [15600,12700,11300,4270,3620]</span><br><span class="line">Y2017 = [17400,14800,12000,5200,4020]</span><br><span class="line">labels = [&apos;北京&apos;,&apos;上海&apos;,&apos;香港&apos;,&apos;深圳&apos;,&apos;广州&apos;]</span><br><span class="line">bar_width = 0.35</span><br><span class="line"></span><br><span class="line"># 中文乱码的处理</span><br><span class="line">plt.rcParams[&apos;font.sans-serif&apos;] =[&apos;SimHei&apos;]</span><br><span class="line">plt.rcParams[&apos;axes.unicode_minus&apos;] = False</span><br><span class="line"></span><br><span class="line"># 绘图</span><br><span class="line">plt.bar(np.arange(5), Y2016, label = &apos;2016&apos;, color = &apos;steelblue&apos;, alpha = 0.8, width = bar_width)</span><br><span class="line">plt.bar(np.arange(5)+bar_width, Y2017, label = &apos;2017&apos;, color = &apos;indianred&apos;, alpha = 0.8, width = bar_width)</span><br><span class="line"># 添加轴标签</span><br><span class="line">plt.xlabel(&apos;Top5城市&apos;)</span><br><span class="line">plt.ylabel(&apos;家庭数量&apos;)</span><br><span class="line"># 添加标题</span><br><span class="line">plt.title(&apos;亿万财富家庭数Top5城市分布&apos;)</span><br><span class="line"># 添加刻度标签</span><br><span class="line">plt.xticks(np.arange(5)+bar_width,labels)</span><br><span class="line"># 设置Y轴的刻度范围</span><br><span class="line">plt.ylim([2500, 19000])</span><br><span class="line"></span><br><span class="line"># 为每个条形图添加数值标签</span><br><span class="line">for x2016,y2016 in enumerate(Y2016):</span><br><span class="line">    plt.text(x2016-0.17, y2016+200, &apos;%s&apos; %y2016)</span><br><span class="line"></span><br><span class="line">for x2017,y2017 in enumerate(Y2017):</span><br><span class="line">    plt.text(x2017+0.17, y2017+100, &apos;%s&apos; %y2017)</span><br><span class="line"># 显示图例</span><br><span class="line">plt.legend()</span><br><span class="line"># 显示图形</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="\myphoto\Figure_1.png" alt="示例二"></p>]]></content>
      
      
      <categories>
          
          <category> python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python3 </tag>
            
            <tag> 可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下多个节点ssh互相免密码登陆</title>
      <link href="/2018/04/29/linux-xia-duo-ge-jie-dian-ssh-hu-xiang-mian-mi-ma-deng-lu/"/>
      <url>/2018/04/29/linux-xia-duo-ge-jie-dian-ssh-hu-xiang-mian-mi-ma-deng-lu/</url>
      
        <content type="html"><![CDATA[<p><strong>假定需要节点gm-35-2和gm-35-18之间免密登陆</strong></p><ol><li>确认安装了ssh</li><li>创建私钥和密钥 （id_rsa和 id_rsa.pub）<br>执行<code>ssh-keygen-t rsa</code> ，这样你进入 <code>~/.ssh</code>文件夹下就会看到 <code>id_rsa</code> 和<code>id_rsa.pub</code>两个文件。每个节点都执行一次</li><li>在<code>gm-35-2</code>下，运行<code>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code></li><li><code>ssh gm-35-18 cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code> 将其他节点公匙拷贝到本节点</li><li><code>scp ~/.ssh/authorized_keys usrname@gm-35-18:~/.ssh/authorized_keys</code> 将文件拷贝到其他节点</li></ol><p><em>网上说要将该文件权限改为600</em></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> Linux </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(转载)samtools常用命令详解</title>
      <link href="/2018/04/29/samtools-chang-yong-ming-ling-xiang-jie/"/>
      <url>/2018/04/29/samtools-chang-yong-ming-ling-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>samtools的说明文档：<a href="http://samtools.sourceforge.net/samtools.shtml" target="_blank" rel="noopener">http://samtools.sourceforge.net/samtools.shtml</a><br>samtools是一个用于操作sam和bam文件的工具合集。包含有许多命令。以下是常用命令的介绍</p><h2 id="view"><a href="#view" class="headerlink" title="view"></a>view</h2><p>view命令的主要功能是：将sam文件转换成bam文件；然后对bam文件进行各种操作，比如数据的排序(不属于本命令的功能)和提取(这些操作是对bam文件进行的，因而当输入为sam文件的时候，不能进行该操作)；最后将排序或提取得到的数据输出为bam或sam（默认的）格式。</p><p>bam文件优点：bam文件为二进制文件，占用的磁盘空间比sam文本文件小；利用bam二进制文件的运算速度快。</p><p>view命令中，对sam文件头部的输入(-t或-T）和输出(-h)是单独的一些参数来控制的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: samtools view [options] &lt;in.bam&gt;|&lt;in.sam&gt; [region1 [...]]</span><br><span class="line"> 默认情况下不加 region，则是输出所有的 region.</span><br><span class="line"></span><br><span class="line">Options: -b       output BAM</span><br><span class="line">                  默认下输出是 SAM 格式文件，该参数设置输出 BAM 格式</span><br><span class="line">         -h       print header for the SAM output</span><br><span class="line">                  默认下输出的 sam 格式文件不带 header，该参数设定输出sam文件时带 header 信息</span><br><span class="line">         -H       print header only (no alignments)</span><br><span class="line">         -S       input is SAM</span><br><span class="line">                  默认下输入是 BAM 文件，若是输入是 SAM 文件，则最好加该参数，否则有时候会报错。</span><br><span class="line">         -u       uncompressed BAM output (force -b)</span><br><span class="line">                  该参数的使用需要有-b参数，能节约时间，但是需要更多磁盘空间。</span><br><span class="line">         -c       Instead of printing the alignments, only count them and print the </span><br><span class="line">                  total number. All filter options, such as ‘-f’, ‘-F’ and ‘-q’ , </span><br><span class="line">                  are taken into account.</span><br><span class="line">         -1       fast compression (force -b)</span><br><span class="line">         -x       output FLAG in HEX (samtools-C specific)</span><br><span class="line">         -X       output FLAG in string (samtools-C specific)</span><br><span class="line">         -c       print only the count of matching records</span><br><span class="line">         -L FILE  output alignments overlapping the input BED FILE [null]</span><br><span class="line">         -t FILE  list of reference names and lengths (force -S) [null]</span><br><span class="line">                  使用一个list文件来作为header的输入</span><br><span class="line">         -T FILE  reference sequence file (force -S) [null]</span><br><span class="line">                  使用序列fasta文件作为header的输入</span><br><span class="line">         -o FILE  output file name [stdout]</span><br><span class="line">         -R FILE  list of read groups to be outputted [null]</span><br><span class="line">         -f INT   required flag, 0 for unset [0]</span><br><span class="line">         -F INT   filtering flag, 0 for unset [0] </span><br><span class="line">                  Skip alignments with bits present in INT [0]</span><br><span class="line">                  数字4代表该序列没有比对到参考序列上</span><br><span class="line">                  数字8代表该序列的mate序列没有比对到参考序列上</span><br><span class="line">         -q INT   minimum mapping quality [0]</span><br><span class="line">         -l STR   only output reads in library STR [null]</span><br><span class="line">         -r STR   only output reads in read group STR [null]</span><br><span class="line">         -s FLOAT fraction of templates to subsample; integer part as seed [-1]</span><br><span class="line">         -?       longer help</span><br></pre></td></tr></table></figure><p>例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将sam文件转换成bam文件</span><br><span class="line">$ samtools view -bS abc.sam &gt; abc.bam</span><br><span class="line">$ samtools view -b -S abc.sam -o abc.bam</span><br><span class="line"></span><br><span class="line">提取比对到参考序列上的比对结果</span><br><span class="line">$ samtools view -bF 4 abc.bam &gt; abc.F.bam</span><br><span class="line"></span><br><span class="line">提取paired reads中两条reads都比对到参考序列上的比对结果，只需要把两个4+8的值12作为过滤参数即可</span><br><span class="line">$ samtools view -bF 12 abc.bam &gt; abc.F12.bam</span><br><span class="line"></span><br><span class="line">提取没有比对到参考序列上的比对结果</span><br><span class="line">$ samtools view -bf 4 abc.bam &gt; abc.f.bam</span><br><span class="line"></span><br><span class="line">提取bam文件中比对到caffold1上的比对结果，并保存到sam文件格式</span><br><span class="line">$ samtools view abc.bam scaffold1 &gt; scaffold1.sam</span><br><span class="line"></span><br><span class="line">提取scaffold1上能比对到30k到100k区域的比对结果</span><br><span class="line">$ samtools view abc.bam scaffold1:30000-100000 $gt; scaffold1_30k-100k.sam</span><br><span class="line"></span><br><span class="line">根据fasta文件，将 header 加入到 sam 或 bam 文件中</span><br><span class="line">$ samtools view -T genome.fasta -h scaffold1.sam &gt; scaffold1.h.sam</span><br></pre></td></tr></table></figure></p><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>sort对bam文件进行排序。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: samtools sort [-n] [-m &lt;maxMem&gt;] &lt;in.bam&gt; &lt;out.prefix&gt;  </span><br><span class="line">-m 参数默认下是 500,000,000 即500M（不支持K，M，G等缩写）。对于处理大数据时，如果内存够用，则设置大点的值，以节约时间。</span><br><span class="line">-n 设定排序方式按short reads的ID排序。默认下是按序列在fasta文件中的顺序（即header）和序列从左往右的位点排序。</span><br></pre></td></tr></table></figure></p><p>例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ samtools sort abc.bam abc.sort</span><br><span class="line">$ samtools view abc.sort.bam | less -S</span><br></pre></td></tr></table></figure></p><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>将2个或2个以上的已经sort了的bam文件融合成一个bam文件。融合后的文件不需要则是已经sort过了的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage:   samtools merge [-nr] [-h inh.sam] &lt;out.bam&gt; &lt;in1.bam&gt; &lt;in2.bam&gt;[...]</span><br><span class="line"></span><br><span class="line">Options: -n       sort by read names</span><br><span class="line">         -r       attach RG tag (inferred from file names)</span><br><span class="line">         -u       uncompressed BAM output</span><br><span class="line">         -f       overwrite the output BAM if exist</span><br><span class="line">         -1       compress level 1</span><br><span class="line">         -R STR   merge file in the specified region STR [all]</span><br><span class="line">         -h FILE  copy the header in FILE to &lt;out.bam&gt; [in1.bam]</span><br><span class="line"></span><br><span class="line">Note: Samtools&apos; merge does not reconstruct the @RG dictionary in the header. Users</span><br><span class="line">      must provide the correct header with -h, or uses Picard which properly maintains</span><br><span class="line">      the header dictionary in merging.</span><br></pre></td></tr></table></figure><h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><p>必须对bam文件进行默认情况下的排序后，才能进行index。否则会报错。</p><p>建立索引后将产生后缀为.bai的文件，用于快速的随机处理。很多情况下需要有bai文件的存在，特别是显示序列比对情况下。比如samtool的tview命令就需要；gbrowse2显示reads的比对图形的时候也需要。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: samtools index &lt;in.bam&gt; [out.index]</span><br></pre></td></tr></table></figure></p><p>例子：<br>以下两种命令结果一样<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ samtools index abc.sort.bam</span><br><span class="line">$ samtools index abc.sort.bam abc.sort.bam.bai</span><br></pre></td></tr></table></figure></p><h2 id="faidx"><a href="#faidx" class="headerlink" title="faidx"></a>faidx</h2><p>对fasta文件建立索引,生成的索引文件以.fai后缀结尾。该命令也能依据索引文件快速提取fasta文件中的某一条（子）序列</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Usage: samtools faidx &lt;in.bam&gt; [ [...]]</span><br><span class="line"></span><br><span class="line">对基因组文件建立索引</span><br><span class="line">$ samtools faidx genome.fasta</span><br><span class="line">生成了索引文件genome.fasta.fai,是一个文本文件，分成了5列。第一列是子序列的名称；</span><br><span class="line">第二列是子序列的长度；个人认为“第三列是序列所在的位置”，因为该数字从上往下逐渐变大，</span><br><span class="line">最后的数字是genome.fasta文件的大小；第4和5列不知是啥意思。于是通过此文件，可以定位子序列在fasta文件在磁盘上的存放位置，直接快速调出子序列。</span><br><span class="line"></span><br><span class="line">由于有索引文件，可以使用以下命令很快从基因组中提取到fasta格式的子序列</span><br><span class="line">$ samtools faidx genome.fasta scffold_10 &gt; scaffold_10.fasta</span><br></pre></td></tr></table></figure><h2 id="tview"><a href="#tview" class="headerlink" title="tview"></a>tview</h2><p>tview能直观的显示出reads比对基因组的情况，和基因组浏览器有点类似。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: samtools tview &lt;aln.bam&gt; [ref.fasta]</span><br><span class="line"></span><br><span class="line">当给出参考基因组的时候，会在第一排显示参考基因组的序列，否则，第一排全用N表示。</span><br><span class="line">按下 g ，则提示输入要到达基因组的某一个位点。例子“scaffold_10:1000&quot;表示到达第10号scaffold的第1000个碱基位点处。</span><br><span class="line">使用H(左）J（上）K（下）L（右）移动显示界面。大写字母移动快，小写字母移动慢。</span><br><span class="line">使用空格建向左快速移动（和 L 类似），使用Backspace键向左快速移动（和 H 类似）。</span><br><span class="line">Ctrl+H 向左移动1kb碱基距离； Ctrl+L 向右移动1kb碱基距离</span><br><span class="line">可以用颜色标注比对质量，碱基质量，核苷酸等。30～40的碱基质量或比对质量使用白色表示；</span><br><span class="line">20～30黄色；10～20绿色；0～10蓝色。</span><br><span class="line">使用点号&apos;.&apos;切换显示碱基和点号；使用r切换显示read name等</span><br><span class="line">还有很多其它的使用说明，具体按 ？ 键来查看。</span><br></pre></td></tr></table></figure><h2 id="flagstat"><a href="#flagstat" class="headerlink" title="flagstat"></a>flagstat</h2><p>给出BAM文件的比对结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: samtools flagstat &lt;in.bam&gt;</span><br><span class="line"></span><br><span class="line">$ samtools flagstat example.bam</span><br><span class="line">11945742 + 0 in total (QC-passed reads + QC-failed reads)</span><br><span class="line">总共的reads数</span><br><span class="line">0 + 0 duplicates</span><br><span class="line">7536364 + 0 mapped (63.09%:-nan%)</span><br><span class="line">总体上reads的匹配率</span><br><span class="line">11945742 + 0 paired in sequencing</span><br><span class="line">有多少reads是属于paired reads</span><br><span class="line">5972871 + 0 read1</span><br><span class="line">reads1中的reads数</span><br><span class="line">5972871 + 0 read2</span><br><span class="line">reads2中的reads数</span><br><span class="line">6412042 + 0 properly paired (53.68%:-nan%)</span><br><span class="line">完美匹配的reads数：比对到同一条参考序列，并且两条reads之间的距离符合设置的阈值</span><br><span class="line">6899708 + 0 with itself and mate mapped</span><br><span class="line">paired reads中两条都比对到参考序列上的reads数</span><br><span class="line">636656 + 0 singletons (5.33%:-nan%)</span><br><span class="line">单独一条匹配到参考序列上的reads数，和上一个相加，则是总的匹配上的reads数。</span><br><span class="line">469868 + 0 with mate mapped to a different chr</span><br><span class="line">paired reads中两条分别比对到两条不同的参考序列的reads数</span><br><span class="line">243047 + 0 with mate mapped to a different chr (mapQ&gt;=5)</span><br><span class="line">同上一个，只是其中比对质量&gt;=5的reads的数量</span><br></pre></td></tr></table></figure></p><h2 id="depth"><a href="#depth" class="headerlink" title="depth"></a>depth</h2><p>得到每个碱基位点的测序深度,并输出到标准输出。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: bam2depth [-r reg] [-q baseQthres] [-Q mapQthres] [-b in.bed] &lt;in1.bam&gt; [...]</span><br></pre></td></tr></table></figure></p><h2 id="其它有用的命令"><a href="#其它有用的命令" class="headerlink" title="其它有用的命令"></a>其它有用的命令</h2><p>reheader 替换bam文件的头<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ samtools reheader &lt;in.header.sam&gt; &lt;in.bam&gt;</span><br></pre></td></tr></table></figure></p><p>cat 连接多个bam文件，适用于非sorted的bam文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ samtools cat [-h header.sam] [-o out.bam] &lt;in1.bam&gt; &lt;in2.bam&gt; [ ... ]</span><br></pre></td></tr></table></figure></p><p>idxstats 统计一个表格，4列，分别为”序列名，序列长度，比对上的reads数，unmapped reads number”。第4列应该是paired reads中有一端能匹配到该scaffold上，而另外一端不匹配到任何scaffolds上的reads数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ samtools idxstats &lt;aln.bam&gt;</span><br></pre></td></tr></table></figure></p><h2 id="将bam文件转换为fastq文件"><a href="#将bam文件转换为fastq文件" class="headerlink" title="将bam文件转换为fastq文件"></a>将bam文件转换为fastq文件</h2><p>有时候，我们需要提取出比对到一段参考序列的reads，进行小范围的分析，以利于debug等。这时需要将bam或sam文件转换为fastq格式。<br>该网站提供了一个bam转换为fastq的程序：<a href="http://www.hudsonalpha.org/gsl/information/software/bam2fastq" target="_blank" rel="noopener">http://www.hudsonalpha.org/gsl/information/software/bam2fastq</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wget http://www.hudsonalpha.org/gsl/static/software/bam2fastq-1.1.0.tgz</span><br><span class="line">$ tar zxf bam2fastq-1.1.0.tgz</span><br><span class="line">$ cd bam2fastq-1.1.0</span><br><span class="line">$ make</span><br><span class="line">$ ./bam2fastq &lt;in.bam&gt;</span><br></pre></td></tr></table></figure><h2 id="mpileup"><a href="#mpileup" class="headerlink" title="mpileup"></a>mpileup</h2><p>samtools还有个非常重要的命令mpileup，以前为pileup。该命令用于生成bcf文件，再使用bcftools进行SNP和Indel的分析。bcftools是samtool中附带的软件，在samtools的安装文件夹中可以找到。</p><p>最常用的参数有2： <code>-f</code> 来输入有索引文件的fasta参考序列； <code>-g</code> 输出到bcf格式。用法和最简单的例子如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: samtools mpileup [-EBug] [-C capQcoef] [-r reg] [-f in.fa] [-l list] [-M capMapQ] [-Q minBaseQ] [-q minMapQ] in.bam [in2.bam [...]]</span><br><span class="line"></span><br><span class="line">$ samtools mpileup -f genome.fasta abc.bam &gt; abc.txt</span><br><span class="line">$ samtools mpileup -gSDf genome.fasta abc.bam &gt; abc.bcf</span><br><span class="line">$ samtools mpileup -guSDf genome.fasta abc.bam | \</span><br><span class="line">           bcftools view -cvNg - &gt; abc.vcf</span><br></pre></td></tr></table></figure><p>mpileup不使用<code>-u</code>或<code>-g</code>参数时，则不生成二进制的bcf文件，而生成一个文本文件(输出到标准输出)。该文本文件统计了参考序列中每个碱基位点的比对情况；该文件每一行代表了参考序列中某一个碱基位点的比对结果。比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scaffold_1      2841    A       11      ,,,...,....     BHIGDGIJ?FF</span><br><span class="line">scaffold_1      2842    C       12      ,$,,...,....^I. CFGEGEGGCFF+</span><br><span class="line">scaffold_1      2843    G       11      ,,...,.....     FDDDDCD?DD+</span><br><span class="line">scaffold_1      2844    G       11      ,,...,.....     FA?AAAA&lt;AA+</span><br><span class="line">scaffold_1      2845    G       11      ,,...,.....     F656666166*</span><br><span class="line">scaffold_1      2846    A       11      ,,...,.....     (1.1111)11*</span><br><span class="line">scaffold_1      2847    A       11      ,,+9acggtgaag.+9ACGGTGAAT.+9ACGGTGAAG.+9ACGGTGAAG,+9acggtgaag.+9ACGGTGAAG.+9ACGGTGAAG.+9ACGGTGAAG.+9ACGGTGAAG.+9ACGGTGAAG       %.+....-..)</span><br><span class="line">scaffold_1      2848    N       11      agGGGgGGGGG     !!$!!!!!!!!</span><br><span class="line">scaffold_1      2849    A       11      c$,...,.....    !0000000000</span><br><span class="line">scaffold_1      2850    A       10      ,...,.....      353333333</span><br></pre></td></tr></table></figure><p>mpileup生成的结果包含6行：参考序列名；位置；参考碱基；比对上的reads数；比对情况；比对上的碱基的质量。其中第5列比较复杂,解释如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  ‘.’代表与参考序列正链匹配。</span><br><span class="line">2  ‘,’代表与参考序列负链匹配。</span><br><span class="line">3  ‘ATCGN’代表在正链上的不匹配。</span><br><span class="line">4  ‘atcgn’代表在负链上的不匹配。</span><br><span class="line">5  ‘*’代表模糊碱基</span><br><span class="line">6  ‘^’代表匹配的碱基是一个read的开始；’^’后面紧跟的ascii码减去33代表比对质量；这两个符号修饰的是后面的碱基，其后紧跟的碱基(.,ATCGatcgNn)代表该read的第一个碱基。</span><br><span class="line">7  ‘$’代表一个read的结束，该符号修饰的是其前面的碱基。</span><br><span class="line">8  正则式’\+[0-9]+[ACGTNacgtn]+’代表在该位点后插入的碱基；比如上例中在scaffold_1的2847后插入了9个长度的碱基acggtgaag。表明此处极可能是indel。</span><br><span class="line">9  正则式’-[0-9]+[ACGTNacgtn]+’代表在该位点后缺失的碱基；</span><br></pre></td></tr></table></figure></p><p><strong>pileup具体的参数如下：</strong></p><p><strong>输入参数</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-6       Assume the quality is in the Illumina 1.3+ encoding. </span><br><span class="line"> -A Do not skip anomalous read pairs in variant calling. </span><br><span class="line">-B       Disable probabilistic realignment for the computation of base alignment quality (BAQ). BAQ is the Phred-scaled probability of a read base being misaligned. Applying this option greatly helps to reduce false SNPs caused by misalignments. </span><br><span class="line">-b FILE  List of input BAM files, one file per line [null]</span><br><span class="line">-C INT   Coefficient for downgrading mapping quality for reads containing excessive mismatches. Given a read with a phred-scaled probability q of being generated from the mapped position, the new mapping quality is about sqrt((INT-q)/INT)*INT. A zero value disables this functionality; if enabled, the recommended value for BWA is 50. [0] </span><br><span class="line">-d INT   At a position, read maximally INT reads per input BAM. [250] </span><br><span class="line">-E       Extended BAQ computation. This option helps sensitivity especially for MNPs, but may hurt specificity a little bit. </span><br><span class="line">-f FILE  The faidx-indexed reference file in the FASTA format. The file can be optionally compressed by razip. [null] </span><br><span class="line">-l FILE  BED or position list file containing a list of regions or sites where pileup or BCF should be generated [null] </span><br><span class="line">-M INT       cap mapping quality at INT [60]</span><br><span class="line">-q INT Minimum mapping quality for an alignment to be used [0] </span><br><span class="line">-Q INT Minimum base quality for a base to be considered [13]</span><br><span class="line">-r STR Only generate pileup in region STR [all sites]</span><br></pre></td></tr></table></figure></p><p><strong>输出参数</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> -D Output per-sample read depth (require -g/-u)</span><br><span class="line"> -g Compute genotype likelihoods and output them in the binary call format (BCF). </span><br><span class="line"> -S Output per-sample Phred-scaled strand bias P-value (require -g/-u) </span><br><span class="line"> -u Similar to -g except that the output is uncompressed BCF, which is preferred for piping. </span><br><span class="line"></span><br><span class="line">Options for Genotype Likelihood Computation (for -g or -u):</span><br><span class="line"> -e INT Phred-scaled gap extension sequencing error probability. Reducing INT leads to longer indels. [20] </span><br><span class="line"> -h INT Coefficient for modeling homopolymer errors. Given an l-long homopolymer run, the sequencing error of an indel of size s is modeled as INT*s/l. [100] </span><br><span class="line"> -I Do not perform INDEL calling </span><br><span class="line"> -L INT Skip INDEL calling if the average per-sample depth is above INT. [250] </span><br><span class="line"> -o INT Phred-scaled gap open sequencing error probability. Reducing INT leads to more indel calls. [40] </span><br><span class="line"> -P STR Comma dilimited list of platforms (determined by @RG-PL) from which indel candidates are obtained. It is recommended to collect indel candidates from sequencing technologies that have low indel error rate such as ILLUMINA. [all]</span><br></pre></td></tr></table></figure></p><h2 id="使用bcftools"><a href="#使用bcftools" class="headerlink" title="使用bcftools"></a>使用bcftools</h2><p>bcftools和samtools类似，用于处理vcf(variant call format)文件和bcf(binary call format)文件。前者为文本文件，后者为其二进制文件。</p><p>bcftools使用简单，最主要的命令是view命令，其次还有index和cat等命令。index和cat命令和samtools中类似。此处主讲使用view命令来进行SNP和Indel calling。该命令的使用方法和例子为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bcftools view [-AbFGNQSucgv] [-D seqDict] [-l listLoci] [-s listSample] </span><br><span class="line">          [-i gapSNPratio] [-t mutRate] [-p varThres] [-P prior] </span><br><span class="line">          [-1 nGroup1] [-d minFrac] [-U nPerm] [-X permThres] </span><br><span class="line">          [-T trioType] in.bcf [region]</span><br><span class="line"></span><br><span class="line">$ bcftools view -cvNg abc.bcf &gt; snp_indel.vcf</span><br></pre></td></tr></table></figure></p><p>生成的结果文件为vcf格式，有10列，分别是：</p><blockquote><p>1 参考序列名；<br>2 varianti所在的left-most位置；<br>3 variant的ID（默认未设置，用’.’表示)；<br>4 参考序列的allele；<br>5 variant的allele(有多个alleles，则用’,’分隔);<br>6 variant/reference QUALity;<br>7 FILTers applied;<br>8 variant的信息，使用分号隔开；<br>9 FORMAT of the genotype fields, separated by colon (optional)；<br>10 SAMPLE genotypes and per-sample information (optional)。</p></blockquote><p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scaffold_1      2847    .       A       AACGGTGAAG      194     .       INDEL;DP=11;VDB=0.0401;AF1=1;AC1=2;DP4=0,0,8,3;MQ=35;FQ=-67.5   GT:PL:GQ        1/1:235,33,0:63</span><br><span class="line">scaffold_1      3908    .       G       A       111     .       DP=13;VDB=0.0085;AF1=1;AC1=2;DP4=0,0,5,7;MQ=42;FQ=-63   GT:PL:GQ        1/1:144,36,0:69</span><br><span class="line">scaffold_1      4500    .       A       G       31.5    .       DP=8;VDB=0.0034;AF1=1;AC1=2;DP4=0,0,1,3;MQ=42;FQ=-39    GT:PL:GQ        1/1:64,12,0:21</span><br><span class="line">scaffold_1      4581    .       TGGNGG  TGG     145     .       INDEL;DP=8;VDB=0.0308;AF1=1;AC1=2;DP4=0,0,0,8;MQ=42;FQ=-58.5    GT:PL:GQ        1/1:186,24,0:45</span><br><span class="line">scaffold_1      4644    .       G       A       195     .       DP=21;VDB=0.0198;AF1=1;AC1=2;DP4=0,0,10,10;MQ=42;FQ=-87 GT:PL:GQ        1/1:228,60,0:99</span><br><span class="line">scaffold_1      4827    .       NACAAAGA        NA      4.42    .       INDEL;DP=1;AF1=1;AC1=2;DP4=0,0,1,0;MQ=40;FQ=-37.5       GT:PL:GQ        0/1:40,3,0:3</span><br><span class="line">scaffold_1      4854    .       A       G       48      .       DP=6;VDB=0.0085;AF1=1;AC1=2;DP4=0,0,2,1;MQ=41;FQ=-36    GT:PL:GQ        1/1:80,9,0:16</span><br><span class="line">scaffold_1      5120    .       A       G       85      .       DP=8;VDB=0.0355;AF1=1;AC1=2;DP4=0,0,5,3;MQ=42;FQ=-51    GT:PL:GQ        1/1:118,24,0:45</span><br></pre></td></tr></table></figure></p><p>第8列中显示了对variants的信息描述，比较重要，其中的 Tag 的描述如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TagFormatDescription</span><br><span class="line">AF1doubleMax-likelihood estimate of the site allele frequency (AF) of the first ALT allele</span><br><span class="line">DPintRaw read depth (without quality filtering)</span><br><span class="line">DP4int[4]  high-quality reference forward bases, ref reverse, alternate for and alt rev bases</span><br><span class="line">FQintConsensus quality. Positive: sample genotypes different; negative: otherwise</span><br><span class="line">MQintRoot-Mean-Square mapping quality of covering reads</span><br><span class="line">PC2int[2]Phred probability of AF in group1 samples being larger (,smaller) than in group2</span><br><span class="line">PCHI2doublePosterior weighted chi^2 P-value between group1 and group2 samples</span><br><span class="line">PV4double[4]P-value for strand bias, baseQ bias, mapQ bias and tail distance bias</span><br><span class="line">QCHI2intPhred-scaled PCHI2</span><br><span class="line">RPint  permutations yielding a smaller PCHI2</span><br><span class="line">CLRintPhred log ratio of genotype likelihoods with and without the trio/pair constraint</span><br><span class="line">UGTstringMost probable genotype configuration without the trio constraint</span><br><span class="line">CGTstringMost probable configuration with the trio constraint</span><br></pre></td></tr></table></figure></p><p>bcftools view 的具体参数如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input/Output Options:</span><br><span class="line">-A Retain all possible alternate alleles at variant sites. By default, the view command discards unlikely alleles.</span><br><span class="line">-b Output in the BCF format. The default is VCF.</span><br><span class="line">-D FILE Sequence dictionary (list of chromosome names) for VCF-&gt;BCF conversion [null]</span><br><span class="line">-F Indicate PL is generated by r921 or before (ordering is different).</span><br><span class="line">-G Suppress all individual genotype information.</span><br><span class="line">-l FILE List of sites at which information are outputted [all sites]</span><br><span class="line">-N Skip sites where the REF field is not A/C/G/T</span><br><span class="line">-Q Output the QCALL likelihood format</span><br><span class="line">-s FILE List of samples to use. The first column in the input gives the sample names and the second gives the ploidy, which can only be 1 or 2. When the 2nd column is absent, the sample ploidy is assumed to be 2. In the output, the ordering of samples will be identical to the one in FILE. [null]</span><br><span class="line">-S The input is VCF instead of BCF.</span><br><span class="line">-u Uncompressed BCF output (force -b). </span><br><span class="line"></span><br><span class="line">Consensus/Variant Calling Options:</span><br><span class="line">-c Call variants using Bayesian inference. This option automatically invokes option -e.</span><br><span class="line">-d FLOAT When -v is in use, skip loci where the fraction of samples covered by reads is below FLOAT. [0]</span><br><span class="line">        当有多个sample用于variants calling时，比如多个转录组数据或多个重测序</span><br><span class="line">        数据需要比对到参考基因组上，设置该值，表明至少有该&lt;float 0~1&gt;比例的</span><br><span class="line">        samples在该位点都有覆盖才计算入variant.所以对于只有一个sample的情况</span><br><span class="line">        下，该值设置在0～1之间没有意义，大于1则得不到任何结果。</span><br><span class="line">-e Perform max-likelihood inference only, including estimating the site allele frequency, testing Hardy-Weinberg equlibrium and testing associations with LRT.</span><br><span class="line">-g Call per-sample genotypes at variant sites (force -c)</span><br><span class="line">-i FLOAT Ratio of INDEL-to-SNP mutation rate [0.15]</span><br><span class="line">-p FLOAT A site is considered to be a variant if P(ref|D)</span><br><span class="line">-t FLOAT Scaled muttion rate for variant calling [0.001]</span><br><span class="line">-T STR Enable pair/trio calling. For trio calling, option -s is usually needed to be applied to configure the trio members and their ordering. In the file supplied to the option -s, the first sample must be the child, the second the father and the third the mother. The valid values of STR are ‘pair’, ‘trioauto’, ‘trioxd’ and ‘trioxs’, where ‘pair’ calls differences between two input samples, and ‘trioxd’ (‘trioxs’) specifies that the input is from the X chromosome non-PAR regions and the child is a female (male). [null]</span><br><span class="line">-v Output variant sites only (force -c) </span><br><span class="line"></span><br><span class="line">Contrast Calling and Association Test Options:</span><br><span class="line">-1 INT Number of group-1 samples. This option is used for dividing the samples into two groups for contrast SNP calling or association test. When this option is in use, the following VCF INFO will be outputted: PC2, PCHI2 and QCHI2. [0]</span><br><span class="line">-U INT Number of permutations for association test (effective only with -1) [0]</span><br><span class="line">-X FLOAT Only perform permutations for P(chi^2)</span><br></pre></td></tr></table></figure></p><p>使用bcftools得到variant calling结果后。需要对结果再次进行过滤。主要依据比对结果中第8列信息。其中的 DP4 一行尤为重要，提供了4个数据：1 比对结果和正链一致的reads数、2 比对结果和负链一致的reads数、3 比对结果在正链的variant上的reads数、4 比对结果在负链的variant上的reads数。可以设定 （value3 + value4）大于某一阈值，才算是variant。比如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ perl -ne &apos;print $_ if /DP4=(\d+),(\d+),(\d+),(\d+)/ &amp;&amp; ($3+$4)&gt;=10 &amp;&amp; ($3+$4)/($1+$2+$3+$4)&gt;=0.8&apos; snp_indel.vcf &gt; snp_indel.final.vcf</span><br></pre></td></tr></table></figure></p><h2 id="rmdup"><a href="#rmdup" class="headerlink" title="rmdup"></a>rmdup</h2><p>NGS上机测序前需要进行PCR一步，使一个模板扩增出一簇，从而在上机测序的时候表现出为1个点，即一个reads。若一个模板扩增出了多簇，结果得到了多个reads，这些reads的坐标(coordinates)是相近的。在进行了reads比对后需要将这些由PCR duplicates获得的reads去掉，并只保留最高比对质量的read。使用rmdup命令即可完成.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage:  samtools rmdup [-sS]  </span><br><span class="line"> -s 对single-end reads。默认情况下，只对paired-end reads</span><br><span class="line"> -S 将Paired-end reads作为single-end reads处理。</span><br><span class="line"></span><br><span class="line">$ samtools input.sorted.bam output.bam</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 生信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生信理论基础 </tag>
            
            <tag> samtools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言读写文件</title>
      <link href="/2018/04/01/c-yu-yan-du-xie-wen-jian/"/>
      <url>/2018/04/01/c-yu-yan-du-xie-wen-jian/</url>
      
        <content type="html"><![CDATA[<p><strong>使用标准I/O处理文件</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;// exit()原型</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int ch;</span><br><span class="line">FILE *fp;  // 文件指针</span><br><span class="line">unsigned long count = 0;</span><br><span class="line">if (argc != 2)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Usage: %s filename\n&quot;,argv[0]);</span><br><span class="line">exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">if ((fp = fopen(argv[1],&quot;r&quot;)) == NULL)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Can&apos;t open %s\n&quot;,argv[1]);</span><br><span class="line">exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">while ((ch = getc(fp)) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">putc(ch, stdout); // putchar(ch)相同</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);</span><br><span class="line">printf(&quot;File %s hash %lu characters\n&quot;, argv[1],count);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//输入/输出升级版，将一个文件附加到另一个文件的末尾</span><br><span class="line">//未测试</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define BUFSIZE 4096</span><br><span class="line">#define SLEN 81</span><br><span class="line"></span><br><span class="line">void append(FILE *source,FILE *dest);  //函数原型,没有返回值，参数为两个文件指针</span><br><span class="line">char *s_gets(char *st,int n);</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">FILE *fa, *fs;</span><br><span class="line">int file = 0;</span><br><span class="line">char file_app[SLEN];</span><br><span class="line">char file_src[SLEN];</span><br><span class="line">int ch;</span><br><span class="line"></span><br><span class="line">puts(&quot;Enter name of destination file:&quot;);</span><br><span class="line">s_gets(file_app,SLEN);</span><br><span class="line">if ((fa = fopen(file_app,&quot;a+&quot;) = NULL)</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;Can&apos;t opne %s\n&quot;, file_app);</span><br><span class="line">exit(EXIT_FAILURE);//程序结束失败</span><br><span class="line">&#125;</span><br><span class="line">if(setvbuf(fa,NULL,_IOFBF,BUFSIZE) !=0) // 完全缓冲。若无法缓冲，就返回0</span><br><span class="line">&#123;</span><br><span class="line">fputs(&quot;Can&apos;t creat output buffer\n&quot;,stderr);</span><br><span class="line">exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">puts(&quot;Enter name of first source file (empty line to quit):&quot;);</span><br><span class="line">while(s_gets(file_src,SLEN) &amp;&amp; file_src[0] != &apos;\0&apos;)</span><br><span class="line">&#123;</span><br><span class="line">if (strcmp(file_src,file_app)==0)</span><br><span class="line">fputs(&quot;Can&apos;t append file to itself\n&quot;,stderr);</span><br><span class="line">else if ((fs = fopen(file_src,&quot;r&quot;)) == NULL)</span><br><span class="line">fprintf(stderr, &quot;Can&apos;t open %s\n&quot;,file_src);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line"> if (setvbuf(fs, NULL,_IOFBF,BUFSIZE) != 0)</span><br><span class="line"> &#123;</span><br><span class="line">fputs(&quot;Can&apos;t creat input buffer\n&quot;,stderr);</span><br><span class="line">continue;</span><br><span class="line"> &#125;</span><br><span class="line"> append(fs,fa);</span><br><span class="line"> if (ferror(fs) != 0)</span><br><span class="line"> fprintf(stderr,&quot;Error in reading file %s.\n&quot;,file_src);</span><br><span class="line"> if (ferror(fa) != 0)</span><br><span class="line"> fprintf(stderr,&quot;Error in writing file %s.\n&quot;,file_app);</span><br><span class="line"> fclose(fs);</span><br><span class="line"> files++;</span><br><span class="line"> puts(&quot;Next file (empty line to quit):&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;Done appending. %d files appending.\n&quot;, files );</span><br><span class="line">rewind(fa);</span><br><span class="line">printf(&quot;%s continue:\n&quot;, file_app);</span><br><span class="line">while  ((ch = gets(fa) != EOF)</span><br><span class="line">putchar(ch);</span><br><span class="line">puts(&quot;Done displaying.&quot;);</span><br><span class="line">fclose(fa);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void append(FILE *source, FILE *dest)</span><br><span class="line">&#123;</span><br><span class="line">size_t bytes;</span><br><span class="line">static char temp[BUFSIZE];</span><br><span class="line"></span><br><span class="line">while((bytes = fread(temp,sizeof(char),BUFSIZE,source)) &gt; 0)//二进制形式处理数据</span><br><span class="line">fwrite(temp,sizeof(char),bytes, dest);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char *s_gets(char *st, int n)</span><br><span class="line">&#123;</span><br><span class="line">char *ret_val;</span><br><span class="line">char *find;</span><br><span class="line"></span><br><span class="line">ret_val = fgets(st,n, stdin);// fgets(类型,长度,文件指针)</span><br><span class="line">if(ret_val)</span><br><span class="line">&#123;</span><br><span class="line">find = strchr(st,&apos;\n&apos;);//查找换行符</span><br><span class="line">if(find)</span><br><span class="line"></span><br><span class="line">*find = &apos;\0&apos;;</span><br><span class="line">else</span><br><span class="line">while(getchar() != &apos;\n&apos;)</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">return ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>沈向洋：You Are What You Write</title>
      <link href="/2018/03/03/you-are-what-you-write/"/>
      <url>/2018/03/03/you-are-what-you-write/</url>
      
        <content type="html"><![CDATA[<h2 id="You-Are-What-You-Write"><a href="#You-Are-What-You-Write" class="headerlink" title="You Are What You Write"></a>You Are What You Write</h2><p><em>原文：<a href="https://www.linkedin.com/pulse/you-what-write-harry-shum?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">https://www.linkedin.com/pulse/you-what-write-harry-shum?from=timeline&amp;isappinstalled=0</a></em></p><p>Are Twitter, PowerPoint, Facebook, Instagram and texting eroding our ability to think?</p><p>There is a Chinese proverb that says “见文如见人,” which literally means “reading the document is the same as seeing the author.” If we are what we write, then who have we, as a society, become?</p><p>I was sitting in a technical review recently, listening to one of our reviewers grill the engineer who was presenting: Why did you choose that design? Why is the service showing bad results? How many users will switch to the solution?</p><p>The presenter’s answers lacked depth. It seemed like he hadn’t done enough rigorous thinking, the kind where you sit quietly, sift through research, contemplate options, determine what you know, don’t know and where more work is required. The kind of thinking I did as a young researcher when peers took me and my work apart when I took short cuts. Back then, I practiced a disciplined approach, spending hours just thinking, and even more hours on the hardest part—writing it down.</p><p>Today, long-form writing is being replaced. Tweets pass for dialogue. PowerPoint condenses thoughts to bullets. Words have been traded for emojis and GIFs. And we’ve become addicted to the noise. What happens in an Internet minute? 16 million text messages. 1.8 million snaps. 452,000 Tweets. 156 million emails. Who has time to think, let alone write?</p><p>And maybe we, in the technology industry, have shaped this reality. We created the phones, apps and 24/7-connected world. We’ve enabled society to put down the pen. The only writing I do today is email or quick WeChat posts.</p><p>So now I worry that we’re losing a valuable tool that helps us to think deeply, express who we are at our greatest and expand the intellect of those around us. And for us in the technical community, this is especially troubling. The stakes are higher than ever before with AI. We’re under enormous pressure to ship quickly, to achieve more, faster, but we can’t do this at the expense of the highest engineering quality. We have to think carefully about consequences and alternatives. Who gets blamed when a self-driving car hits someone? The engineer who wrote the code is the driver. Who is accountable for the AI algorithm with bias? The engineer who created the AI.</p><p>I see fewer engineers writing and sharing deep thinking, but this is what will lead to far more true innovation across the industry. How will we achieve the big transformative breakthroughs versus the incremental milestones?</p><p>By writing. Because the way to think is actually to write.</p><p>Putting pen to paper forces you to develop and refine your thinking by iterating, revising and exploring alternatives. Anyone who can think deeply can write beautiful code, inspiring papers or develop the plan to bring the next big thing to life. I encourage you to read Reid Hoffman’s Series B pitch for LinkedIn in which he shares the thinking that helped him succeed. At the time, he shares that a partner in a venture firm was exposed to around 5,000 pitches, looked more closely at 600 to 800, and did between 0 and 2 deals.</p><p>Writing offers the possibility to create lasting artifacts. I think of papers I published that endure, albeit perhaps as reference materials. Plenoptic Sampling. Lazy Snapping. Poisson Matting. These are my work’s contribution to the field of computer vision and graphics. They will survive me and, if I’m lucky, even help shape a mind or two.</p><p>One of my favorite professors at Carnegie Mellon, Takeo Kanade, said that you have to write research papers like detective novels. You need story, suspense, surprise and ‘aha’ to explain your ideas to peers, to inspire others to contribute and advance your work and the whole field.</p><p>Writing is an equalizer to get the best from the whole team. At Amazon, presentations are done with the six-page paper. Meetings kick off with everyone reading followed by comments and questions to the author. Everyone operates from the same context, and introverts, extroverts and non-native speakers have an equal chance to get their thinking across. It’s not about the presenter’s personality, but the words.</p><p>Ultimately, writing helps make you successful. You might be the smartest person with the best idea, but if you can’t communicate your thinking in a compelling way, you won’t get far. Two engineers in our AI+R team who inspire me with their regular writing habits are Bill Ramsey and Ronny Kohavi. Bill has written over 250 blog posts at Microsoft, benefitting our entire technical community. With Ronny, you don’t even need to meet him—his highly cited A/B test experimentation papers say it all, and he’s publishing for the benefit of the industry on LinkedIn.</p><p>As you’re reading this, you may be logging your objections: I need to drive results, so I need to go straight to code. I’m known for my code, so I don’t need to write papers. I’m not a native speaker, and I speak better with my code. I don’t know what to write about. I don’t have time… But please set them aside—for your own success, for your company’s, for the industry’s advancement—and start writing.</p><p>I see so many occasions for building long-form writing back into the engineering culture—planning documents, project proposals, technology LRP’s, review articles—to inspire us to work together, collectively creating and cultivating big ideas and big thinking.</p><p>I took a first step recently, writing a research paper with my colleagues Xiaodong He and Di Li, From Eliza to XiaoIce: Challenges and Opportunities with Social Chatbots, for the first time in years, so please no judgment, only constructive feedback!</p><p>I challenge everyone reading this piece to write 500 words per week. If you’ve got an idea or you see a problem, write your proposal and share it!</p><p>Let’s rewrite our standards for thought leadership and engineering quality by writing more!</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWK简明教程</title>
      <link href="/2018/02/16/awk-jian-ming-jiao-cheng/"/>
      <url>/2018/02/16/awk-jian-ming-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h5 id="awk命令格式和选项"><a href="#awk命令格式和选项" class="headerlink" title="awk命令格式和选项"></a>awk命令格式和选项</h5><p>语法形式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk [options] &apos;script&apos; var=value file(s)</span><br><span class="line">awk [options] -f scriptfile var=value file(s)</span><br></pre></td></tr></table></figure></p><p>常用命令选项</p><ul><li>-F fs   fs指定输入分隔符，fs可以是字符串或正则表达式，如-F:</li><li>-v var=value   赋值一个用户定义变量，将外部变量传递给awk</li><li>-f scripfile  从脚本文件中读取awk命令</li><li>-m[fr] val   对val值设置内在限制，-mf选项限制分配给val的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</li></ul><p><strong>工作原理</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hawk &apos;BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;&apos;</span><br></pre></td></tr></table></figure></p><h5 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h5><div class="table-container"><table><thead><tr><th>变量</th><th>详细说明</th></tr></thead><tbody><tr><td>$0</td><td>当前记录（这个变量中存放着整个行的内容）</td></tr><tr><td>$1~$n</td><td>当前记录的第n个字段，字段间由FS分隔</td></tr><tr><td>FS</td><td>输入字段分隔符 默认是空格或Tab (<strong>也可以是-F</strong>)</td></tr><tr><td>NF</td><td>当前记录中的字段个数，就是有多少列</td></tr><tr><td>NR</td><td>已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中。</td></tr><tr><td>FNR</td><td>当前记录数，与NR不同的是，这个值会是各个文件自己的行号</td></tr><tr><td>RS</td><td>输入的记录分隔符， 默认为换行符</td></tr><tr><td>OFS</td><td>输出字段分隔符， 默认也是空格</td></tr><tr><td>ORS</td><td>输出的记录分隔符，默认为换行符</td></tr><tr><td>FILENAME</td><td>当前输入文件的名字</td></tr></tbody></table></div><h5 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;$6 ~ /FIN|TIME/ || NR==1 &#123;print NR,$4,$5,$6&#125;&apos; OFS=&quot;\t&quot; netstat.txt</span><br></pre></td></tr></table></figure><h5 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h5><p>下面的命令计算所有的C文件，CPP文件和H文件的文件大小总和。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -l  *.cpp *.c *.h | awk &apos;&#123;sum+=$5&#125; END &#123;print sum&#125;&apos;</span><br><span class="line">2511401</span><br></pre></td></tr></table></figure></p><p>统计每个用户的进程的占了多少内存<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ps aux | awk &apos;NR!=1&#123;a[$1]+=$6;&#125; END &#123; for(i in a) print i &quot;, &quot; a[i]&quot;KB&quot;;&#125;&apos;</span><br><span class="line">dbus, 540KB</span><br><span class="line">mysql, 99928KB</span><br><span class="line">www, 3264924KB</span><br><span class="line">root, 63644KB</span><br><span class="line">hchen, 6020KB</span><br></pre></td></tr></table></figure></p><p><strong>++控制结构和脚本语言待补充==++</strong></p><p><strong>参考链接：</strong></p><p><a href="http://man.linuxde.net/awk" target="_blank" rel="noopener">http://man.linuxde.net/awk</a><br><a href="https://coolshell.cn/articles/9070.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9070.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> Linux </tag>
            
            <tag> AWK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>突变注释格式说明</title>
      <link href="/2018/02/15/zhu-shi-ge-shi-shuo-ming/"/>
      <url>/2018/02/15/zhu-shi-ge-shi-shuo-ming/</url>
      
        <content type="html"><![CDATA[<p><img src="/myphoto/bdvj80uudkbj.png" alt="image"></p><div class="table-container"><table><thead><tr><th>核酸变化</th><th style="text-align:center">氨基酸改变</th><th style="text-align:center">详细说明</th></tr></thead><tbody><tr><td>c.1915A&gt;G(exon16)</td><td style="text-align:center">p.N639D</td><td style="text-align:center">非同义突变，第639氨基酸蛋白位置上，氨基酸N突变为氨基酸D</td></tr><tr><td>c.112C&gt;T(exon1)</td><td style="text-align:center">p.R38X,70</td><td style="text-align:center">非同义突变，提前终止，第20氨基酸蛋白位置上，氨基酸C突变为终止密码子（用X表示），且相对原来缩短170个氨基酸</td></tr><tr><td>c.3052T&gt;C(exon20)</td><td style="text-align:center">p.X1018Q,11</td><td style="text-align:center">非同义突变，延长终止，第1018氨基酸蛋白位置为终止密码子（用X表示），突变为Q，且相对原来预测延长11个氨基酸，如果用“？”则表示无法计算延长长度</td></tr><tr><td>c.67(exon1)_c.69(exon1)delCTG</td><td style="text-align:center">p.L23del</td><td style="text-align:center">非框移突变，第23氨基酸蛋白位置缺失</td></tr><tr><td>c.3364(exon33)_c.3372(exon33)delGGCCCCCCA</td><td style="text-align:center">p.G1122_P1124del</td><td style="text-align:center">非框移突变，第1122位(G)至1124位(P)氨基酸缺失</td></tr><tr><td>c.3675(exon2)_c.3676(exon2)insAGC</td><td style="text-align:center">p.S1225_E1226insS</td><td style="text-align:center">非框移突变，第1225（S）至1226（E）位氨基酸蛋白发生之间插入氨基酸S</td></tr><tr><td>c.311(exon2)_c.313(exon2)delCCC</td><td style="text-align:center">p.T104_L105delinsM</td><td style="text-align:center">非框移突变，第104（T）至105（L）位氨基酸突变为氨基酸M，也可理解为：第104位至第105位置的氨基酸替换为M</td></tr><tr><td>c.1072(exon10)_c.1073(exon10)insAGGGACTGGGCGGGGCCATGGTCT</td><td style="text-align:center">p.W358delinsX,76</td><td style="text-align:center">非框移突变，导致第358位氨基酸蛋白W突变为终止密码子(用X表示)，且相对原来长度缩短76个氨基酸</td></tr><tr><td>c.417(exon3)delA</td><td style="text-align:center">p.X139Wfs*8</td><td style="text-align:center">框移突变，延长终止，导致终止密码子（第139位，用X表示）突变为氨基酸W，且相对原长度预测延长8个氨基酸（或从第139位氨基酸开始住数后第8个终止），如果用“？”则表示无法计算延长长度，即在3’UTR上找不到终止密码子</td></tr><tr><td>c.191(exon4)delA</td><td style="text-align:center">p.Y64Lfs*30</td><td style="text-align:center">框移突变，导致其编码的蛋白从第64位氨基酸开始算起，再翻译29个氨基酸（包含第64位）后终止，且这29个氨基酸是移码的，序列和原来的序列不同</td></tr></tbody></table></div><ul><li>c.-20T&gt;G(exon1)：基因5’utr上距离起始密码子的第-20位碱基T突变为G，位于第1外显子 </li><li>c.1A&gt;G(exon1)：基因编码区第1位碱基A突变为G，位于第1外显子 </li><li>c.21T&gt;A(exon1)：基因编码区第21位碱基T突变为A，位于第1外显子 </li><li>c.21+2T&gt;A(IVS1)：基因的第1个内含子第2位碱基G突变为A，距离第1外显子边界（c.21）2bp的位置 </li><li>c.61-2G&gt;A(IVS2)：基因的第2个内含子上距离第3外显子边界（c.61）2bp的位置 </li><li>c.*22G&gt;A(exon4)：基因3’utr上距离终止密码子的第22位碱基G突变为A，位于第4外显子</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生信理论基础 </tag>
            
            <tag> 文件格式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(转载)二代数据质控及Trimmomatic的使用</title>
      <link href="/2018/02/14/er-dai-shu-ju-zhi-kong-ji-trimmomatic-de-shi-yong/"/>
      <url>/2018/02/14/er-dai-shu-ju-zhi-kong-ji-trimmomatic-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h3 id="数据质控的意义"><a href="#数据质控的意义" class="headerlink" title="数据质控的意义"></a>数据质控的意义</h3><p>现在的NGS测序，以illumina为首基本都是运用边合成边测序的技术。碱基的合成依靠的是化学反应，这使得碱基链可以不断地从5’端一直往3’端合成并延伸下去。但在这个合成的过程中随着合成链的增长，DNA聚合酶的效率会不断下降，特异性也开始变差，这就会带来一个问题,—越到后面碱基合成的错误率就会越高，这也是为何当前NGS测序读长普遍偏短的一个原因。</p><p><strong>注</strong>: 有时候测序仪在刚开始进行合成反应的时候也会由于反应还不够稳定，同样会带来质量值的波动，不过这个波动一般都在高质量值区域（如下图）。<br><img src="/myphoto/1.png" alt="image"></p><p>一般我们可以从如下几个方面来分析：</p><ul><li>read各个位置的碱基质量值分布</li><li>碱基的总体质量值分布</li><li>read各个位置上碱基分布比例，目的是为了分析碱基的分离程度</li><li>GC含量分布</li><li>read各位置的N含量</li><li>read是否还包含测序的接头序列</li><li>read重复率，这个是实验的扩增过程所引入的</li></ul><p>下面以软件FastQC质控结果为例，进行详细说明</p><p>在做read质量值分析的时候，FastQC并不单独查看具体某一条read中碱基的质量值，而是将Fastq文件中所有的read数据都综合起来一起分析。下图是一个测序质量非常好的read各位置碱基质量分布图（如下图）。</p><p><img src="/myphoto/2.png" alt="image"></p><p>这个图的横轴是read上碱基的位置，纵轴是碱基质量值。在这个例子中，read的长度是126bp（来自HiSeq X10的测序结果），这应该算是比较长的二代测序序列了。我们可以看到read上的每一个位置都有一个黄色的箱型图表示在该位置上所有碱基的质量分布情况。除了最后一个碱基之外，其他的碱基质量值都基本都在大于30，而且波动很小，说明质量很稳定，这其实是一个非常高质量的结果。而且我们可以看到图中质量值的分布都在绿色背景（代表高质量）的区域。</p><p>那如果是质量很差的结果看起来会是怎么样的呢？我手边一时找不到这样的数据，就在网上找到了一个代替品，样子如下</p><p><img src="/myphoto/3.png" alt="image"></p><p>在这个图中我们可以明显看到，read各个位置上的碱基质量分布波动都比较大，特别从第18个碱基往后全部出现了大幅度的波动，而且很多read的碱基质量值都掉到非常低（红色）的区域中了，说明这个数据的测序结果真的非常差，有着大量不及格的read。最好的情况是重新测序，但如果不得不使用这个数据，就要把这些低质量的数据全都去除掉才行，同时还需留意是否还存在其他的问题，但不管如何都一定会丢掉很大一部分的数据。</p><p>除了上面read各位置的碱基质量值分布之外，FastQC还会为我们计算其他几个非常有价值的统计结果，包括：</p><p>1）碱基总体质量值分布，只要大部分都高于20，那么就比较正常。</p><p><img src="/myphoto/4.png" alt="image"></p><p>一般来说，对于二代测序，<strong>最好是达到Q20的碱基要在95%以上（最差不低于90%），Q30要求大于85%（最差也不要低于80%）。</strong></p><p>2）read各个位置上碱基比例分布</p><p><img src="/myphoto/5.png" alt="image"></p><p>这个是为了分析碱基的分离程度。何为碱基分离？我们知道AT配对，CG配对，假如测序过程是比较随机的话（随机意味着好），那么在每个位置上A和T比例应该差不多，C和G的比例也应该差不多，如上图所示，两者之间即使有偏差也不应该太大，最好平均在1%以内，如果过高，除非有合理的原因，比如某些特定的捕获测序所致，否则都需要注意是不是测序过程有什么偏差。</p><p>3）GC含量分布图</p><p><img src="/myphoto/6.png" alt="image"></p><p>GC含量指的是G和C这两种碱基占总碱基的比例。二代测序平台或多或少都存在一定的测序偏向性，我们可以通过查看这个值来协助判断测序过程是否足够随机。对于人类来说，我们基因组的GC含量一般在40%左右。因此，如果发现GC含量的图谱明显偏离这个值那么说明测序过程存在较高的序列偏向性，结果就是基因组中某些特定区域被反复测序的几率高于平均水平，除了覆盖度会有偏离之后，将会影响下游的变异检测和CNV分析。</p><p>4）N含量分布图</p><p><img src="/myphoto/7.png" alt="image"></p><p>N在测序数据中一般是不应该出现的，如果出现则意味着，测序的光学信号无法被清晰分辨，如果这种情况多的话，往往意味着测序系统或者测序试剂的错误。</p><p>5）接头序列</p><p><img src="/myphoto/8.png" alt="image"></p><p>在测序之前需要构建测序文库，测序接头就是在这个时候加上的，其目的一方面是为了能够结合到flowcell上，另一方面是当有多个样本同时测序的时候能够利用接头信息进行区分。当测序read的长度大于被测序的DNA片段时，就会在read的末尾测到这些接头序列（如下图）。一般的WGS测序是不会测到这些接头序列的，因为构建WGS测序的文库序列（插入片段）都比较长，约几百bp，而read的测序长度都在100bp-150bp这个范围。不过在进行一些RNA测序的时候，由于它们的序列本来就比较短，很多只有几十bp长（特别是miRNA），那么就很容易会出现read测通的现象，这个时候就会在read的末尾测到这些接头序列。</p><p><img src="/myphoto/9.png" alt="image"></p><p>最后，这些被测到的接头序列和低质量碱基一样都是需要在正式分析之前进行切除的read片段。</p><h3 id="Trimmomatic的使用"><a href="#Trimmomatic的使用" class="headerlink" title="Trimmomatic的使用"></a>Trimmomatic的使用</h3><h4 id="Trimmomatic-介绍"><a href="#Trimmomatic-介绍" class="headerlink" title="Trimmomatic 介绍"></a>Trimmomatic 介绍</h4><p>Trimmomatic 发表的文章至今已被引用了 2810 次，是一个广受欢迎的 Illumina 平台数据过滤工具。其他平台的数据例如 Iron torrent ，PGM 测序数据可以用 fastx_toolkit 、NGSQC toolkit 来过滤。</p><p>Trimmomatic 支持多线程，处理数据速度快，主要用来去除 Illumina 平台的 Fastq 序列中的接头，并根据碱基质量值对 Fastq 进行修剪。软件有两种过滤模式，分别对应 SE 和 PE 测序数据，同时支持 gzip 和 bzip2 压缩文件。</p><p>另外也支持 phred-33 和 phred-64 格式互相转化，现在之所以会出现 phred-33 和 phred-64 格式的困惑，都是 Illumina 公司的锅（damn you, Illumina!），不过现在绝大部分 Illumina 平台的产出数据也都转为使用 phred-33 格式了。</p><h4 id="Trimmomatic-过滤步骤"><a href="#Trimmomatic-过滤步骤" class="headerlink" title="Trimmomatic 过滤步骤"></a>Trimmomatic 过滤步骤</h4><p><strong>Trimmomatic 过滤数据的步骤与命令行中过滤参数的顺序有关</strong>，通常的过滤步骤如下：</p><ol><li>ILLUMINACLIP: 过滤 reads 中的 Illumina 测序接头和引物序列，并决定是否去除反向互补的 R1/R2 中的 R2。</li><li>SLIDINGWINDOW: 从 reads 的 5’ 端开始，进行滑窗质量过滤，切掉碱基质量平均值低于阈值的滑窗。<br>MAXINFO: 一个自动调整的过滤选项，在保证 reads 长度的情况下尽量降低测序错误率，最大化 reads 的使用价值。</li><li>LEADING: 从 reads 的开头切除质量值低于阈值的碱基。</li><li>TRAILING: 从 reads 的末尾开始切除质量值低于阈值的碱基。</li><li>CROP: 从 reads 的末尾切掉部分碱基使得 reads 达到指定长度。</li><li>HEADCROP: 从 reads 的开头切掉指定数量的碱基。</li><li>MINLEN: 如果经过剪切后 reads 的长度低于阈值则丢弃这条 reads。</li><li>AVGQUAL: 如果 reads 的平均碱基质量值低于阈值则丢弃这条 reads。</li><li>TOPHRED33: 将 reads 的碱基质量值体系转为 phred-33。</li><li>TOPHRED64: 将 reads 的碱基质量值体系转为 phred-64。</li></ol><h4 id="Trimmomatic-简单用法"><a href="#Trimmomatic-简单用法" class="headerlink" title="Trimmomatic 简单用法"></a>Trimmomatic 简单用法</h4><p>由于 Trimmomatic 过滤数据的步骤与命令行中过滤参数的顺序有关，因此，如果需要去接头，建议第一步就去接头，否则接头序列被其他的过滤参数剪切掉部分之后就更难匹配更难去除干净了。</p><h5 id="单末端测序模式"><a href="#单末端测序模式" class="headerlink" title="单末端测序模式"></a>单末端测序模式</h5><p>在 SE 模式下，只有一个输入文件和一个过滤之后的输出文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar &lt;path to trimmomatic jar&gt; SE [-threads &lt;threads&gt;] [-phred33 | -phred64] [-trimlog</span><br><span class="line">&lt;logFile&gt;] &lt;input&gt; &lt;output&gt; &lt;step 1&gt; &lt;step 2&gt; ...</span><br></pre></td></tr></table></figure></p><p><code>-trimlog</code> 参数指定了过滤日志文件名，日志中包含以下四列内容:</p><ul><li>read ID</li><li>过滤之后剩余序列长度</li><li>过滤之后的序列起始碱基位置（序列开头处被切掉了多少个碱基）</li><li>过滤之后的序列末端碱基位置</li><li>序列末端处被剪切掉的碱基数</li></ul><p>由于生成的 trimlog 文件中包含了每一条 reads 的处理记录，因此文件体积巨大（GB 级别），如果后面不会用到 trim 日志，建议不要使用这个参数。 </p><h5 id="双末端测序模式"><a href="#双末端测序模式" class="headerlink" title="双末端测序模式"></a>双末端测序模式</h5><p>在 PE 模式下，有两个输入文件，正向测序序列和反向测序序列，但是过滤之后输出文件有四个，过滤之后双端序列都保留的就是 paired，反之如果其中一端序列过滤之后被丢弃了另一端序列保留下来了就是 unpaired 。</p><p><img src="/myphoto/10.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar &lt;path to trimmomatic.jar&gt; PE [-threads &lt;threads] [-phred33 | -phred64] [-trimlog</span><br><span class="line">&lt;logFile&gt;] &gt;] [-basein &lt;inputBase&gt; | &lt;input 1&gt; &lt;input 2&gt;] [-baseout &lt;outputBase&gt; |</span><br><span class="line">&lt;paired output 1&gt; &lt;unpaired output 1&gt; &lt;paired output 2&gt; &lt;unpaired output 2&gt; &lt;step 1&gt; &lt;step 2&gt; ...</span><br></pre></td></tr></table></figure><p>其中 -phred33 和 -phred64 参数指定 fastq 的质量值编码格式，如果不设置这个参数，软件会自动判断输入文件是哪种格式（v0.32 之后的版本都支持），虽然软件默认的参数是 phred64，如果不确定序列是哪种质量编码格式，可以不设置这个参数。</p><h5 id="输入输出文件"><a href="#输入输出文件" class="headerlink" title="输入输出文件"></a>输入输出文件</h5><p>PE 模式的两个输入文件：<code>sample_R1.fastq</code> <code>sample_R2.fastq</code>以及四个输出文件：<code>sample_paired_R1.clean.fastq</code> <code>sample_unpaired_R1.clean.fastq</code> <code>sample_paired_R1.clean.fastq</code> <code>sample_unpaired_R1.clean.fastq</code></p><p>通常 PE 测序的两个文件，R1 和 R2 的文件名是类似的，因此可以使用 <code>-basein</code> 参数指定其中 R1 文件名即可，软件会推测出 R2 的文件名，但是这个功能实测并不好用，因为软件只能自动识别推测三种种格式的 <code>-basein</code>:</p><ul><li>Sample_Name_R1_001.fq.gz -&gt; Sample_Name_R2_001.fq.gz</li><li>Sample_Name.f.fastq -&gt; Sample_Name.r.fastq</li><li>Sample_Name.1.sequence.txt -&gt; Sample_Name.2.sequence.txt</li></ul><p>建议不用 <code>-basein</code> 参数，直接指定两个文件名（R1 和 R2）作为输入。</p><p>输出文件有四个，当然也可以像上文一样指定四个文件名，但是参数太长有点麻烦，有个省心的方法，使用 <code>-baseout</code> 参数指定输出文件的 <code>basename</code>，软件会自动为四个输出文件命名。例如 <code>-baseout mySampleFiltered.fq.gz</code> ，文件名中添加 <code>.gz</code> 后缀，软件会自动将输出结果进行 <code>gzip</code> 压缩。输出的四个文件分别会自动命名为：</p><ul><li>mySampleFiltered_1P.fq.gz - for paired forward reads</li><li>mySampleFiltered_1U.fq.gz - for unpaired forward reads</li><li>mySampleFiltered_2P.fq.gz - for paired reverse reads</li><li>mySampleFiltered_2U.fq.gz - for unpaired reverse reads</li></ul><p>此外，如果直接指定输入输出文件名，文件名后添加 <code>.gz</code> 后缀就是告诉软件输入文件是 <code>.gz</code> 压缩文件，输出文件需要用 gzip 压缩。</p><h5 id="常用参数说明"><a href="#常用参数说明" class="headerlink" title="常用参数说明"></a>常用参数说明</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PE/SE</span><br><span class="line">    设定对Paired-End或Single-End的reads进行处理，其输入和输出参数稍有不一样。</span><br><span class="line">-threads</span><br><span class="line">    设置多线程运行数</span><br><span class="line">-phred33</span><br><span class="line">    设置碱基的质量格式，可选pred64</span><br><span class="line">ILLUMINACLIP:TruSeq3-PE.fa:2:30:10</span><br><span class="line">    切除adapter序列。参数后面分别接adapter序列的fasta文件：允许的最大mismatch</span><br><span class="line">数：palindrome模式下匹配碱基数阈值：simple模式下的匹配碱基数阈值。</span><br><span class="line">LEADING:3</span><br><span class="line">    切除首端碱基质量小于3的碱基</span><br><span class="line">TRAILING:3</span><br><span class="line">    切除尾端碱基质量小于3的碱基</span><br><span class="line">SLIDINGWINDOW:4:15</span><br><span class="line">    从5&apos;端开始进行滑动，当滑动位点周围一段序列(window)的平均碱基低于阈值，则从该处进行切除。Windows的size是4个碱基，其平均碱基</span><br><span class="line">质量小于15，则切除。</span><br><span class="line">MINLEN:50</span><br><span class="line">    最小的reads长度</span><br><span class="line">CROP:&lt;length&gt;</span><br><span class="line">    保留reads到指定的长度</span><br><span class="line">HEADCROP:&lt;length&gt;</span><br><span class="line">    在reads的首端切除指定的长度</span><br><span class="line">TOPHRED33</span><br><span class="line">    将碱基质量转换为pred33格式</span><br><span class="line">TOPHRED64</span><br><span class="line">    将碱基质量转换为pred64格式</span><br></pre></td></tr></table></figure><h5 id="过滤原理"><a href="#过滤原理" class="headerlink" title="过滤原理"></a>过滤原理</h5><p>每一步的过滤如果需要多个参数，通常用冒号:将各个参数隔开，当然参数的先后顺序是有要求的。</p><h6 id="ILUMINACLIP"><a href="#ILUMINACLIP" class="headerlink" title="ILUMINACLIP"></a>ILUMINACLIP</h6><p>从名字可以看出，这一步是为了去除 illumina 接头的，这个软件其实就是专为 illumina 平台数据而设计的。</p><p>为了更好理解测序 reads 中为什么会有引物和接头序列，我画了一个文库加上接头之后的结构示意图，也把引物结合部位大概标了出来：</p><p><img src="/myphoto/11.png" alt="image"></p><p>这个文库结构示意图理解之后就容易理解测序过程了。</p><p>去除接头以及引物序列看似简单，但需要权衡灵敏度（保证接头和引物去除干净）和特异性（保证不是接头和引物的序列不被误切除），由于测序中可能存在的随机错误让去接头这样一个简单的操作变的复杂。</p><p>虽然理论上接头序列和引物序列可能出现在 reads 中的任何位置，但实际上序列中出现接头和引物大部分情况下都是由于文库插入片段比测序读长短导致的，这种情况在 reads 的开头部分是有一段可用序列的，末端包含了接头的全长或部分序列，如果末端只有接头的一部分序列，那么去除这残缺的接头序列也不是容易的事。</p><p>然而，在 PE 测序模式下如果文库的插入片段比测序读长短，那么 read1 和 read2 中非接头序列的那部分会完全反向互补，Trimmomatic 有一个 ‘palindrome’ 模式会利用这个特点进行接头序列的去除。</p><p>下图中 A、B、C、D 四种情况就是 Trimmomatic 去除接头和引物的四种模式：</p><ul><li>红色条形：被切除的序列</li><li>绿色条形：保留下来的有效读长 </li><li>深蓝色条形：接头序列</li><li>浅蓝色条形：引物序列</li></ul><p><img src="/myphoto/12.png" alt="image"></p><p><strong>A 模式</strong>：测序 reads 从起始位置开始就包含了完整的接头序列，那么根据 Illumina 测序原理，这整条 reads 都不可能包含有用序列了，整条 reads 被丢弃。</p><p><strong>B 模式</strong>：这种相对常见，由于文库插入片段比测序读长短，会在 reads 末端包含部分接头序列，若是这部分接头序列足够长是可以识别并去除的，但如果接头序列太短，比接头匹配参数设置的最短长度还短，那么就无法去除。但是，如果是 PE 测序，可以按照 D 模式去除 reads 末端的很短的接头序列。</p><p><strong>C 模式</strong>：PE 测序可能出现这种情况，正向测序和反向测序有部分完全反向互补，但是空载的文库，两个接头直接互连，这样的 reads 不包含任何有用序列，正反向测序 reads 都被丢弃。</p><p><strong>D 模式</strong>：是 Trimmomatic 利用 PE 测序进行短接头序列去除的典范，如果文库插入片段比测序读长短，利用正反向测序 reads 中一段碱基可以完全反向互补的特点，将两个接头序列与 reads 进行比对，同时两条 reads 之间也互相比对，可以将 3’ 末端哪怕只有 1bp 的接头序列都可以被准确去除，相对 B 模式去除接头污染更彻底。</p><p>Trimmomatic 使用了一种类似序列比对软件（例如 Isaac aligner，一个超快速的 alignment 软件）的两步策略来搜索潜在的接头序列。首先，使用接头序列中的一段种子序列（seed 长度不超过 16bp）与测序 reads 进行比对，如果种子序列在测序 reads 中有足够好的比对结果（具体由 seedMismatch 参数决定），就启动第二步的接头全长与 reads 比对。第一步的 seed 搜索速度很快，可以过滤掉没有接头污染的 reads ，这种两步搜索的方法使得接头序列的查找效率很高。</p><p>在第二步的接头序列和测序 reads 全长比对统计比对分值时，罚分策略考虑了测序碱基的质量值Q，每一个比对上的碱基加分 0.6，每一个错配的碱基减分 Q/10，考虑碱基质量值可以降低低质量碱基（高测序错误率）错配对整个比对得分的影响。在这个规则下，一段 12bp 的接头序列完全比对到 reads 上得分为 7.2, 25bp 的接头序列完全比对到 reads 上得分为 15。因此在 ILLUMINACLIP 参数中 simple clip threshold 的值建议为 7-15 之间（即上图中 A/B 比对模式比对得分阈值）。</p><p>对于 palindromic 模式的比对（上图中 D 模式），可以比对上的序列长度会更长，为了保证识别接头序列的准确率，比对得分的阈值也更高，例如 reads的 R1 和 R2 中有 50bp 序列可以反向互补匹配，得分为 30。这种模式下，Trimmomatic 可以识别并去除 reads 中非常短的接头序列。</p><p><strong>ILLUMINACLIP 参数说明</strong>：按照规定顺序，ILLUMINACLIP 的参数列表如下（各个参数之间以冒号分开），PE 测序需要注意最后一个参数。对于 SE 测序最后两个参数可以不设置。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ILLUMINACLIP:&lt;fastaWithAdaptersEtc&gt;:&lt;seed mismatches&gt;:&lt;palindrome clip threshold&gt;:&lt;simple clip threshold&gt;:&lt;minAdapterLength&gt;:&lt;keepBothReads&gt;</span><br><span class="line"></span><br><span class="line">ILLUMINACLIP:TruSeq3-SE:2:30:10 #接头和引物序列在 TruSeq3-SE 中，第一步 seed 搜索允许2个碱基错配，palindrome 比对分值阈值 30，simple clip 比对分值阈值 10，palindrome 模式允许切除的最短接头序列为 8bp（默认值），palindrome 模式去除与 R1 完全反向互补的 R2（默认去除）</span><br></pre></td></tr></table></figure><p><code>fastaWithAdaptersEtc</code>：指定包含接头和引物序列（所有被视为污染的序列）的 fasta 文件路径，Trimmomatic 自带了一个包含 Illumina 平台接头和引物序列的 fasta 文件，可以直接用这个。</p><p><code>seedMismatches</code>：指定第一步 seed 搜索时允许的错配碱基个数，例如 2。</p><p><code>palindrome clip threshold</code>：指定针对 PE 的 palindrome clip 模式下，需要 R1 和 R2 之间至少多少比对分值（上图中 D 模式），才会进行接头切除，例如 30。</p><p><code>simple clip threshold</code>：指定切除接头序列的最低比对分值（上图 A/B 模式），通常 7-15 之间。</p><p><code>minAdapterLength</code>：只对 PE 测序的 palindrome clip 模式有效，指定 palindrome 模式下可以切除的接头序列最短长度，由于历史的原因，默认值是 8，但实际上 palindrome 模式可以切除短至 1bp 的接头污染，所以可以设置为 1 。</p><p><code>keepBothReads</code>：只对 PE 测序的 palindrome clip 模式有效，这个参数很重要，在上图中 D 模式下， R1 和 R2 在去除了接头序列之后剩余的部分是完全反向互补的，默认参数 false，意味着整条去除与 R1 完全反向互补的 R2，当做重复去除掉，但在有些情况下，例如需要用到 paired reads 的 bowtie2 流程，就要将这个参数改为 true，否则会损失一部分 paired reads。</p><p>看一个 PE150 数据的测试，就知道 <code>keepBothReads</code> 参数的重要性了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ java -jar trimmomatic-0.36.jar PE -phred33 F-2-test_R1.fastq.gz F-2-test_R2.fastq.gz -baseout F-2.fastq.gz ILLUMINACLIP:TruSeq3-PE.fa:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:51</span><br><span class="line"></span><br><span class="line">ILLUMINACLIP: Using 1 prefix pairs, 0 forward/reverse sequences, 0 forward only sequences, 0 reverse only sequences</span><br><span class="line">Input Read Pairs: 2500 Both Surviving: 1633 (65.32%) Forward Only Surviving: 828 (33.12%) Reverse Only Surviving: 12 (0.48%) Dropped: 27 (1.08%)</span><br><span class="line">TrimmomaticPE: Completed successfully</span><br><span class="line"># 使用 ILLUMINACLIP 默认的第六个参数 false，只有 65.32% paired reads 保留下来</span><br><span class="line"></span><br><span class="line">$ java -jar trimmomatic-0.36.jar PE -phred33 F-2-test_R1.fastq.gz F-2-test_R2.fastq.gz -baseout F-2.fastq.gz ILLUMINACLIP:TruSeq3-PE.fa:2:30:10:8:true LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:51</span><br><span class="line"></span><br><span class="line">ILLUMINACLIP: Using 1 prefix pairs, 0 forward/reverse sequences, 0 forward only sequences, 0 reverse only sequences</span><br><span class="line">Input Read Pairs: 2500 Both Surviving: 2439 (97.56%) Forward Only Surviving: 22 (0.88%) Reverse Only Surviving: 16 (0.64%) Dropped: 23 (0.92%)</span><br><span class="line">TrimmomaticPE: Completed successfully</span><br><span class="line"># 将 ILLUMINACLIP 第六个参数改为 true，其余所有参数均相同，结果有 97.56% paired reads 保留下来</span><br></pre></td></tr></table></figure><h6 id="SLIDINGWINDOW"><a href="#SLIDINGWINDOW" class="headerlink" title="SLIDINGWINDOW"></a>SLIDINGWINDOW</h6><p>滑窗剪切，统计滑窗口中所有碱基的平均质量值，如果低于设定的阈值，则切掉窗口。<br>SLIDINGWINDOW 参数如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SLIDINGWINDOW:&lt;windowSize&gt;:&lt;requiredQuality&gt;</span><br><span class="line"></span><br><span class="line">SLIDINGWINDOW:4:15  #设置 4bp 窗口，碱基平均质量值阈值 15</span><br></pre></td></tr></table></figure><p><code>widowSize</code>:设置窗口大小<br><code>requiredQuality</code>：设置窗口碱基平均质量阈值</p><h6 id="MAXINFO"><a href="#MAXINFO" class="headerlink" title="MAXINFO"></a>MAXINFO</h6><p>包含一个可以自动调整的过滤条件，在保留尽可能长的序列和保持序列中碱基测序错误率尽可能低之间进行平衡，以达到 trim 之后保留序列的价值最大化。</p><p>对于不同的应用场景，一条 reads 序列的价值由以下三个因素决定：</p><ol><li>允许的最短 read 长度：只有在测序 reads 足够长的情况下，才能将 reads map 到参考序列的唯一位置上。过短的序列往往能 map 到参考基因组上的多个位置（特异性差），这种非特异性的 map 结果可以给出的有价值信息很少（对后续分析没什么用）。保证 reads 可以 map 到参考序列的唯一位置上需要的 reads 最短长度也与参考序列本身的长度和序列复杂度有关，但是通常最短 reads 要求不低于 40bp。</li><li>需求的额外 reads 长度：在保证 reads 可以 map 到参考序列上的唯一位置的情况下， reads 序列越长，可能对后续分析越有利。当然，这也需要看应用场景，对于 RNA-seq 来说只需要统计某个位置 map 上的 reads 数目，这种情况下 reads 长度只要满足唯一比对要求即可。而对于 de-novo 序列组装或者 Resequencing 检测变异，reads 序列长度越长越好，reads 越长可以为后续分析提供越多的有效证据。</li><li>对测序错误的敏感性：即测序错误率对后续分析工作是否造成严重影响，有的应用中对 reads 测序错误零容忍，就需要非常严格的过滤条件，而有的应用对测序错误不敏感，就可以使用宽松的过滤条件。</li></ol><p>MAXINFO 有两个参数，第一个 <code>target read length</code> 控制上面的因素一，即允许的最短 read 长度。第二个参数 <code>strictness</code> 是控制因素二和因素三之间的平衡，即满足最短 read 长度的情况下，是保留尽可能多的碱基，还是保证尽可能低的测序错误率。</p><p>MAXINFO 过滤从 reads 3’ 端开始进行剪切，在考虑上述三个因素的情况下统计所有可能的 trim 方式的到的 clean reads 的 INFO 分值（即所谓的 reads 价值），这三个因素分别以不同的方式影响最终的 reads INFO 分值：</p><ol><li>最短 read 长度：最终保留的 reads 长度与 INFO 分值之间是 logistic 函数关系，即 INFO 分值与 reads 长度之间是 S 形增长曲线（类似大肠杆菌生长曲线），大概相当于，当保留下来的 reads 长度小于最短长度时，INFO 分值随着 reads 长度增加呈指数级增长，当保留下来的 reads 长度达到最短 read 长度要求之后，INFO 分值的增长会变缓。</li><li>超出最短 read 长度的部分：INFO 分值会随着额外的 reads 长度增加了线性增长，线性系数与 MAXINFO 的第二个参数有关，为 1 - strictness。</li><li>测序错误敏感性：最终保留下来的所有碱基的质量值都被用来计算 reads 包含测序错误的概率，出现测序错误的概率提升会降低 INFO 分值，错误概率对 INFO 分值的影响权重与 strictness 相关。</li></ol><p>针对一条 read 的任何可能的剪切方式都计算出 INFO 分值，最终的 reads 长度和切除的碱基由 INFO 最大值决定。实际上这三个影响因子作用的方式不同：</p><ol><li>当 reads 长度比最短 read 长度还短时 INFO 分值被序列长度主导，因为太短的 reads 根本无法提供足够的有用信息。</li><li>当 reads 长度满足最短 read 长度要求时，reads 的长度因素就不再是影响 INFO 分值的主导因素了，而且一旦 reads 长度足够长时，由于 logistic 函数的关系，reads 长度就不怎么贡献 INFO 分值了。</li><li>超出最短 read 长度要求的碱基对 INFO 贡献有限，而另一方面，由于碱基的增加导致 reads 中出现测序错误的概率增大，这会导致对 INFO 的罚分。控制这超出最短 read 长度的序列对 INFO 分值的影响到底是罚分还是得分，就看 strictness 参数了。</li><li>对于大部分足够长的 reads，保留超出最低要求的碱基序列是利还是弊，会依照碱基质量值分布和 strictness 参数来决定如何 trim。</li></ol><p>参数说明：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MAXINFO:&lt;targetLength&gt;:&lt;strictness&gt;</span><br></pre></td></tr></table></figure></p><p><code>targetLength</code>:使得 reads 可以 map 到参考序列上唯一位置的最短长度（likely）。<br><code>strictness</code>：一个介于 0 - 1 之间的小数，决定如何平衡 最大化 reads 长度 或者 最小化 reads 出现错误的概率，当参数设置小于 0.2 时倾向于最大化 reads 长度，当参数设置大于 0.8 时倾向于最小化 reads 中出现测序错误的概率。</p><h6 id="LEADING"><a href="#LEADING" class="headerlink" title="LEADING"></a>LEADING</h6><p>从 reads 的起始端开始切除质量值低于设定的阈值的碱基，直到有一个碱基其质量值达到阈值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LEADING:&lt;quality&gt;</span><br></pre></td></tr></table></figure></p><p><code>quality</code>:设定碱基质量值阈值，低于这个阈值将被切除。</p><h6 id="TRAILING"><a href="#TRAILING" class="headerlink" title="TRAILING"></a>TRAILING</h6><p>从 reads 的末端开始切除质量值低于设定阈值的碱基，直到有一个碱基质量值达到阈值。Illumina 平台有些低质量的碱基质量值被标记为 2 ，所以设置为 3 可以过滤掉这部分低质量碱基。官方推荐使用 Sliding Window 或 MaxInfo 来代替 LEADING 和 TAILING。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TRAILING:&lt;quality&gt;</span><br></pre></td></tr></table></figure></p><p><code>quality</code>:设定碱基质量值阈值，低于这个阈值将被切除。</p><h6 id="CROP"><a href="#CROP" class="headerlink" title="CROP"></a>CROP</h6><p>不管碱基质量，从 reads 的起始开始保留设定长度的碱基，其余全部切除。一刀切，把所有 reads 切成相同的长度。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CROP:&lt;length&gt;</span><br></pre></td></tr></table></figure></p><p><code>length</code>：reads 从末端除之后保留下来的序列长度</p><h6 id="HEADCROP"><a href="#HEADCROP" class="headerlink" title="HEADCROP"></a>HEADCROP</h6><p>不管碱基质量，从 reads 的起始开始直接切除部分碱基。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEADCROP:&lt;length&gt;</span><br></pre></td></tr></table></figure></p><p><code>length</code>：从 reads 的起始开始切除的碱基数</p><h6 id="MINLEN"><a href="#MINLEN" class="headerlink" title="MINLEN"></a>MINLEN</h6><p>设定一个最短 read 长度，当 reads 经过前面的过滤之后，如果保留下来的长度低于这个阈值，整条 reads 被丢弃。被丢弃的 reads 数会被统计在 Trimmomatic 日志的 dropped reads 中。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MINLEN:&lt;length&gt;</span><br></pre></td></tr></table></figure></p><p><code>length</code>：可被保留的最短 read 长度</p><h6 id="TOPHRED33"><a href="#TOPHRED33" class="headerlink" title="TOPHRED33"></a>TOPHRED33</h6><p>此选项可以将过滤之后的 Fastq 文件中质量值这一行转为 phred-33 格式。</p><h6 id="TOPHRED64"><a href="#TOPHRED64" class="headerlink" title="TOPHRED64"></a>TOPHRED64</h6><p>此选项可以将过滤之后的 Fastq 文件中质量值这一行转为 phred-64 格式。</p><h6 id="接头序列和引物序列"><a href="#接头序列和引物序列" class="headerlink" title="接头序列和引物序列"></a>接头序列和引物序列</h6><p>Trimmomatic 也可以自己制作包含接头和引物序列的 fasta 文件，格式可以参考软件自带的 adapters 文件夹中的格式。</p><p>adapters 文件夹中包含 illumina 测序 TruSeq2，TruSeq3 针对 SE 和 PE 的通用接头和引物序列。</p><p><strong>参考链接</strong>：<br><a href="https://www.jianshu.com/p/a8935adebaae" target="_blank" rel="noopener">https://www.jianshu.com/p/a8935adebaae</a><br><a href="https://www.jianshu.com/p/7b5591673255" target="_blank" rel="noopener">https://www.jianshu.com/p/7b5591673255</a><br><a href="http://www.huangshujia.me/2017/08/25/2017-08-25-Begining-WGS-Data-Analysis-Fastq-Data-Quality-Control.html" target="_blank" rel="noopener">http://www.huangshujia.me/2017/08/25/2017-08-25-Begining-WGS-Data-Analysis-Fastq-Data-Quality-Control.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 生信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生信理论基础 </tag>
            
            <tag> 测序数据质控 </tag>
            
            <tag> Trimmomatic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>perl 单行命令</title>
      <link href="/2018/02/13/perl-dan-xing-ming-ling/"/>
      <url>/2018/02/13/perl-dan-xing-ming-ling/</url>
      
        <content type="html"><![CDATA[<p><strong>与One-Liner相关的perl参数</strong></p><ul><li>-a 自动分隔模式，用空格分隔$并保存在@F中，也就是@F=split //, $</li><li>-F 指定-a的分隔符</li><li>-l 对输入的内容进行自动chomp，对输出的内容自动加换行符</li><li>-n 相当于while(&lt;&gt;)</li><li>-e 执行命令，也就是脚本</li><li>-p 自动循环+输出，也就是while(&lt;&gt;){命令（脚本）; print;}</li></ul><p><img src="http://files.jb51.net/file_images/article/201709/2017910200851051.png?201781020923" alt="完整版本"></p><ol><li><p>基本格式：perl -参数 ‘命令’ 输入文件</p></li><li><p><code>perl -e</code>为必须要写的参数</p></li><li><p><code>perl -pe</code> 可用于读取文件每行，并按照给定的命令进行处理，最后输出；如将文件1.txt中的aaa替换为AAA</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -pe &apos;s/aaa/AAA/g&apos; 1.txt</span><br></pre></td></tr></table></figure></li><li><p><code>perl -l</code>参数几乎可以跟n搭配代替perl经常用的<code>while(&lt;&gt;){chomp;}</code>语法</p></li><li><p>如果需要处理tab分割的文件的每一行内容，那么<code>perl -alne</code>参数几乎可以说是必备的，例如:<code>while(&lt;&gt;){chomp;@F=split /\s+/,$_;print &quot;$F[0]\n&quot;}</code>相当于<code>perl -alne &#39;print $F[0]&#39;</code></p></li><li><p>perl单行命令脚本里的变量都不需要预先声明，如想打印出每空行，并且每行以行数开头</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -ne &apos;print ++$a.&quot; $_&quot; if /./&apos;</span><br></pre></td></tr></table></figure></li><li><p>perl单行命令有时优于sed/grep等shell命令是由于其优秀的正则匹配，通常简单的匹配可以如：匹配上的行号，模仿grep -c的功能：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -lne &apos;$a++ if /regex/; END &#123;print $a+0&#125;&apos;</span><br></pre></td></tr></table></figure></li><li><p>perl单行命令可以使用perl的模块，如使用sum函数的模块：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -MList::Util=sum -alne &apos;print sum @F&apos;</span><br></pre></td></tr></table></figure></li><li><p>perl也可以像awk一样使用END命令，如打印出文件中总单词个数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -alne &apos;$t += @F; END &#123; print $t&#125;&apos;</span><br></pre></td></tr></table></figure></li><li><p>perl也可以使用<code>map{}</code>等函数，如打印出匹配上的单词的总个数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -alne &apos;map &#123; /regex/ &amp;&amp; $t++ &#125; @F; END &#123; print $t &#125;&apos;</span><br></pre></td></tr></table></figure></li><li><p>perl单行命令可以说是将perl的简洁用到了极致，如打印出匹配上的行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -ne &apos;/regex/ &amp;&amp; print&apos;</span><br></pre></td></tr></table></figure></li><li><p>perl单行命令能像perl一样灵活的使用则正表达式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -ne &apos;print if /^\d+$/&apos;</span><br></pre></td></tr></table></figure></li></ol><p>以上例子均出自于 <a href="http://www.catonmat.net/blog/perl-one-liners-explained-part-one/" target="_blank" rel="noopener">http://www.catonmat.net/blog/perl-one-liners-explained-part-one/</a></p><p>使用perl来处理数据的我们，会一点Perl one line可以有效的减少编写重复命令的时间，尤其是那些就用1-2次就不会用的脚本，尤其在window系统下不方便使用shell命令的时候。</p><p>PS.当然在windows系统下也可以借用git模拟Unix命令环境</p>]]></content>
      
      
      <categories>
          
          <category> perl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> perl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装python3及模块</title>
      <link href="/2018/02/13/an-zhuang-python3-ji-mo-kuai/"/>
      <url>/2018/02/13/an-zhuang-python3-ji-mo-kuai/</url>
      
        <content type="html"><![CDATA[<h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p><strong>linux下安装python</strong></p><ol><li>官网下载源码压缩包，解压 </li><li>setup.py 里面可以设置sqlite3的搜索路径， 以防止模块安装不上</li><li><p>./configure</p><blockquote><p>安装文件有很多选项</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure -h</span><br><span class="line">`configure&apos; configures python 3.6 to adapt to many kinds of systems.</span><br><span class="line"></span><br><span class="line">Usage: ./configure [OPTION]... [VAR=VALUE]...</span><br><span class="line"></span><br><span class="line">To assign environment variables (e.g., CC, CFLAGS...), specify them as</span><br><span class="line">VAR=VALUE.  See below for descriptions of some of the useful variables.</span><br><span class="line"></span><br><span class="line">Defaults for the options are specified in brackets.</span><br><span class="line"></span><br><span class="line">Configuration:</span><br><span class="line">  -h, --help              display this help and exit</span><br><span class="line">      --help=short        display options specific to this package</span><br><span class="line">      --help=recursive    display the short help of all the included packages</span><br><span class="line">  -V, --version           display version information and exit</span><br><span class="line">  -q, --quiet, --silent   do not print `checking ...&apos; messages</span><br><span class="line">      --cache-file=FILE   cache test results in FILE [disabled]</span><br><span class="line">  -C, --config-cache      alias for `--cache-file=config.cache&apos;</span><br><span class="line">  -n, --no-create         do not create output files</span><br><span class="line">      --srcdir=DIR        find the sources in DIR [configure dir or `..&apos;]</span><br><span class="line"></span><br><span class="line">Installation directories:</span><br><span class="line">  --prefix=PREFIX         install architecture-independent files in PREFIX      ###  安装路径</span><br><span class="line">                          [/usr/local]</span><br><span class="line">  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX</span><br><span class="line">                          [PREFIX]</span><br><span class="line"></span><br><span class="line">By default, `make install&apos; will install all the files in</span><br><span class="line">`/usr/local/bin&apos;, `/usr/local/lib&apos; etc.  You can specify</span><br><span class="line">an installation prefix other than `/usr/local&apos; using `--prefix&apos;,</span><br><span class="line">for instance `--prefix=$HOME&apos;.</span><br><span class="line"></span><br><span class="line">For better control, use the options below.</span><br><span class="line"></span><br><span class="line">Fine tuning of the installation directories:</span><br><span class="line">  --bindir=DIR            user executables [EPREFIX/bin]</span><br><span class="line">  --sbindir=DIR           system admin executables [EPREFIX/sbin]</span><br><span class="line">  --libexecdir=DIR        program executables [EPREFIX/libexec]</span><br><span class="line">  --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]</span><br><span class="line">  --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]</span><br><span class="line">  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]</span><br><span class="line">  --libdir=DIR            object code libraries [EPREFIX/lib]</span><br><span class="line">  --includedir=DIR        C header files [PREFIX/include]</span><br><span class="line">  --oldincludedir=DIR     C header files for non-gcc [/usr/include]</span><br><span class="line">  --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]</span><br><span class="line">  --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]</span><br><span class="line">  --infodir=DIR           info documentation [DATAROOTDIR/info]</span><br><span class="line">  --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]</span><br><span class="line">  --mandir=DIR            man documentation [DATAROOTDIR/man]</span><br><span class="line">  --docdir=DIR            documentation root [DATAROOTDIR/doc/python]</span><br><span class="line">  --htmldir=DIR           html documentation [DOCDIR]</span><br><span class="line">  --dvidir=DIR            dvi documentation [DOCDIR]</span><br><span class="line">  --pdfdir=DIR            pdf documentation [DOCDIR]</span><br><span class="line">  --psdir=DIR             ps documentation [DOCDIR]</span><br><span class="line"></span><br><span class="line">System types:</span><br><span class="line">  --build=BUILD     configure for building on BUILD [guessed]</span><br><span class="line">  --host=HOST       cross-compile to build programs to run on HOST [BUILD]</span><br><span class="line">  --target=TARGET   configure for building compilers for TARGET [HOST]</span><br><span class="line"></span><br><span class="line">Optional Features:</span><br><span class="line">  --disable-option-checking  ignore unrecognized --enable/--with options</span><br><span class="line">  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)</span><br><span class="line">  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]</span><br><span class="line">  --enable-universalsdk[=SDKDIR]</span><br><span class="line">                          Build fat binary against Mac OS X SDK</span><br><span class="line">  --enable-framework[=INSTALLDIR]</span><br><span class="line">                          Build (MacOSX|Darwin) framework</span><br><span class="line">  --enable-shared         disable/enable building shared python library</span><br><span class="line">  --enable-profiling      enable C-level code profiling</span><br><span class="line">  --enable-optimizations  Enable expensive, stable optimizations (PGO, etc).</span><br><span class="line">                          Disabled by default.</span><br><span class="line">  --enable-loadable-sqlite-extensions</span><br><span class="line">                          support loadable extensions in _sqlite module</span><br><span class="line">  --enable-ipv6           Enable ipv6 (with ipv4) support</span><br><span class="line">  --disable-ipv6          Disable ipv6 support</span><br><span class="line">  --enable-big-digits[=BITS]</span><br><span class="line">                          use big digits for Python longs [[BITS=30]]</span><br><span class="line"></span><br><span class="line">Optional Packages:</span><br><span class="line">  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]</span><br><span class="line">  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)</span><br><span class="line">  --with-universal-archs=ARCH</span><br><span class="line">                          select architectures for universal build (&quot;32-bit&quot;,</span><br><span class="line">                          &quot;64-bit&quot;, &quot;3-way&quot;, &quot;intel&quot;, &quot;intel-32&quot;, or &quot;all&quot;)</span><br><span class="line">  --with-framework-name=FRAMEWORK</span><br><span class="line">                          specify an alternate name of the framework built</span><br><span class="line">                          with --enable-framework</span><br><span class="line">  --without-gcc           never use gcc</span><br><span class="line">  --with-icc              build with icc</span><br><span class="line">  --with-cxx-main=&lt;compiler&gt;</span><br><span class="line">                          compile main() and link python executable with C++</span><br><span class="line">                          compiler</span><br><span class="line">  --with-suffix=.exe      set executable suffix</span><br><span class="line">  --with-pydebug          build with Py_DEBUG defined</span><br><span class="line">  --with-assertions       build with C assertions enabled</span><br><span class="line">  --with-lto              Enable Link Time Optimization in PGO builds.</span><br><span class="line">                          Disabled by default.</span><br><span class="line">  --with-hash-algorithm=[fnv|siphash24]</span><br><span class="line">                          select hash algorithm</span><br><span class="line">  --with-address-sanitizer</span><br><span class="line">                          enable AddressSanitizer</span><br><span class="line">  --with-libs=&apos;lib1 ...&apos;  link against additional libs</span><br><span class="line">  --with-system-expat     build pyexpat module using an installed expat</span><br><span class="line">                          library</span><br><span class="line">  --with-system-ffi       build _ctypes module using an installed ffi library</span><br><span class="line">  --with-system-libmpdec  build _decimal module using an installed libmpdec</span><br><span class="line">                          library</span><br><span class="line">  --with-tcltk-includes=&apos;-I...&apos;</span><br><span class="line">                          override search for Tcl and Tk include files</span><br><span class="line">  --with-tcltk-libs=&apos;-L...&apos;</span><br><span class="line">                          override search for Tcl and Tk libs</span><br><span class="line">  --with-dbmliborder=db1:db2:...</span><br><span class="line">                          order to check db backends for dbm. Valid value is a</span><br><span class="line">                          colon separated string with the backend names</span><br><span class="line">                          `ndbm&apos;, `gdbm&apos; and `bdb&apos;.</span><br><span class="line">  --with(out)-threads[=DIRECTORY]</span><br><span class="line">                          disable/enable thread support</span><br><span class="line">  --with(out)-thread[=DIRECTORY]</span><br><span class="line">                          deprecated; use --with(out)-threads</span><br><span class="line">  --with(out)-doc-strings disable/enable documentation strings</span><br><span class="line">  --with(out)-pymalloc    disable/enable specialized mallocs</span><br><span class="line">  --with-valgrind         Enable Valgrind support</span><br><span class="line">  --with(out)-dtrace      disable/enable DTrace support</span><br><span class="line">  --with-fpectl           enable SIGFPE catching</span><br><span class="line">  --with-libm=STRING      math library</span><br><span class="line">  --with-libc=STRING      C library</span><br><span class="line">  --with(out)-computed-gotos</span><br><span class="line">                          Use computed gotos in evaluation loop (enabled by</span><br><span class="line">                          default on supported compilers)</span><br><span class="line">  --with(out)-ensurepip=[=upgrade]</span><br><span class="line">                          &quot;install&quot; or &quot;upgrade&quot; using bundled pip</span><br><span class="line"></span><br><span class="line">Some influential environment variables:</span><br><span class="line">  MACHDEP     name for machine-dependent library files</span><br><span class="line">  CC          C compiler command</span><br><span class="line">  CFLAGS      C compiler flags</span><br><span class="line">  LDFLAGS     linker flags, e.g. -L&lt;lib dir&gt; if you have libraries in a</span><br><span class="line">              nonstandard directory &lt;lib dir&gt;</span><br><span class="line">  LIBS        libraries to pass to the linker, e.g. -l&lt;library&gt;</span><br><span class="line">  CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I&lt;include dir&gt; if</span><br><span class="line">              you have headers in a nonstandard directory &lt;include dir&gt;</span><br><span class="line">  CPP         C preprocessor</span><br><span class="line">  PKG_CONFIG  path to pkg-config utility</span><br><span class="line">  PKG_CONFIG_PATH</span><br><span class="line">              directories to add to pkg-config&apos;s search path</span><br><span class="line">  PKG_CONFIG_LIBDIR</span><br><span class="line">              path overriding pkg-config&apos;s built-in search path</span><br><span class="line"></span><br><span class="line">Use these variables to override the choices made by `configure&apos; or to help</span><br><span class="line">it to find libraries and programs with nonstandard names/locations.</span><br><span class="line"></span><br><span class="line">Report bugs to &lt;https://bugs.python.org/&gt;.</span><br></pre></td></tr></table></figure></blockquote></li><li><p>make &amp;&amp; make install </p></li><li>安装模块 pip3 install modulename</li></ol><p><strong>注意-h 下有响应时间等其他参数 按需设置,每个参数具体意义可自行搜索</strong></p>]]></content>
      
      
      <categories>
          
          <category> python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python3 </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ichorCNA</title>
      <link href="/2018/02/13/ichorcna/"/>
      <url>/2018/02/13/ichorcna/</url>
      
        <content type="html"><![CDATA[<h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><p>ichorCNA是从超低通全基因组测序（ULP-WGS，0.1x覆盖率）估计无细胞DNA中肿瘤分数的工具。</p><p><strong>描述</strong></p><p>ichorCNA使用概率模型，作为隐马尔可夫模型（HMM）实现，以同时分割基因组，预测大规模拷贝数改变，并估计超低通全基因组测序样本（ULP-WGS ）。ichorCNA针对样本的低覆盖率（〜0.1x）测序进行了优化，并使用患者和健康供体cfDNA样本进行了基准测试。</p><p><strong>用途</strong></p><p>ichorCNA可用于通知肿瘤来源DNA的存在或缺失，并指导决定进行整个外显子或更深的全基因组测序。此外，我们可以使用肿瘤分数的定量估计来校准期望的测序深度，以达到用于鉴定无细胞DNA中的突变的统计功效。最后，ichorCNA可以利用超低通量测序的成本效益方法来检测来自大群体的大规模拷贝数变化。</p><p><strong>文献</strong></p><p>Adalsteinsson, Ha, Freeman, et al. Scalable whole-exome sequencing of cell-free DNA reveals high concordance with metastatic tumors</p><h4 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#R控制台中</span><br><span class="line">install.packages(&quot;plyr&quot;)</span><br><span class="line">source(&quot;https://bioconductor.org/biocLite.R&quot;)</span><br><span class="line">biocLite(&quot;HMMcopy&quot;)</span><br><span class="line">biocLite(&quot;GenomeInfoDb&quot;)</span><br><span class="line">install.packages(&quot;devtools&quot;)</span><br><span class="line">library(devtools)</span><br><span class="line">install_github(&quot;broadinstitute/ichorCNA&quot;, &quot;--no-docs&quot;)</span><br><span class="line">#依赖的包有很多，安装过程报错信息可以看出需要依赖的其他包</span><br></pre></td></tr></table></figure><h4 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#以样本DYDFA-842-31为例</span><br><span class="line">$bwa mem -t 4 -B 3 -O 11 -E 4 -k 32 -Y hg19_reference_with_NC.fasta </span><br><span class="line">DYDFA-842-31/DYDFA-842-31_R1.fq.gz DYDFA-842-31_R2.fq.gz &gt; ichorCNA/test31/31.sam</span><br><span class="line"></span><br><span class="line">$samtools view -bS ichorCNA/test31/31.sam &gt; ichorCNA/test31/31.bam</span><br><span class="line"></span><br><span class="line">$samtools sort 31.bam &gt; 31.sort.bam &amp;</span><br><span class="line"></span><br><span class="line">$samtools  index 31.sort.bam &amp;</span><br><span class="line"></span><br><span class="line">$java -jar picard-2.8.2.jar MarkDuplicates I=./31.sort.bam O=./31.rmdup.bam M=rmdup_stat.txt REMOVE_DUPLICATES=true &amp;</span><br><span class="line"></span><br><span class="line">$samtools index 31.rmdup.bam  &amp;</span><br><span class="line"></span><br><span class="line">hmmcopy_utils-master/bin/readCounter --window 1000000 --quality 20 --chromosome chr1,chr2,chr3,chr4,chr5,chr6,chr7,chr8,chr9,chr10,chr11,chr12,chr13,chr14,chr15,chr16,chr17,chr18,chr19,chr20,chr21,chr22,chrX,chrY 31.rmdup.bam &gt; 31.wig &amp;</span><br><span class="line"></span><br><span class="line">$Rscript ichorCNA-master/scripts/runIchorCNA.R --id test31 --WIG test31.wig \</span><br><span class="line">    --gcWig ichorCNA-master/inst/extdata/gc_hg19_1000kb.wig \</span><br><span class="line">    --mapWig ichorCNA-master/inst/extdata/map_hg19_1000kb.wig \</span><br><span class="line">    --centromere ichorCNA-master/inst/extdata/GRCh37.p13_centromere_UCSC-gapTable.txt \</span><br><span class="line">    --normalPanel ichorCNA-master/inst/extdata/HD_ULP_PoN_1Mb_median_normAutosome_mapScoreFiltered_median.rds \</span><br><span class="line">    --normal &quot;c(0.5,0.6,0.7,0.8,0.9)&quot;  --scStates &quot;c(1,3)&quot; \</span><br><span class="line">    --txnE 0.9999 --txnStrength 10000 --outDir ./</span><br></pre></td></tr></table></figure><h4 id="4-输出"><a href="#4-输出" class="headerlink" title="4. 输出"></a>4. 输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test31</span><br><span class="line">Gender: male</span><br><span class="line">Tumor Fraction: 0</span><br><span class="line">Ploidy: 2.001</span><br><span class="line">Subclone Fraction:      NA</span><br></pre></td></tr></table></figure><p><img src="/myphoto/clipboard31.png" alt="31"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test32</span><br><span class="line">Gender: male</span><br><span class="line">Tumor Fraction: 0</span><br><span class="line">Ploidy: 2</span><br><span class="line">Subclone Fraction:      NA</span><br></pre></td></tr></table></figure></p><p><img src="/myphoto/clipboard32.png" alt="32"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test33</span><br><span class="line">Gender: female</span><br><span class="line">Tumor Fraction: 0</span><br><span class="line">Ploidy: 2</span><br><span class="line">Subclone Fraction:      NA</span><br></pre></td></tr></table></figure></p><p><img src="/myphoto/clipboard33.png" alt="33"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test34</span><br><span class="line">Gender: female</span><br><span class="line">Tumor Fraction: 0</span><br><span class="line">Ploidy: 1.999</span><br><span class="line">Subclone Fraction:      NA</span><br></pre></td></tr></table></figure></p><p><img src="/myphoto/clipboard34.png" alt="34"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test35</span><br><span class="line">Gender: female</span><br><span class="line">Tumor Fraction: 0.404</span><br><span class="line">Ploidy: 2.98</span><br><span class="line">Subclone Fraction:      0.5017</span><br></pre></td></tr></table></figure></p><p><img src="/myphoto/clipboard35.png" alt="35"></p><h4 id="5-解释结果"><a href="#5-解释结果" class="headerlink" title="5. 解释结果"></a>5. 解释结果</h4><h4 id="6-帮助文档"><a href="#6-帮助文档" class="headerlink" title="6. 帮助文档"></a>6. 帮助文档</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rscript runIchorCNA.R --help</span><br><span class="line">Usage: runIchorCNA.R [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">--WIG=WIG</span><br><span class="line">WIG 文件(必须)</span><br><span class="line"></span><br><span class="line">--NORMWIG=NORMWIG</span><br><span class="line">标准 WIG 文件 Default: [NULL]</span><br><span class="line"></span><br><span class="line">--gcWig=GCWIG</span><br><span class="line">GC-content WIG 文件; (必须);软件给出的是hg19的GC WIG文件</span><br><span class="line"></span><br><span class="line">--mapWig=MAPWIG</span><br><span class="line"> WIG 文件  Default: [NULL]</span><br><span class="line"></span><br><span class="line">--normalPanel=NORMALPANEL</span><br><span class="line">深度矫正文件 Default: [NULL]</span><br><span class="line"></span><br><span class="line">--exons.bed=EXONS.BED</span><br><span class="line">外显子bed文件 Default: [NULL]</span><br><span class="line"></span><br><span class="line">--id=ID</span><br><span class="line">样本名 Default: [test]</span><br><span class="line"></span><br><span class="line">--centromere=CENTROMERE</span><br><span class="line">着丝粒位置文件;ichorCNA提供的是hg19版本的. Default: [NULL]</span><br><span class="line"></span><br><span class="line">--rmCentromereFlankLength=RMCENTROMEREFLANKLENGTH</span><br><span class="line">    去除着丝粒侧翼的长度. Default: [1e+05]</span><br><span class="line"></span><br><span class="line">--normal=NORMAL</span><br><span class="line">Initial normal contamination; can be more than one value if additional normal initializations are desired. Default: [0.5]</span><br><span class="line">    #初始正常污染; 如果需要额外的正常初始化，可以是多于一个值</span><br><span class="line">--scStates=SCSTATES</span><br><span class="line">亚克隆状态. Default: [NULL]</span><br><span class="line"></span><br><span class="line">--coverage=COVERAGE</span><br><span class="line">PICARD 软件计算出的覆盖度文件. Default: [NULL]</span><br><span class="line"></span><br><span class="line">--lambda=LAMBDA</span><br><span class="line">Initial Student&apos;s t precision; must contain 4 values (e.g. c(1500,1500,1500,1500)); if not provided then will automatically use based on variance of data. Default: [NULL]</span><br><span class="line">    # 初始T-test精确度; 必须包含4个值（例如c（1500,1500,1500,1500））;如果没有提供，则会根据数据的方差自动使用</span><br><span class="line">--lambdaScaleHyperParam=LAMBDASCALEHYPERPARAM</span><br><span class="line">Hyperparameter (scale) for Gamma prior on Student&apos;s-t precision. Default: [3]</span><br><span class="line">    #Gamma之前的超参数（规模）的t精度</span><br><span class="line">--ploidy=PLOIDY</span><br><span class="line">Initial tumour ploidy; can be more than one value if additional ploidy initializations are desired. Default: [2]</span><br><span class="line">    # 最初的肿瘤倍性; 默认二倍体；</span><br><span class="line">--maxCN=MAXCN</span><br><span class="line">Total clonal CN states. Default: [7]</span><br><span class="line"></span><br><span class="line">--estimateNormal=ESTIMATENORMAL</span><br><span class="line">Estimate normal. Default: [TRUE]</span><br><span class="line"></span><br><span class="line">--estimateScPrevalence=ESTIMATESCPREVALENCE</span><br><span class="line">Estimate subclonal prevalence. Default: [TRUE]</span><br><span class="line"></span><br><span class="line">--estimatePloidy=ESTIMATEPLOIDY</span><br><span class="line">Estimate tumour ploidy. Default: [TRUE]</span><br><span class="line"></span><br><span class="line">--maxFracCNASubclone=MAXFRACCNASUBCLONE</span><br><span class="line">Exclude solutions with fraction of subclonal events greater than this value. Default: [0.7]</span><br><span class="line">    # 排除大于此值的部分亚克隆事件的解决方案</span><br><span class="line">--maxFracGenomeSubclone=MAXFRACGENOMESUBCLONE</span><br><span class="line">Exclude solutions with subclonal genome fraction greater than this value. Default: [0.5]</span><br><span class="line">    # 排除亚克隆基因组分数大于此值的解决方案</span><br><span class="line">--minSegmentBins=MINSEGMENTBINS</span><br><span class="line">Minimum number of bins for largest segment threshold required to estimate tumor fraction; if below this threshold, then will be assigned zero tumor fraction.</span><br><span class="line"></span><br><span class="line">--altFracThreshold=ALTFRACTHRESHOLD</span><br><span class="line">Minimum proportion of bins altered required to estimate tumor fraction; if below this threshold, then will be assigned zero tumor fraction. Default: [0.05]</span><br><span class="line">    # 评估肿瘤分数所需的最大分割阈值的最小分箱数量; 如果低于这个阈值，则将被分配零肿瘤分数</span><br><span class="line">--chrNormalize=CHRNORMALIZE</span><br><span class="line">Specify chromosomes to normalize GC/mappability biases. Default: [c(1:22)]</span><br><span class="line">    #指定染色体</span><br><span class="line">--chrTrain=CHRTRAIN</span><br><span class="line">Specify chromosomes to estimate params. Default: [c(1:22)]</span><br><span class="line">    #指定染色体</span><br><span class="line">--chrs=CHRS</span><br><span class="line">Specify chromosomes to analyze. Default: [c(1:22,&quot;X&quot;)]</span><br><span class="line">    #指定染色体</span><br><span class="line">--normalizeMaleX=NORMALIZEMALEX</span><br><span class="line">If male, then normalize chrX by median. Default: [TRUE]</span><br><span class="line">    # 男性按照X染色体分析</span><br><span class="line">--fracReadsInChrYForMale=FRACREADSINCHRYFORMALE</span><br><span class="line">Threshold for fraction of reads in chrY to assign as male. Default: [0.001]</span><br><span class="line">    #将chrY中的读数部分的阈值分配为男性</span><br><span class="line">--includeHOMD=INCLUDEHOMD</span><br><span class="line">If FALSE, then exclude HOMD state. Useful when using large bins (e.g. 1Mb). Default: [FALSE]</span><br><span class="line">    # 如果FALSE，则排除HOMD状态。 使用大容量箱（如1Mb）时很有用</span><br><span class="line">--txnE=TXNE</span><br><span class="line">Self-transition probability. Increase to decrease number of segments. Default: [0.9999999]</span><br><span class="line">    #　自我转换概率。 增加以减少段数</span><br><span class="line">--txnStrength=TXNSTRENGTH</span><br><span class="line">Transition pseudo-counts. Exponent should be the same as the number of decimal places of --txnE. Default: [1e+07]</span><br><span class="line">    # 转换伪计数。 指数应与--txnE的小数位数相同</span><br><span class="line">--plotFileType=PLOTFILETYPE</span><br><span class="line">File format for output plots. Default: [pdf]</span><br><span class="line">    #图片输出格式</span><br><span class="line">--plotYLim=PLOTYLIM</span><br><span class="line">ylim to use for chromosome plots. Default: [c(-2,2)]</span><br><span class="line">    y轴范围</span><br><span class="line">--outDir=OUTDIR</span><br><span class="line">Output Directory. Default: [./]</span><br><span class="line"></span><br><span class="line">--libdir=LIBDIR</span><br><span class="line">Script library path. Usually exclude this argument unless custom modifications have been made to the ichorCNA R package code and the user would like to source those R files. Default: [NULL]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 生信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生信软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SAM/BAM格式说明</title>
      <link href="/2018/02/13/sam-bam-ge-shi-shuo-ming/"/>
      <url>/2018/02/13/sam-bam-ge-shi-shuo-ming/</url>
      
        <content type="html"><![CDATA[<p><strong>SAM</strong>是一种序列比对格式标准，由sanger制定，是以TAB为分割符的文本格式。 主要应用于测序序列mapping到基因组上的结果表示，当然也可以表示任意的多重比对结果。 SAM的全称是sequence alignment/map format</p><h5 id="定义和示例"><a href="#定义和示例" class="headerlink" title="定义和示例"></a>定义和示例</h5><p>SAM分为两部分，注释信息（header section ）和比对结果部分 （alignment section）。 通常是把FASTQ文件格式的测序数据比对到对应的参考基因组版本得到的。 注释信息并不是SAM文件的重点，是该SAM文件产生以及被处理过程的一个记录，规定以@开头，用不同的tag表示不同的信息，主要有：</p><ul><li>@HD，说明符合标准的版本、对比序列的排列顺序；</li><li>@SQ，参考序列说明；</li><li>@RG，比对上的序列（read）说明；</li><li>@PG，使用的程序说明；</li><li>@CO，任意的说明信息。<br>一个简单的SAM文件例子如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ST-E00317:118:HNHK2CCXX:7:1101:5071:130997chr119669566660147Mchr18548067150AAGAATATGGACACAGTGAAGTGGTGGAATATTATTGCAATCCTAGATTTCTAATGAAGGGACCTAATAAAATTCAGTGTGTTGATGGAGAGTGGACAACTTTACCAGTGTGTATTTGTAATGTATAAAACATTAATATTGAAACTTFFAKKKKKKFKKKKKK,FKKKKKKK&lt;KKKFKK,FKKKKKKKKKFFKKKKKFFKKFAKFK,FKKKAKKKKKKKKKKKAF,,,FFAFA,FKKAKAA7FKKFKFFFKKKK7FFKK7F7K,7FAFKAFFKKKKK,7AFKFKFA,,,AAK,AMC:Z:13S134MMD:Z:76A39G13T9T6RG:Z:sampleIDNM:i:4AS:i:127XS:i:21</span><br></pre></td></tr></table></figure></li></ul><p>说明如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QNAME   ST-E00317:118:HNHK2CCXX:7:1101:5071:1309      </span><br><span class="line">## read名称</span><br><span class="line">FLAG    97  </span><br><span class="line">##  FLAG, 概括出一个合适的标记，各个数字分别代表</span><br><span class="line">##1     序列是一对序列中的一个</span><br><span class="line">##2     比对结果是一个pair-end比对的末端</span><br><span class="line">##4     没有找到位点</span><br><span class="line">##8     这个序列是pair中的一个但是没有找到位点</span><br><span class="line">##16   在这个比对上的位点，序列与参考序列反向互补</span><br><span class="line">##32   这个序列在pair-end中的的mate序列与参考序列反响互补</span><br><span class="line">##64   序列是 mate 1</span><br><span class="line">##128 序列是 mate 2</span><br><span class="line">##假如说标记为以上列举出的数目，就可以直接推断出匹配的情况。假如说标记不是以上列举出的数字，比如说83=（64+16+2+1），就是这几种情况值和。</span><br><span class="line">##　其他情况可参见 http://broadinstitute.github.io/picard/explain-flags.html</span><br><span class="line">RNAME  chr1 </span><br><span class="line">## 染色体名称</span><br><span class="line">POS 196695666   </span><br><span class="line">## 染色体位置</span><br><span class="line">MAQ 60  </span><br><span class="line">## mapping质量 越高说明位点越独特</span><br><span class="line">CIGAR   147M </span><br><span class="line">## M”表示 match或 mismatch；</span><br><span class="line">## “I”表示 insert；</span><br><span class="line">## “D”表示 deletion；</span><br><span class="line">## “N”表示 skipped（跳过这段区域）；</span><br><span class="line">## “S”表示 soft clipping（被剪切的序列存在于序列中）；</span><br><span class="line">##“H”表示 hard clipping（被剪切的序列不存在于序列中）；</span><br><span class="line">##“P”表示 padding；</span><br><span class="line">##“=”表示 match；</span><br><span class="line">##“X”表示 mismatch（错配，位置是一一对应的）；</span><br><span class="line">MRNM    chr18</span><br><span class="line">## read2 在参考序列上的位置，如果没有就用 &quot;*&quot;, 相同&quot;=&quot;</span><br><span class="line">MPOS    0 </span><br><span class="line">##read2 的位置，若不可用则用0</span><br><span class="line">ISIZE   0</span><br><span class="line">## emplate的长度，最左边得为正，最右边的为负，中间的不用定义正负，不分区段（single-segment)的比对上，或者不可用时，此处为0</span><br><span class="line">SEQ AAGAATATGGACACAGTGAAGTGGTGGAATATTATTGCAATCCTAGATTTCTAATGAAGGGACCTAATAAAATTCAGTGTGTTGATGGAGAGTGGACAACTTTACCAGTGTGTATTTGTAATGTATAAAACATTAATATTGAAACTT</span><br><span class="line">##　序列片段的序列信息</span><br><span class="line">QUAL    FFAKKKKKKFKKKKKK,FKKKKKKK&lt;KKKFKK,FKKKKKKKKKFFKKKKKFFKKFAKFK,FKKKAKKKKKKKKKKKAF,,,FFAFA,FKKAKAA7FKKFKFFFKKKK7FFKK7F7K,7FAFKAFFKKKKK,7AFKFKFA,,,AAK,A</span><br><span class="line">## 序列的质量信息，格式同FASTQ一样。read质量的ASCII编码</span><br><span class="line">MC:Z:13S134M    MD:Z:76A39G13T9T6       RG:Z:sampleID   NM:i:4  AS:i:127        XS:i:21</span><br><span class="line">## 可选字段（optional fields)，格式如：TAG:TYPE:VALUE，其中TAG有两个大写字母组成，每个TAG代表一类信息，每一行一个TAG只能出现一次，TYPE表示TAG对应值的类型，可以是字符串、整数、字节、数组等。</span><br><span class="line">## AS:i 匹配的得分</span><br><span class="line">## XS:i 第二好的匹配的得分</span><br><span class="line">## YS:i mate 序列匹配的得分</span><br><span class="line">## XN:i 在参考序列上模糊碱基的个数</span><br><span class="line">## XM:i 错配的个数</span><br><span class="line">## XO:i gap open的个数</span><br><span class="line">## XG:i gap 延伸的个数</span><br><span class="line">## NM:i 经过编辑的序列 </span><br><span class="line">## YF:i 说明为什么这个序列被过滤的字符串</span><br><span class="line">## YT:Z</span><br><span class="line">## MD:Z 代表序列和参考序列错配的字符串</span><br><span class="line">##</span><br></pre></td></tr></table></figure></p><h5 id="SAM要处理好的问题"><a href="#SAM要处理好的问题" class="headerlink" title="SAM要处理好的问题"></a>SAM要处理好的问题</h5><ul><li>非常多序列（read)，mapping到多个参考基因组（reference）上</li><li>同一条序列，分多段（segment）比对到参考基因组上</li><li>无限量的，结构化信息表示，包括错配、删除、插入等比对信息</li></ul><p>要注意的几个概念，以及与之对应的模型：</p><ul><li>reference</li><li>read</li><li>segment</li><li><strong>++template（参考序列和比对上的序列共同组成的序列为template）++</strong></li><li>alignment</li><li>seq</li><li></li></ul><p><strong>参考链接</strong>：</p><ol><li><a href="https://en.wikipedia.org/wiki/SAM_(file_format" target="_blank" rel="noopener">SAM(file format)</a>)(可下载PDF文件)</li><li><a href="https://genome.sph.umich.edu/wiki/SAM#What_are_TAGs.3F" target="_blank" rel="noopener">https://genome.sph.umich.edu/wiki/SAM#What_are_TAGs.3F</a></li><li><a href="https://mp.weixin.qq.com/s/yK1OyJHrePg6bWl41JCpvA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/yK1OyJHrePg6bWl41JCpvA</a></li><li><a href="http://www.cnblogs.com/emanlee/p/5366610.html" target="_blank" rel="noopener">http://www.cnblogs.com/emanlee/p/5366610.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 生信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生信理论基础 </tag>
            
            <tag> 文件格式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(转载)linux下R安装(无root权限)</title>
      <link href="/2018/02/13/zhuan-zai-linux-xia-r-an-zhuang-wu-root-quan-xian/"/>
      <url>/2018/02/13/zhuan-zai-linux-xia-r-an-zhuang-wu-root-quan-xian/</url>
      
        <content type="html"><![CDATA[<h5 id="R依赖库的安装"><a href="#R依赖库的安装" class="headerlink" title="R依赖库的安装"></a>R依赖库的安装</h5><p>在安装R之前首先要安装R依赖的包，如何知道R安装需要什么包呢？可以去看R的官方文档<a href="https://cran.r-project.org/doc/manuals/r-release/R-admin.html#Essential-and-useful-other-programs-under-a-Unix_002dalike" target="_blank" rel="noopener">R Installation and Administration</a> ,我们主要要安装的依赖包是zlib，bzip，liblzma(这个包如果直接搜索liblzma出来的会是XZ，没错，需要安装的就是XZ)以及PCRE。不过首先需要注意的是，我安装的R版本是R-3.4.2 Short Summer，2017-09-28发行，而依照的官方文档也是Version 3.4.2 2017-09-28，因此其他版本的不一定完全适用，但是一般来说R所依赖的包大致都是这些，可能有版本的区别，安装R的大致顺序也差不多。其次，在安装这些库时最好遵照我下面给出的顺序来依次进行。否则就会报错。</p><ol><li><p>安装zlib1.2.5版本及以上</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd zlib-1.2.11</span><br><span class="line">./configure --prefix =/bulider/software/zlib</span><br><span class="line">make  </span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li><li><p>安装bzip</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd bzip2-1.0.6</span><br><span class="line">make -f Makefile-libbz2_so</span><br><span class="line">#修改Makefile 中的PREFIX=/bulider/software/bzip2</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li><li><p>安装liblzma5.0.3版本及以上</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd xz-5.2.3</span><br><span class="line">./configure -prefix=/bulider/software/xz</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li><li><p>安装pcre</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf pcre-8.41.tar.gz</span><br><span class="line">cd pcre-8.41</span><br><span class="line">./configure --enable-utf --enable-unicode-properties --enable-jit --disable-cpp --prefix /bulider/software/pcre</span><br><span class="line">##这个包的安装参数是有要求的，因此用的是官方文档的推荐命令</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li><li><p>安装libcurl7.22.0及以上，但是不要超过版本8</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxf curl-7.28.0.tar.gz</span><br><span class="line">cd curl-7.28.0</span><br><span class="line">./configure --prefix=/bulider/software/curl</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li></ol><h5 id="安装R"><a href="#安装R" class="headerlink" title="安装R"></a>安装R</h5><ol><li>进行configure<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/source/R-3.4.2/configure --prefix=/builder/software/R --en</span><br><span class="line">able-R-shlib --with-cairo  --with-jpeglib --with-readline --with-tcltk  --with-blas --with-lapack --enable-R-profiling LDFLAGS=&quot;-L/builder/software/zlib/lib  -L/builder/software/bzip2/lib -L/builder/software/xz/lib -L/builder/software/pcre/lib -L/builder/so</span><br><span class="line">ftware/curl/lib&quot; CPPFLAGS=&quot;-I/builder/zlib/include -I/builder/softw</span><br><span class="line">are/bzip2/include -I/builder/software/xz/include -I/builder/software/pcre/in</span><br><span class="line">clude -I/builder/software/curl/include&quot;##第一步检查环境配置，生成Makefile</span><br></pre></td></tr></table></figure></li></ol><p>首先注意一点，如果你要把R安装到另一个文件夹里而不是源码所在的文件夹里，那么你首先要创建一个文件夹，然后在这个文件夹里对R进行编译，在<code>configure</code>时要加上全路径<code>/source/R-3.4.2/configure</code>，同时在后面加上<code>--prefix=</code>参数，比方我要安装到<code>/builder/software/R</code>,那么就需要加入<code>--prefix=/builder/software/R</code>这个参数，而我的源码在<code>/source/R-3.4.2</code>这个文件夹里。</p><p>其次由于R是用C语言写的，因此要从源码编译R需要把R的源码需要通过gcc将源码编译为可执行文件。在前面我们安装了一些R的依赖库，这些依赖库是在编译R的时候要用到的，如果在一般情况下这些依赖库都会放到系统指定的位置来进行使用，但是由于我没有root权限，因此无法将这些库文件放到系统指定的库路径或者修改相应的配置文件，只能把这些库的路径通过<code>LDFLAGS</code>和<code>CPPFLAGS</code>这两个参数来传递给gcc，关于这两个参数可以参考。告诉gcc这些路径里有相应的库。其中<code>LDFLAGS</code>传递的是给链接器的参数，<code>CPPFLAGS</code>传递的是相应的头文件。这两个参数都是<code>configure</code>的参数。</p><ol><li>通过上一步生成了<code>Makefile</code>后，觉得胜利已经在前方向你招手，于是你进行了<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li></ol><p>但是出现了报错！<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sr/bin/ld: warning: libpcre.so.1, needed by ../../lib/libR.so, not found (try using -rpath or -rpath-link)</span><br><span class="line">/usr/bin/ld: warning: liblzma.so.5, needed by ../../lib/libR.so, not found (try using -rpath or -rpath-link)</span><br><span class="line">../../lib/libR.so: undefined reference to `pcre_fullinfo&apos;</span><br><span class="line">../../lib/libR.so: undefined reference to `lzma_lzma_preset@XZ_5.0&apos;</span><br><span class="line">../../lib/libR.so: undefined reference to `lzma_alone_decoder@XZ_5.0&apos;</span><br><span class="line">../../lib/libR.so: undefined reference to `lzma_crc64@XZ_5.0&apos;</span><br><span class="line">../../lib/libR.so: undefined reference to `lzma_raw_encoder@XZ_5.0&apos;</span><br><span class="line">../../lib/libR.so: undefined reference to `pcre_config&apos;</span><br><span class="line">../../lib/libR.so: undefined reference to `lzma_code@XZ_5.0&apos;</span><br><span class="line">../../lib/libR.so: undefined reference to `lzma_stream_decoder@XZ_5.0&apos;</span><br><span class="line">../../lib/libR.so: undefined reference to `pcre_free&apos;</span><br><span class="line">../../lib/libR.so: undefined reference to `lzma_raw_decoder@XZ_5.0&apos;</span><br><span class="line">../../lib/libR.so: undefined reference to `pcre_free_study&apos;</span><br><span class="line">../../lib/libR.so: undefined reference to `pcre_assign_jit_stack&apos;</span><br><span class="line">../../lib/libR.so: undefined reference to `pcre_exec&apos;</span><br><span class="line">../../lib/libR.so: undefined reference to `lzma_version_string@XZ_5.0&apos;</span><br><span class="line">../../lib/libR.so: undefined reference to `pcre_maketables&apos;</span><br><span class="line">../../lib/libR.so: undefined reference to `lzma_stream_encoder@XZ_5.0&apos;</span><br><span class="line">../../lib/libR.so: undefined reference to `pcre_compile&apos;</span><br><span class="line">../../lib/libR.so: undefined reference to `pcre_study&apos;</span><br><span class="line">../../lib/libR.so: undefined reference to `pcre_version&apos;</span><br><span class="line">../../lib/libR.so: undefined reference to `lzma_end@XZ_5.0&apos;</span><br><span class="line">../../lib/libR.so: undefined reference to `pcre_jit_stack_alloc&apos;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">make[3]: *** [R.bin] Error 1</span><br><span class="line">make[3]: Leaving directory `/builder/software/R/src/main&apos;</span><br><span class="line">make[2]: *** [R] Error 2</span><br><span class="line">make[2]: Leaving directory `/builder/software/R/src/main&apos;</span><br><span class="line">make[1]: *** [R] Error 1</span><br><span class="line">make[1]: Leaving directory `/builder/software/R/src&apos;</span><br><span class="line">make: *** [R] Error 1</span><br></pre></td></tr></table></figure></p><p>这个报错是因为什么原因导致的？我们可以看到里面说<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usr/bin/ld: warning: libpcre.so.1, needed by ../../lib/libR.so, not found (try using -rpath or -rpath-link)</span><br><span class="line">/usr/bin/ld: warning: liblzma.so.5, needed by ../../lib/libR.so, not found (try using -rpath or -rpath-link)</span><br></pre></td></tr></table></figure></p><p>说缺少<code>libpcre.so.1</code>和<code>liblzma.so.5</code>这两个库文件，我心里浮现了一副黑人问号脸我在前面<code>./configure</code>的时候还传入了<code>PCRE</code>和<code>XZ</code>这两个库的路径，为什么还是会报错？<br>于是我先是进行了谷歌，从谷歌上找到了一篇R安装攻略,在这篇攻略里也提到了这个问题，</p><blockquote><p>此处报错是由于没有找到动态库，看第一二行</p><p>解决方法：添加动态库</p><p>cat /etc/ld.so.conf</p><p>include ld.so.conf.d/*.conf</p><p>/opt/pcre-8.39/lib</p><p>/opt/xz-5.2.2/lib</p></blockquote><p>但是在这个攻略里最后的解决方法是修改<code>/etc/ld.so.conf</code>文件，将前面安装的库的路径添加到这个文件中，但是我没有root权限，并不能修改这个文件，因此这个方法对我并不适用。后来在鹏帆和许骄的提醒下，我们在后面看到建议说try using <code>-rpath or -rpath-link</code>,后来我搜索了这两个命令，这两个命令是用于通过gcc向ld传递参数的时候用的，</p><blockquote><p>gcc编译链接动态库时，很有可能编译通过，但是执行时，找不到动态链接库，那是因为-L选项指定的路径只在编译时有效，解决方法是通过-Wl(注意，是字母表K之后的小写L),<code>rpath=&lt;your_lib_dir&gt;</code>，使得execute记住链接库的位置</p></blockquote><p>于是我试着在configure的时候加入这两个参数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/builder/software/R-3.4.2/configure --prefix=/builder/software/R --en</span><br><span class="line">able-R-shlib --with-cairo  --with-jpeglib --with-readline --with-tcltk  --with-blas --with-lapack --enable-R-profiling LDFLAGS=&quot;-L/builder/software/zlib/lib  -L/builder/software/bzip2/lib -L/builder/software/xz/lib  -Wl,--rpath/builder/software/pcre/lib -Wl,--rpath/builder/so</span><br><span class="line">ftware/curl/lib&quot; CPPFLAGS=&quot;-I/builder/software/zlib/include -I/builder/softw</span><br><span class="line">are/bzip2/include -I/builder/software/xz/include -I/builder/software/pcre/in</span><br><span class="line">clude -I/builder/software/curl/include</span><br></pre></td></tr></table></figure></p><p>但是这样总会报错，后来我知道，configure的时候我们传入的参数都会写到Makeconf文件里面，那么我可不可以先按照原来的我方法先进行configure，然后再对Makeconf文件进行修改呢？于是我还是先按照之前的方法进行configure<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/builder/software/R-3.4.2/configure --prefix=/builder/software/R --en</span><br><span class="line">able-R-shlib --with-cairo  --with-jpeglib --with-readline --with-tcltk  --with-blas --with-lapack --enable-R-profiling LDFLAGS=&quot;-L/builder/software/zlib/lib  -L/builder/software/bzip2/lib -L/builder/software/xz/lib -L/builder/software/pcre/lib -L/builder/so</span><br><span class="line">ftware/curl/lib&quot; CPPFLAGS=&quot;-I/builder/software/zlib/include -I/builder/softw</span><br><span class="line">are/bzip2/include -I/builder/software/xz/include -I/builder/software/pcre/in</span><br><span class="line">clude -I/builder/software/curl/include</span><br></pre></td></tr></table></figure></p><p>然后在make之前修改Makeconf中的参数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LDFLAGS = -L/builder/software/zlib/lib  -L/builder/software/bzip2/lib   -L/builder/software/curl/lib -Wl,-rpath=/builder/software/xz/lib -Wl,-rpath=/builder/software/pcre/lib</span><br></pre></td></tr></table></figure></p><p>再进行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></p><p>之前的报错终于不见了!但是出现了新的报错心里有句mmp:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/bin/ld: cannot find -lpcre</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">make[3]: *** [libR.so] Error 1</span><br><span class="line">make[3]: Leaving directory `/builder/software/R-3.4.2/src/main&apos;</span><br><span class="line">make[2]: *** [R] Error 2</span><br><span class="line">make[2]: Leaving directory `/builder/software/R-3.4.2/src/main&apos;</span><br><span class="line">make[1]: *** [R] Error 1</span><br><span class="line">make[1]: Leaving directory `/builder/software/R-3.4.2/src&apos;</span><br><span class="line">make: *** [R] Error 1</span><br></pre></td></tr></table></figure></p><p>于是我在想，可能是前面我把LDFLAGS里面参数由-L/builder/software/pcre/lib修改为了-Wl,-rpath=/builder/software/pcre/lib之后不再出现原来的报错，但是现在又出现了新的报错，而我在使用原来的参数时不会出现这个新的报错，结合之前我搜索到的结果,是不是因为我之前的写法只能让路径gcc在编译时有效,而后来的写法只能让其在进行运行时有效？那么如果我让两种参数同时出现，虽然我把库的路径传递了两次，但是会不会就不再报错了？时间是检验真理的唯一标准！先试验一把！于是我把两种参数的路径都加到了Makeconf中<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LDFLAGS = -L/builder/software/zlib/lib  -L/builder/software/bzip2/lib -L/builder/software/xz/lib -L/builder/software/pcre/lib -L/builder/software/curl/lib -Wl,-rpath=/builder/software/xz/lib -Wl,-rpath=/builder/software/pcre/lib</span><br></pre></td></tr></table></figure></p><p>再次进行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></p><p>终于没有了报错。说明make成功了，于是我再进行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></p><p>终于安装完成！你挑着担我牵着马</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>1.在Linux下用源码安装R是个大坑尤其是在没有root权限的情况下</p><p>2.安装R之前一定要将R要求的依赖库预先安装好，版本和安装顺序都要对。具体可以参考R官方文档R Installation and Administration 。</p><p>3.在安装好R的依赖库之后，在进行R的安装的时候要注意将依赖库的路径传入到参数中，而且一定要注意传入的方式。</p><p>4.注意分析报错信息，从中寻找原因，不要盲目瞎想，多谷歌，多问老司机。</p><p>5.关于-Wl -rpath更详细的介绍<a href="https://my.oschina.net/shelllife/blog/115958" target="_blank" rel="noopener">参考</a></p><p>3.在安装好R的依赖库之后，在进行R的安装的时候要注意将依赖库的路径传入到参数中，而且一定要注意传入的方式。<br>4.注意分析报错信息，从中寻找原因，不要盲目瞎想，多谷歌，多问老司机。<br>5.关于-Wl -rpath更详细的介绍参考</p><p>参考链接：<a href="http://www.jianshu.com/p/5bfe154f1aa4" target="_blank" rel="noopener">http://www.jianshu.com/p/5bfe154f1aa4</a></p>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> R </tag>
            
            <tag> 统计语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="/2018/02/12/wo-de-di-yi-ge-bo-ke/"/>
      <url>/2018/02/12/wo-de-di-yi-ge-bo-ke/</url>
      
        <content type="html"><![CDATA[<hr><p>title:<br>categories: </p><ul><li>python3<br>tags:</li><li>编程语言</li><li>python3</li><li>大数据<br>date: </li></ul><h2 id="—"><a href="#—" class="headerlink" title="—-"></a>—-</h2><p>title: perl 单行命令<br>categories: </p><ul><li>perl<br>tags:</li><li>编程语言</li><li>perl<br>date: </li></ul><h2 id="—-1"><a href="#—-1" class="headerlink" title="—-"></a>—-</h2><p>title: (转载)linux下R安装(无root权限)<br>categories: </p><ul><li>R<br>tags:</li><li>编程语言</li><li>R</li><li>统计语言<br>date: </li></ul><h2 id="—-2"><a href="#—-2" class="headerlink" title="—-"></a>—-</h2><p>title: C语言读写文件<br>categories: </p><ul><li>C/C++<br>tags:</li><li>编程语言</li><li>C<br>date: 2018-03-25</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 生信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生信理论基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
