<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器学习笔记-----Logistic回归</title>
      <link href="/2019/01/23/ji-qi-xue-xi-bi-ji-logistic-hui-gui/"/>
      <url>/2019/01/23/ji-qi-xue-xi-bi-ji-logistic-hui-gui/</url>
      
        <content type="html"><![CDATA[<p>Logistic回归,有翻译为“逻辑回归”，但是它跟“逻辑”这个单词一点关系都没有，也不是解决回归问题的，是用来解决二分类的算法，最准确的翻译应该是“对数几率回归”</p><p>至于为什么叫对数几率刚回归，请看下面的推倒过程</p><a id="more"></a> <h2 id="线性回归回顾"><a href="#线性回归回顾" class="headerlink" title="线性回归回顾"></a>线性回归回顾</h2><p>先来看一个简单的线性回归模型：</p><p>$$ f(x) = \vec\omega^T \vec{x}+b  $$<br>这里的</p><p>$$ \vec\omega^T = [\omega_1,\omega_2,\cdots,\omega_n] $$</p>$$ \vec x  = \left[\begin{matrix}x_1 \\x_2  \\\cdots\\x_n  \end{matrix} \right] $$<p>一般来说给定的数据集是：$D={(\vec x^{(1)},y^{(1)}),(\vec x^{(2)},y^{(2)}),⋯,(\vec x^{(m)},y^{(m)})}$, 即有m组数据，n个未知数，因此多变量线性回归的公式是：</p><p>$$f(x)= X^T \vec\omega $$</p><p>其中：</p>$$X = \left[\begin{matrix}x_1^{(1)} \   x_2^{(1)} \ x_1^{(1)} \ \cdots \ x_n^{(1)} \ 1 \\x_1^{(2)} \   x_2^{(2)} \ x_3^{(2)} \ \cdots \ x_n^{(2)} \ 1 \\x_1^{(3)} \   x_2^{(3)} \ x_3^{(3)} \ \cdots \ x_n^{(3)} \ 1 \\\cdots \\x_1^{(m)} \   x_2^{(m)} \ x_3^{(m)} \ \cdots \ x_n^{(m)} \ 1 \end{matrix} \right] =  \left[\begin{matrix}\vec x^{(1)T} \ 1 \\\vec x^{(2)T} \ 1 \\\vec x^{(3)T} \ 1 \\\cdots \\\vec x^{(m)T} \ 1 \\\end{matrix} \right]$$<p>展开式：</p><p>$$\omega_1 x_1^{(1)} + \omega_2 x_2^{(1)} + \cdots + \omega_n x_n^{(1)} +b = y^{(1)} $$</p><p>$$\omega_1 x_1^{(2)} + \omega_2 x_2^{(2)} + \cdots + \omega_n x_n^{(2)} + b = y^{(2)}$$</p><p>$$\cdots$$</p><p>$$\omega_1 x_1^{(m)} + \omega_2 x_2^{(m)} + \cdots + \omega_n x_n^{(m)} +b = y^{(m)}$$</p><p>我们为了便于推导，忽略了下标，只用了一组$(\vec{x},y)$,然后把$b$当做$\omega_0$，而此时$x_0 = 1$：</p><p>$$f(x)=\vec\omega^T \vec{x} $$</p><h2 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h2><p>线性回归很显然是一个连续的值，既然要解决二分类的问题，那最好是换成一个$0/1$的值</p><p>这里引出一个sigmoid函数：<br>$$g(z) = \frac {1}{1+e^{-z}}$$</p><p><img src="/myphoto/logtic.png" alt="logtic"></p><p>令：</p><p>$$z =\vec\omega^T \vec{x}+b $$</p><p>$$f(x) = g(z) = \frac {1}{1+e^{-\vec\omega^T \vec{x}}} $$</p><p>我们就引出了我们的模型：</p><p>$$ln \frac{y}{1-y} =  \vec\omega^T \vec{x}+b $$</p><p>上式中$\frac{y}{1-y}$ 称为几率，反应x获得正例(y)的相对可能性，由此可以看出，模型实际上是在用线性回归模型的预测结果去逼近真实值$y$的对数几率，因此该模型就称为<strong>对数几率回归模型</strong></p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>由于$y$的值为0,1，我们将$y$视为后验概率：</p><p>$$p(y=1 |  x;\omega) = f(x) $$</p><p>$$p(y=0 |  x;\omega) = 1- f(x) $$</p><p>$f(x)$越大，代表着预测值与$y$越接近，误差就越小，带入到公式中：</p><p>$$p(y=1 |  x;\omega) = \frac {e^{\vec\omega^T \vec{x}}}{1+e^{\vec\omega^T \vec{x}}} $$</p><p>$$p(y=0 |  x;\omega) = \frac {1}{1+e^{\vec\omega^T \vec{x}}}  $$</p><p>为了确定$\omega$用对数似然函数：</p><p>$$ \ell(\omega) = lnp(y|x ;\omega)$$</p><p>可以合并到一起：</p><p>$$ p(y|x ;\omega) = f(x)^y(1-f(x))^{(1-y)}$$</p><p>带入到对数似然函数中：</p><p>$$ln p(y|x ;\omega) = y lnf(x) + (1-y)ln(1-f(x)) $$</p><p>我们得到的代价函数：</p><p>$$J(\omega) = - \frac{1}{m} \sum_{i=1}^m [ y^{(i)} lnf(x^{(i)}) + (1-y^{(i)})ln(1-f(x^{(i)})) ] $$</p><p>$J(\omega)$越小，就说明$f(x) = 1$的概率越大，因此只要求出$J(\omega)$的<strong>最小值</strong></p><blockquote><p>ps：</p><p>1）其实正常推倒出来的J(w)是没有前面的负号的，这里为了习惯，用梯度下降法求最小值，所以加了一个负号</p><p>2） 之前推倒时候忽略了上标，但是我们在最后的损失函数中为了完整性就把上标加了上去</p></blockquote><h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><p>对代价函数求导的过程就不写了，直接写最后的结果:</p><p>$$\frac{\partial J(\omega)}{\partial\omega_j} =\frac{1}{m} \sum_{i=1}^m (f(x^{(i)}) - y^{(i)})x_j^{(i)}  $$</p><p>$$\omega_{j+1} := \omega_j- \frac{1}{m}\alpha\sum_{i=1}^m(f(x^{(i)}) - y^{(i)})x_j^{(i)} $$</p><h2 id="sklearn代码实现逻辑回归"><a href="#sklearn代码实现逻辑回归" class="headerlink" title="sklearn代码实现逻辑回归"></a>sklearn代码实现逻辑回归</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt</span><br><span class="line"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd</span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataset = pd.read_csv(<span class="hljs-string">r'E:\Downloads\100-Days-Of-ML-Code-master\Social_Network_Ads.csv'</span>)</span><br><span class="line">dataset.head(<span class="hljs-number">5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = dataset.iloc[:,[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]].values</span><br><span class="line">Y = dataset.iloc[:,<span class="hljs-number">4</span>].values</span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size = <span class="hljs-number">0.25</span>, random_state = <span class="hljs-number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler</span><br><span class="line">sc = StandardScaler()</span><br><span class="line">X_train = sc.fit_transform(X_train)</span><br><span class="line">X_test = sc.transform(X_test)</span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression</span><br><span class="line">classifier = LogisticRegression()</span><br><span class="line">classifier.fit(X_train, y_train)</span><br><span class="line"><span class="hljs-comment"># classifier.coef_</span></span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_pred = classifier.predict(X_test)</span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> confusion_matrix</span><br><span class="line">cm = confusion_matrix(y_test, y_pred)</span><br></pre></td></tr></table></figure><p>可视化</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> matplotlib.colors <span class="hljs-keyword">import</span> ListedColormap</span><br><span class="line">X_set,y_set=X_train,y_train</span><br><span class="line">X1,X2=np. meshgrid(np. arange(start=X_set[:,<span class="hljs-number">0</span>].min()<span class="hljs-number">-1</span>, stop=X_set[:, <span class="hljs-number">0</span>].max()+<span class="hljs-number">1</span>, step=<span class="hljs-number">0.01</span>),</span><br><span class="line">                   np. arange(start=X_set[:,<span class="hljs-number">1</span>].min()<span class="hljs-number">-1</span>, stop=X_set[:,<span class="hljs-number">1</span>].max()+<span class="hljs-number">1</span>, step=<span class="hljs-number">0.01</span>))</span><br><span class="line">plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(),X2.ravel()]).T).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="hljs-number">0.75</span>, cmap = ListedColormap((<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(),X1.max())</span><br><span class="line">plt.ylim(X2.min(),X2.max())</span><br><span class="line"><span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> enumerate(np. unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set==j,<span class="hljs-number">0</span>],X_set[y_set==j,<span class="hljs-number">1</span>],</span><br><span class="line">                c = ListedColormap((<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>))(i), label=j)</span><br><span class="line"></span><br><span class="line">plt. title(<span class="hljs-string">' LOGISTIC(Training set)'</span>)</span><br><span class="line">plt. xlabel(<span class="hljs-string">' Age'</span>)</span><br><span class="line">plt. ylabel(<span class="hljs-string">' Estimated Salary'</span>)</span><br><span class="line">plt. legend()</span><br><span class="line">plt. show()</span><br><span class="line"></span><br><span class="line">X_set,y_set=X_test,y_test</span><br><span class="line">X1,X2=np. meshgrid(np. arange(start=X_set[:,<span class="hljs-number">0</span>].min()<span class="hljs-number">-1</span>, stop=X_set[:, <span class="hljs-number">0</span>].max()+<span class="hljs-number">1</span>, step=<span class="hljs-number">0.01</span>),</span><br><span class="line">                   np. arange(start=X_set[:,<span class="hljs-number">1</span>].min()<span class="hljs-number">-1</span>, stop=X_set[:,<span class="hljs-number">1</span>].max()+<span class="hljs-number">1</span>, step=<span class="hljs-number">0.01</span>))</span><br><span class="line"></span><br><span class="line">plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(),X2.ravel()]).T).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="hljs-number">0.75</span>, cmap = ListedColormap((<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(),X1.max())</span><br><span class="line">plt.ylim(X2.min(),X2.max())</span><br><span class="line"><span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> enumerate(np. unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set==j,<span class="hljs-number">0</span>],X_set[y_set==j,<span class="hljs-number">1</span>],</span><br><span class="line">                c = ListedColormap((<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>))(i), label=j)</span><br><span class="line"></span><br><span class="line">plt. title(<span class="hljs-string">' LOGISTIC(Test set)'</span>)</span><br><span class="line">plt. xlabel(<span class="hljs-string">' Age'</span>)</span><br><span class="line">plt. ylabel(<span class="hljs-string">' Estimated Salary'</span>)</span><br><span class="line">plt. legend()</span><br><span class="line">plt. show()</span><br></pre></td></tr></table></figure><p><img src="/myphoto/output_12_0.png" alt="png"></p><p><img src="/myphoto/output_12_1.png" alt="png"></p>]]></content>
      
      
      <categories>
          
          <category> 数学与统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>沈向洋：You Are What You Write</title>
      <link href="/2018/03/03/you-are-what-you-write/"/>
      <url>/2018/03/03/you-are-what-you-write/</url>
      
        <content type="html"><![CDATA[<h2 id="You-Are-What-You-Write"><a href="#You-Are-What-You-Write" class="headerlink" title="You Are What You Write"></a>You Are What You Write</h2><p><em>原文：<a href="https://www.linkedin.com/pulse/you-what-write-harry-shum?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">https://www.linkedin.com/pulse/you-what-write-harry-shum?from=timeline&amp;isappinstalled=0</a></em></p><p>Are Twitter, PowerPoint, Facebook, Instagram and texting eroding our ability to think?</p><p>There is a Chinese proverb that says “见文如见人,” which literally means “reading the document is the same as seeing the author.” If we are what we write, then who have we, as a society, become?</p><p>I was sitting in a technical review recently, listening to one of our reviewers grill the engineer who was presenting: Why did you choose that design? Why is the service showing bad results? How many users will switch to the solution?</p><a id="more"></a> <p>The presenter’s answers lacked depth. It seemed like he hadn’t done enough rigorous thinking, the kind where you sit quietly, sift through research, contemplate options, determine what you know, don’t know and where more work is required. The kind of thinking I did as a young researcher when peers took me and my work apart when I took short cuts. Back then, I practiced a disciplined approach, spending hours just thinking, and even more hours on the hardest part—writing it down.</p><p>Today, long-form writing is being replaced. Tweets pass for dialogue. PowerPoint condenses thoughts to bullets. Words have been traded for emojis and GIFs. And we’ve become addicted to the noise. What happens in an Internet minute? 16 million text messages. 1.8 million snaps. 452,000 Tweets. 156 million emails. Who has time to think, let alone write?</p><p>And maybe we, in the technology industry, have shaped this reality. We created the phones, apps and 24/7-connected world. We’ve enabled society to put down the pen. The only writing I do today is email or quick WeChat posts.</p><p>So now I worry that we’re losing a valuable tool that helps us to think deeply, express who we are at our greatest and expand the intellect of those around us. And for us in the technical community, this is especially troubling. The stakes are higher than ever before with AI. We’re under enormous pressure to ship quickly, to achieve more, faster, but we can’t do this at the expense of the highest engineering quality. We have to think carefully about consequences and alternatives. Who gets blamed when a self-driving car hits someone? The engineer who wrote the code is the driver. Who is accountable for the AI algorithm with bias? The engineer who created the AI.</p><p>I see fewer engineers writing and sharing deep thinking, but this is what will lead to far more true innovation across the industry. How will we achieve the big transformative breakthroughs versus the incremental milestones?</p><p>By writing. Because the way to think is actually to write.</p><p>Putting pen to paper forces you to develop and refine your thinking by iterating, revising and exploring alternatives. Anyone who can think deeply can write beautiful code, inspiring papers or develop the plan to bring the next big thing to life. I encourage you to read Reid Hoffman’s Series B pitch for LinkedIn in which he shares the thinking that helped him succeed. At the time, he shares that a partner in a venture firm was exposed to around 5,000 pitches, looked more closely at 600 to 800, and did between 0 and 2 deals.</p><p>Writing offers the possibility to create lasting artifacts. I think of papers I published that endure, albeit perhaps as reference materials. Plenoptic Sampling. Lazy Snapping. Poisson Matting. These are my work’s contribution to the field of computer vision and graphics. They will survive me and, if I’m lucky, even help shape a mind or two.</p><p>One of my favorite professors at Carnegie Mellon, Takeo Kanade, said that you have to write research papers like detective novels. You need story, suspense, surprise and ‘aha’ to explain your ideas to peers, to inspire others to contribute and advance your work and the whole field.</p><p>Writing is an equalizer to get the best from the whole team. At Amazon, presentations are done with the six-page paper. Meetings kick off with everyone reading followed by comments and questions to the author. Everyone operates from the same context, and introverts, extroverts and non-native speakers have an equal chance to get their thinking across. It’s not about the presenter’s personality, but the words.</p><p>Ultimately, writing helps make you successful. You might be the smartest person with the best idea, but if you can’t communicate your thinking in a compelling way, you won’t get far. Two engineers in our AI+R team who inspire me with their regular writing habits are Bill Ramsey and Ronny Kohavi. Bill has written over 250 blog posts at Microsoft, benefitting our entire technical community. With Ronny, you don’t even need to meet him—his highly cited A/B test experimentation papers say it all, and he’s publishing for the benefit of the industry on LinkedIn.</p><p>As you’re reading this, you may be logging your objections: I need to drive results, so I need to go straight to code. I’m known for my code, so I don’t need to write papers. I’m not a native speaker, and I speak better with my code. I don’t know what to write about. I don’t have time… But please set them aside—for your own success, for your company’s, for the industry’s advancement—and start writing.</p><p>I see so many occasions for building long-form writing back into the engineering culture—planning documents, project proposals, technology LRP’s, review articles—to inspire us to work together, collectively creating and cultivating big ideas and big thinking.</p><p>I took a first step recently, writing a research paper with my colleagues Xiaodong He and Di Li, From Eliza to XiaoIce: Challenges and Opportunities with Social Chatbots, for the first time in years, so please no judgment, only constructive feedback!</p><p>I challenge everyone reading this piece to write 500 words per week. If you’ve got an idea or you see a problem, write your proposal and share it!</p><p>Let’s rewrite our standards for thought leadership and engineering quality by writing more!</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘抄 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWK简明教程</title>
      <link href="/2018/02/16/awk-jian-ming-jiao-cheng/"/>
      <url>/2018/02/16/awk-jian-ming-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<p>AWK是一种处理文本文件的语言，是一个强大的文本分析工具。之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。</p><a id="more"></a><h5 id="awk命令格式和选项"><a href="#awk命令格式和选项" class="headerlink" title="awk命令格式和选项"></a>awk命令格式和选项</h5><p>语法形式</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk [options] &apos;script&apos; var=value file(s)</span><br><span class="line">awk [options] -f scriptfile var=value file(s)</span><br></pre></td></tr></table></figure><p>常用命令选项</p><ul><li>-F fs   fs指定输入分隔符，fs可以是字符串或正则表达式，如-F:</li><li>-v var=value   赋值一个用户定义变量，将外部变量传递给awk</li><li>-f scripfile  从脚本文件中读取awk命令</li><li>-m[fr] val   对val值设置内在限制，-mf选项限制分配给val的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</li></ul><p><strong>工作原理</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hawk &apos;BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;&apos;</span><br></pre></td></tr></table></figure><h5 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h5><table><thead><tr><th>变量</th><th>详细说明</th></tr></thead><tbody><tr><td>$0</td><td>当前记录（这个变量中存放着整个行的内容）</td></tr><tr><td>$1~$n</td><td>当前记录的第n个字段，字段间由FS分隔</td></tr><tr><td>FS</td><td>输入字段分隔符 默认是空格或Tab (<strong>也可以是-F</strong>)</td></tr><tr><td>NF</td><td>当前记录中的字段个数，就是有多少列</td></tr><tr><td>NR</td><td>已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中。</td></tr><tr><td>FNR</td><td>当前记录数，与NR不同的是，这个值会是各个文件自己的行号</td></tr><tr><td>RS</td><td>输入的记录分隔符， 默认为换行符</td></tr><tr><td>OFS</td><td>输出字段分隔符， 默认也是空格</td></tr><tr><td>ORS</td><td>输出的记录分隔符，默认为换行符</td></tr><tr><td>FILENAME</td><td>当前输入文件的名字</td></tr></tbody></table><h5 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h5><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span> awk '$6 ~ /FIN|TIME/ || NR==1 &#123;print NR,$4,$5,$6&#125;' OFS="\t" netstat.txt</span><br></pre></td></tr></table></figure><h5 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h5><p>下面的命令计算所有的C文件，CPP文件和H文件的文件大小总和。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l  *.cpp *.c *.h | awk &apos;&#123;sum+=$5&#125; END &#123;print sum&#125;&apos;</span><br><span class="line">2511401</span><br></pre></td></tr></table></figure><p>统计每个用户的进程的占了多少内存</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span> ps aux | awk 'NR!=1&#123;a[$1]+=$6;&#125; END &#123; for(i in a) print i ", " a[i]"KB";&#125;'</span><br><span class="line">dbus, 540KB</span><br><span class="line">mysql, 99928KB</span><br><span class="line">www, 3264924KB</span><br><span class="line">root, 63644KB</span><br><span class="line">hchen, 6020KB</span><br></pre></td></tr></table></figure><p><strong>控制结构和脚本语言待补充</strong></p><p><strong>参考链接：</strong></p><p><a href="http://man.linuxde.net/awk" target="_blank" rel="noopener">http://man.linuxde.net/awk</a><br><a href="https://coolshell.cn/articles/9070.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9070.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> awk </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
