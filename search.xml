<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器学习笔记-----最小二乘法</title>
      <link href="/2019/05/19/ji-qi-xue-xi-bi-ji-zui-xiao-er-cheng-fa/"/>
      <url>/2019/05/19/ji-qi-xue-xi-bi-ji-zui-xiao-er-cheng-fa/</url>
      
        <content type="html"><![CDATA[<p><em>本文章转载自： <a href="https://www.cnblogs.com/pinard/" target="_blank" rel="noopener">刘建平Pinard</a>- <a href="https://www.cnblogs.com/pinard/p/5976811.html" target="_blank" rel="noopener">最小二乘法小结</a></em></p><p>最小二乘法是用来做函数拟合或者求函数极值的方法。在机器学习，尤其是回归模型中，经常可以看到最小二乘法的身影，这里就对我对最小二乘法的认知做一个小结。</p><a id="more"></a><h2 id="1-最小二乘法的原理与要解决的问题"><a href="#1-最小二乘法的原理与要解决的问题" class="headerlink" title="1.最小二乘法的原理与要解决的问题"></a>1.最小二乘法的原理与要解决的问题</h2><p>最小二乘法是由勒让德在19世纪发现的，原理的一般形式很简单，当然发现的过程是非常艰难的。形式如下式：<br>$$<br>    loss = \sum (f(x) - y )^2<br>$$</p><p>f(x)就是我们的多组样本，y就是我们的假设拟合函数。loss也就是在机器学习中常说的损失函数，我们的目标是得到使目标函数最小化时候的拟合函数的模型。举一个最简单的线性回归的简单例子，比如我们有m个只有一个特征的样本：</p><p>$$<br>(x^{(1)},y^{(1)}), (x^{(2)},y^{(2)}),…(x^{(m)},y^{(m)})<br>$$</p><p>样本采用下面的拟合函数：</p><p>$$<br>h_\theta(x) = \theta_0 + \theta_1 x<br>$$</p><p>这样我们的样本有一个特征x，对应的拟合函数有两个参数$\theta_0 和 \theta_1$需要求出。</p><p>我们的目标函数为：</p><p>$$<br>J(\theta_0, \theta_1) = \sum\limits_{i=1}^{m}(y^{(i)} - h_\theta(x^{(i)})^2<br>= \sum\limits_{i=1}^{m}(y^{(i)} -  \theta_0 - \theta_1 x^{(i)})^2<br>$$</p><p>用最小二乘法做什么呢，使$J(\theta_0, \theta_1)$最小，求出使$J(\theta_0,<br>\theta_1)$最小时的$\theta_0 和 \theta_1$，这样拟合函数就得出了。</p><p>那么，最小二乘法怎么才能使$J(\theta_0, \theta_1)$最小呢？</p><h2 id="2-最小二乘法的代数法解法"><a href="#2-最小二乘法的代数法解法" class="headerlink" title="2.最小二乘法的代数法解法"></a>2.最小二乘法的代数法解法</h2><p>上面提到要使$J(\theta_0, \theta_1)$最小，方法就是对$\theta_0$和$\theta_1$分别来求偏导数，令偏导数为0，得到一个关于$\theta_0 和\theta_1$的二元方程组。求解这个二元方程组，就可以得到$\theta_0$ 和 $\theta_1$的值。下面我们具体看看过程。</p><p>$J(\theta_0, \theta_1)$对$\theta_0$求导，得到如下方程：</p><p>①$$<br>\sum\limits_{i=1}^{m}(y^{(i)} -  \theta_0 - \theta_1 x^{(i)}) = 0<br>$$</p><p>$J(\theta_0, \theta_1)$对$\theta_1$求导，得到如下方程：<br>②$$<br>\sum\limits_{i=1}^{m}(y^{(i)} -  \theta_0 - \theta_1 x^{(i)})x^{(i)} = 0<br>$$</p><p>①和②组成一个二元一次方程组，容易求出$\theta_0$ 和 $\theta_1$的值：</p><p>$$<br>\theta_0 = \frac {\sum\limits_{i=1}^{m}\big(x^{(i)})^2\sum\limits_{i=1}^{m}y^{(i)}-\sum\limits_{i=1}^{m}x^{(i)}\sum\limits_{i=1}^{m}x^{(i)}y^{(i)}}{m\sum\limits_{i=1}^{m}\big(x^{(i)})^2 -\big(\sum\limits_{i=1}^{m}x^{(i)})^2}<br>$$</p><p>$$<br>\theta_1 = \frac {m\sum\limits_{i=1}^{m}x^{(i)}y^{(i)} -\sum\limits_{i=1}^{m}x^{(i)}\sum\limits_{i=1}^{m}y^{(i)}} {m\sum\limits_{i=1}^{m}\big(x^{(i)})^2 -\big(\sum\limits_{i=1}^{m}x^{(i)})^2}<br>$$</p><p>这个方法很容易推广到多个样本特征的线性拟合。</p><p>拟合函数表示为 $h_\theta(x_1, x_2, …x_n) = \theta_0 + \theta_{1}x_1 + … +\theta_{n}x_{n}$, 其中 $\theta_i$ (i = 0,1,2… n)为模型参数，$x_i $ (i =0,1,2… n)为每个样本的n个特征值。这个表示可以简化，我们增加一个特征$x_0 = 1$ ，这样拟合函数表示为：</p><p>$$<br>h_\theta(x_0,x_1, …x_n) = \sum\limits_{i=0}^{n} \theta_{i} x_{i}<br>$$</p><p>损失函数表示为：</p><p>$$<br>J(\theta_0, \theta_1…, \theta_n) = \sum\limits_{j=1}^{m}(h_\theta(x_0^{(j)}, x_1^{(j)}, …x_n^{(j)}) - y^{(j)})^2 = \sum\limits_{j=1}^{m}(\sum\limits_{i=0}^{n}(\theta_{i}x_{i}^{(j)}- y^{(j)}))^2<br>$$</p><p>利用损失函数分别对$\theta_i$(i=0,1,…n)求导,并令导数为0可得：</p><p>$$<br>\sum\limits_{j=0}^{m}(\sum\limits_{i=0}^{n}(\theta_{i}x_{i}^{(j)} -<br>y^{(j)})x_i^{(j)}) = 0 ,   (i=0,1,…n)<br>$$</p><p>这样我们得到一个N+1元一次方程组，这个方程组有N+1个方程，求解这个方程，就可以得到所有的N+1个未知的$\theta$</p><p>这个方法很容易推广到多个样本特征的非线性拟合。原理和上面的一样，都是用损失函数对各个参数求导取0，然后求解方程组得到参数值。这里就不累述了。</p><h2 id="3-最小二乘法的矩阵法解法"><a href="#3-最小二乘法的矩阵法解法" class="headerlink" title="3.最小二乘法的矩阵法解法"></a>3.最小二乘法的矩阵法解法</h2><p>矩阵法比代数法要简洁，且矩阵运算可以取代循环，所以现在很多书和机器学习库都是用的矩阵法来做最小二乘法。</p><p>这里用上面的多元线性回归例子来描述矩阵法解法。</p><p>假设函数$h_\theta(x_1, x_2, …x_n) = \theta_0 + \theta_{1}x_1 + … +\theta_{n-1}x_{n-1}$的矩阵表达方式为：</p><p>$$<br>h_\mathbf{\theta}(\mathbf{x}) = \mathbf{X\theta}<br>$$</p><p>其中，<br>假设函数$h_\mathbf{\theta}(\mathbf{X})$为mx1的向量,$\mathbf{\theta}$为nx1的向量，里面有n个代数法的模型参数。$\mathbf{X}$为mxn维的矩阵。m代表样本的个数，n代表样本的特征数。</p><p>损失函数定义为$J(\mathbf\theta) = \frac{1}{2}(\mathbf{X\theta} -\mathbf{Y})^T(\mathbf{X\theta} - \mathbf{Y})$</p><p>其中$\mathbf{Y}$是样本的输出向量，维度为$mx1$. $\frac{1}{2}$在这主要是为了求导后系数为1，方便计算。</p><p>根据最小二乘法的原理，我们要对这个损失函数对$\mathbf{\theta}$向量求导取0。结果如下式：</p><p>$$<br>\frac{\partial}{\partial\mathbf\theta}J(\mathbf\theta) =<br>\mathbf{X}^T(\mathbf{X\theta} - \mathbf{Y}) = 0<br>$$</p><p>这里面用到了矩阵求导链式法则，和两个个矩阵求导的公式。</p><p>公式1：$\frac{\partial}{\partial\mathbf{x}}(\mathbf{x^Tx})=2\mathbf{x}$, x为向量</p><p>公式2：$\nabla_Xf(AX+B) = A^T\nabla_Yf,;; Y=AX+B$, f(Y)为标量</p><p>对上述求导等式整理后可得：</p><p>$$<br>\mathbf{X^{T}X\theta} = \mathbf{X^{T}Y}<br>$$</p><p>两边同时左乘$(\mathbf{X^{T}X})^{-1}$可得：</p><p>$$ \mathbf{\theta} = (\mathbf{X^{T}X})^{-1}\mathbf{X^{T}Y} $$</p><p>这样我们就一下子求出了$\theta$向量表达式的公式，免去了代数法一个个去求导的麻烦。只要给了数据,我们就可以用$\mathbf{\theta} = (\mathbf{X^{T}X})^{-1}\mathbf{X^{T}Y}$算出$\theta$。</p><h2 id="4-最小二乘法的局限性和适用场景"><a href="#4-最小二乘法的局限性和适用场景" class="headerlink" title="4.最小二乘法的局限性和适用场景"></a>4.最小二乘法的局限性和适用场景</h2><p>从上面可以看出，最小二乘法适用简洁高效，比梯度下降这样的迭代法似乎方便很多。但是这里我们就聊聊最小二乘法的局限性。</p><ul><li><p>首先，最小二乘法需要计算$\mathbf{X^{T}X}$的逆矩阵，有可能它的逆矩阵不存在，这样就没有办法直接用最小二乘法了，此时梯度下降法仍然可以使用。当然，我们可以通过对样本数据进行整理，去掉冗余特征。让$\mathbf{X^{T}X}$的行列式不为0，然后继续使用最小二乘法。</p></li><li><p>第二，当样本特征n非常的大的时候，计算$\mathbf{X^{T}X}$的逆矩阵是一个非常耗时的工作（nxn的矩阵求逆），甚至不可行。此时以梯度下降为代表的迭代法仍然可以使用。那这个n到底多大就不适合最小二乘法呢？如果你没有很多的分布式大数据计算资源，建议超过10000个特征就用迭代法吧。或者通过主成分分析降低特征的维度后再用最小二乘法。</p></li><li><p>第三，如果拟合函数不是线性的，这时无法使用最小二乘法，需要通过一些技巧转化为线性才能使用，此时梯度下降仍然可以用。</p></li><li><p>第四，讲一些特殊情况。当样本量m很少，小于特征数n的时候，这时拟合方程是欠定的，常用的优化方法都无法去拟合数据。当样本量m等于特征数n的时候，用方程组求解就可以了。当m大于n时，拟合方程是超定的，也就是我们常用与最小二乘法的场景了。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学与统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生新基础知识-----sam-bam文件格式详解</title>
      <link href="/2019/05/18/sheng-xin-ji-chu-zhi-shi-sam-bam-wen-jian-ge-shi/"/>
      <url>/2019/05/18/sheng-xin-ji-chu-zhi-shi-sam-bam-wen-jian-ge-shi/</url>
      
        <content type="html"><![CDATA[<p><strong>SAM</strong>是一种序列比对格式标准，由sanger制定，是以TAB为分割符的文本格式。 主要应用于测序序列mapping到基因组上的结果表示，当然也可以表示任意的多重比对结果。 </p><p>SAM的全称是sequence alignment/map format</p><a id="more"></a><h5 id="定义和示例"><a href="#定义和示例" class="headerlink" title="定义和示例"></a>定义和示例</h5><p>SAM分为两部分，注释信息（header section ）和比对结果部分 （alignment section）。 通常是把FASTQ文件格式的测序数据比对到对应的参考基因组版本得到的。 注释信息并不是SAM文件的重点，是该SAM文件产生以及被处理过程的一个记录，规定以@开头，用不同的tag表示不同的信息，主要有：</p><ul><li>@HD，说明符合标准的版本、对比序列的排列顺序；</li><li>@SQ，参考序列说明；</li><li>@RG，比对上的序列（read）说明；</li><li>@PG，使用的程序说明；</li><li>@CO，任意的说明信息。<br>一个简单的SAM文件例子如下：</li></ul><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ST-E00317:118:HNHK2CCXX:7:1101:5071:130997chr119669566660147Mchr18548067150AAGAATATGGACACAGTGAAGTGGTGGAATATTATTGCAATCCTAGATTTCTAATGAAGGGACCTAATAAAATTCAGTGTGTTGATGGAGAGTGGACAACTTTACCAGTGTGTATTTGTAATGTATAAAACATTAATATTGAAACTTFFAKKKKKKFKKKKKK,FKKKKKKK&lt;KKKFKK,FKKKKKKKKKFFKKKKKFFKKFAKFK,FKKKAKKKKKKKKKKKAF,,,FFAFA,FKKAKAA7FKKFKFFFKKKK7FFKK7F7K,7FAFKAFFKKKKK,7AFKFKFA,,,AAK,AMC:Z:13S134MMD:Z:76A39G13T9T6RG:Z:sampleIDNM:i:4AS:i:127XS:i:21</span><br></pre></td></tr></table></figure><p>说明如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">QNAME   ST-E00317:118:HNHK2CCXX:7:1101:5071:1309      </span><br><span class="line">## read名称</span><br><span class="line">FLAG    97  </span><br><span class="line">##  FLAG, 概括出一个合适的标记，各个数字分别代表</span><br><span class="line">##1    序列是一对序列中的一个</span><br><span class="line">##2    比对结果是一个pair-end比对的末端</span><br><span class="line">##4    没有找到位点</span><br><span class="line">##8    这个序列是pair中的一个但是没有找到位点</span><br><span class="line">##16   在这个比对上的位点，序列与参考序列反向互补</span><br><span class="line">##32   这个序列在pair-end中的的mate序列与参考序列反响互补</span><br><span class="line">##64   序列是 mate 1</span><br><span class="line">##128  序列是 mate 2</span><br><span class="line">##假如说标记为以上列举出的数目，就可以直接推断出匹配的情况。假如说标记不是以上列举出的数字，比如说83=（64+16+2+1），就是这几种情况值和。</span><br><span class="line">##　其他情况可参见 http://broadinstitute.github.io/picard/explain-flags.html</span><br><span class="line">RNAME  chr1 </span><br><span class="line">## 染色体名称</span><br><span class="line">POS 196695666   </span><br><span class="line">## 染色体位置</span><br><span class="line">MAQ 60  </span><br><span class="line">## mapping质量 越高说明位点越独特</span><br><span class="line">CIGAR   147M </span><br><span class="line">## “M”表示 match或 mismatch；</span><br><span class="line">## “I”表示 insert；</span><br><span class="line">## “D”表示 deletion；</span><br><span class="line">## “N”表示 skipped（跳过这段区域）；</span><br><span class="line">## “S”表示 soft clipping（被剪切的序列存在于序列中）；</span><br><span class="line">## “H”表示 hard clipping（被剪切的序列不存在于序列中）；</span><br><span class="line">## “P”表示 padding；</span><br><span class="line">## “=”表示 match；</span><br><span class="line">## “X”表示 mismatch（错配，位置是一一对应的）；</span><br><span class="line">MRNM    chr18</span><br><span class="line">## read2 在参考序列上的位置，如果没有就用 &quot;*&quot;, 相同&quot;=&quot;</span><br><span class="line">MPOS    0 </span><br><span class="line">##read2 的位置，若不可用则用0</span><br><span class="line">ISIZE   0</span><br><span class="line">## 插入片段的长度，最左边得为正，最右边的为负，中间的不用定义正负，不分区段（single-segment)的比对上，或者不可用时，此处为0</span><br><span class="line">SEQ AAGAATATGGACACAGTGAAGTGGTGGAATATTATTGCAATCCTAGATTTCTAATGAAGGGACCTAATAAAATTCAGTGTGTTGATGGAGAGTGGACAACTTTACCAGTGTGTATTTGTAATGTATAAAACATTAATATTGAAACTT</span><br><span class="line">##　序列片段的序列信息</span><br><span class="line">QUAL    FFAKKKKKKFKKKKKK,FKKKKKKK&lt;KKKFKK,FKKKKKKKKKFFKKKKKFFKKFAKFK,FKKKAKKKKKKKKKKKAF,,,FFAFA,FKKAKAA7FKKFKFFFKKKK7FFKK7F7K,7FAFKAFFKKKKK,7AFKFKFA,,,AAK,A</span><br><span class="line">## 序列的质量信息，格式同FASTQ一样。read质量的ASCII编码</span><br><span class="line">MC:Z:13S134M    MD:Z:76A39G13T9T6       RG:Z:sampleID   NM:i:4  AS:i:127        XS:i:21</span><br><span class="line">## 可选字段（optional fields)，格式如：TAG:TYPE:VALUE，其中TAG有两个大写字母组成，每个TAG代表一类信息，每一行一个TAG只能出现一次，TYPE表示TAG对应值的类型，可以是字符串、整数、字节、数组等。</span><br><span class="line">## AS:i 最佳匹配的得分</span><br><span class="line">## XS:i 第二好的匹配的得分</span><br><span class="line">## YS:i mate 序列匹配的得分</span><br><span class="line">## XN:i 在参考序列上模糊碱基的个数</span><br><span class="line">## XM:i 错配的个数</span><br><span class="line">## XO:i gap open的个数</span><br><span class="line">## XG:i gap 延伸的个数</span><br><span class="line">## NM:i 经过编辑的序列 </span><br><span class="line">## YF:i 说明为什么这个序列被过滤的字符串</span><br><span class="line">## YT:Z</span><br><span class="line">## MD:Z 代表序列和参考序列错配的字符串</span><br><span class="line">##</span><br></pre></td></tr></table></figure><p><strong>参考链接</strong>：</p><ol><li><a href="https://en.wikipedia.org/wiki/SAM_(file_format)" target="_blank" rel="noopener">SAM(file format)</a>(可下载PDF文件)</li><li><a href="https://genome.sph.umich.edu/wiki/SAM#What_are_TAGs.3F" target="_blank" rel="noopener">https://genome.sph.umich.edu/wiki/SAM#What_are_TAGs.3F</a></li><li><a href="https://mp.weixin.qq.com/s/yK1OyJHrePg6bWl41JCpvA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/yK1OyJHrePg6bWl41JCpvA</a></li><li><a href="http://www.cnblogs.com/emanlee/p/5366610.html" target="_blank" rel="noopener">http://www.cnblogs.com/emanlee/p/5366610.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 生信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生信基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生信基础知识-----fastq文件格式详解</title>
      <link href="/2019/05/18/sheng-xin-ji-chu-zhi-shi-fastq-wen-jian-ge-shi/"/>
      <url>/2019/05/18/sheng-xin-ji-chu-zhi-shi-fastq-wen-jian-ge-shi/</url>
      
        <content type="html"><![CDATA[<p><strong>FASTQ格式</strong>是一种保存生物序列（通常为核酸序列）及其测序质量得分信息的文本格式。序列与质量得分皆由单个ASCII字符表示。</p><p><strong>格式</strong></p><p>FASTQ格式通常每个序列使用四行：</p><ul><li>第一行以“@”字符开头，后面是序列标识符和其他描述。</li><li>第二行是序列</li><li>第三行以“+”也是序列标识符和描述（可选）</li><li>第四行是序列的质量得分信息，与第二行的碱基一一对应</li></ul><a id="more"></a><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@A00262:122:H5FW3DSXX:3:1101:1561:1031 1:N:0:CCGTGAGA</span><br><span class="line">CNACCCCAAAAATGCTTTTGAAATCCTGAGATGTGATCAGTGAAATATGCAGCCAAGGCAAGGGGAAACTGTCCGCAAGTTAAAAAGATTTATTGCTATTCCAGGCTTCAAATGAGCCCAGAACTCAGGGCTGGTGTGTGTTTCAGAAGT</span><br><span class="line">+</span><br><span class="line">F#FFFFFFFFFFFFFFFFFFFFFFFFFFFFF,F:FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:FFFFFFFFF:FFFFFFFFFFFFFFFFFFF:FFFFFFFFFF:FFFFFFFFFFF:FF,FFFFF:FFFFFFF</span><br></pre></td></tr></table></figure><p><strong>Illumina 测序仪标识符</strong></p><table><thead><tr><th align="center">A00262</th><th align="center">测序仪编号</th></tr></thead><tbody><tr><td align="center">122</td><td align="center">运行id</td></tr><tr><td align="center">H5FW3DSXX</td><td align="center">flowcell id</td></tr><tr><td align="center">3</td><td align="center">lane 编号</td></tr><tr><td align="center">1101</td><td align="center">tile编号</td></tr><tr><td align="center">1561</td><td align="center">tile x坐标</td></tr><tr><td align="center">1031</td><td align="center">tile y坐标</td></tr><tr><td align="center">1</td><td align="center">单端测序为1，双端为2</td></tr><tr><td align="center">N</td><td align="center">Y过滤reads(reads质量较差),否则为N</td></tr></tbody></table><blockquote><p><strong>ps</strong>: 每个flowcell有8个泳道，一个泳道称为一个Lane，每条Lane上有两列，每列有多个有小格子，叫一个tile。(见下图)</p></blockquote><blockquote><p><img src="/myphoto/flowcell.jpg" alt="flowcell"></p></blockquote><p><strong>质量评分</strong></p><p>第四行表示序列的质量值,用<a href="https://en.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">ACSII码</a>表示。<br>测序仪一般是按照荧光信号来判断所测序的碱基是哪一种的，例如红黄蓝绿分别对应ATCG，因此对每个结果的判断都是一个概率的问题：</p><table><thead><tr><th align="center">Phred Quality Score(Q值)</th><th align="center">错误率</th><th align="center">碱基准确率</th></tr></thead><tbody><tr><td align="center">10</td><td align="center">0.1</td><td align="center">90%</td></tr><tr><td align="center">20</td><td align="center">0.01</td><td align="center">99%</td></tr><tr><td align="center">30</td><td align="center">0.001</td><td align="center">99.9%</td></tr><tr><td align="center">40</td><td align="center">0.0001</td><td align="center">99.99%</td></tr><tr><td align="center">50</td><td align="center">0.00001</td><td align="center">99.999%</td></tr></tbody></table><p>一般都是以Q值来衡量read碱基质量，Sanger中心用的换算公式如下，其中P为错误率，</p><p>$$Q=-10logP $$</p><p>Solexa系列测序仪使用不同的公示来计算质量值：$Q=-10log(P/1-P)$<br>不同的测序平台Q值所能表示的范围不一样，因此要想用对应的ACSII编码，必须加上一个数值(33或者64)<br>以上面的那条Illumina测序仪产生的read为例，<code>F</code>对应的十进制数是70，Q值就是36，也就是说这个碱基的准确率在99.99%以上</p><blockquote><p><em>转载请注明出处</em></p></blockquote><p><strong>参考链接:</strong></p><ul><li><a href="http://boyun.sh.cn/bio/?p=1901" target="_blank" rel="noopener">http://boyun.sh.cn/bio/?p=1901</a></li><li><a href="https://en.wikipedia.org/wiki/FASTQ_format" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/FASTQ_format</a></li><li><a href="https://blog.csdn.net/godsunshine/article/details/51946314" target="_blank" rel="noopener">https://blog.csdn.net/godsunshine/article/details/51946314</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 生信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生信基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记-----数据预处理</title>
      <link href="/2019/05/17/ji-qi-xue-xi-bi-ji-shu-ju-yu-chu-li/"/>
      <url>/2019/05/17/ji-qi-xue-xi-bi-ji-shu-ju-yu-chu-li/</url>
      
        <content type="html"><![CDATA[<p>数据预处理是机器学习中非常重要的步骤，为了能正确的分析数据，得到最佳的机器学习算法，拿到数据后我们一般来说都需要对数据进行预处理。数据预处理包括以下几个步骤：</p><ul><li>导入需要的库</li><li>导入数据集</li><li>处理丢失数据</li><li>解析分类数据</li><li>拆分数据集分成训练集合和测试集合</li><li>特征缩放</li></ul><a id="more"></a><p><img src="/myphoto/ML-1.png" alt="ML-1"></p><p><em>图片来源与github项目<a href="https://github.com/MLEveryday/100-Days-Of-ML-Code" target="_blank" rel="noopener">机器学习100天中文翻译</a>, 喜欢的可以去点个star哦</em></p><h2 id="1-导入库"><a href="#1-导入库" class="headerlink" title="1. 导入库"></a>1. 导入库</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd</span><br></pre></td></tr></table></figure><h2 id="2-导入数据集"><a href="#2-导入数据集" class="headerlink" title="2. 导入数据集"></a>2. 导入数据集</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dataset = pd.read_csv(<span class="hljs-string">r'E:\Downloads\100-Days-Of-ML-Code-master\100-Days-Of-ML-Code-master\datasets\Data.csv'</span>)</span><br><span class="line">X = dataset.iloc[ : , :<span class="hljs-number">-1</span>].values <span class="hljs-comment"># loc 表示标签索引行数据</span></span><br><span class="line">Y = dataset.iloc[ : , <span class="hljs-number">-1</span>].values <span class="hljs-comment"># iloc 表示按照行号号索引</span></span><br><span class="line">print(Y)</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;No&apos; &apos;Yes&apos; &apos;No&apos; &apos;No&apos; &apos;Yes&apos; &apos;Yes&apos; &apos;No&apos; &apos;Yes&apos; &apos;No&apos; &apos;Yes&apos;]</span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataset</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CountryAgeSalaryPurchased</span><br><span class="line">France4472000No</span><br><span class="line">Spain2748000Yes</span><br><span class="line">Germany3054000No</span><br><span class="line">Spain3861000No</span><br><span class="line">Germany40Yes</span><br><span class="line">France3558000Yes</span><br><span class="line">Spain52000No</span><br><span class="line">France4879000Yes</span><br><span class="line">Germany5083000No</span><br><span class="line">France3767000Yes</span><br></pre></td></tr></table></figure><h2 id="3-处理丢失数据"><a href="#3-处理丢失数据" class="headerlink" title="3. 处理丢失数据"></a>3. 处理丢失数据</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> Imputer</span><br><span class="line"><span class="hljs-comment"># axis=0表示按列的平均值进行填充</span></span><br><span class="line">imputer = Imputer(missing_values = <span class="hljs-string">"NaN"</span>, strategy = <span class="hljs-string">"mean"</span>, axis = <span class="hljs-number">0</span>)</span><br><span class="line">imputer = imputer.fit(X[ : , <span class="hljs-number">1</span>:<span class="hljs-number">3</span>]) <span class="hljs-comment"># 处理缺失值</span></span><br><span class="line">X[ : , <span class="hljs-number">1</span>:<span class="hljs-number">3</span>] = imputer.transform(X[ : , <span class="hljs-number">1</span>:<span class="hljs-number">3</span>]) <span class="hljs-comment"># 转换</span></span><br><span class="line">X</span><br></pre></td></tr></table></figure><p>上述代码使用的是样本的平均值来代替缺失值, 也可以使用中位数、众数，接口详细信息参见<code>help(Imputer)</code></p><h2 id="4-解析分类数据"><a href="#4-解析分类数据" class="headerlink" title="4. 解析分类数据"></a>4. 解析分类数据</h2><p><strong>为什么要独热编码？</strong></p><p>使用one-hot编码，将离散特征的取值扩展到了欧式空间，离散特征的某个取值就对应欧式空间的某个点。将离散型特征使用one-hot编码，会让特征之间的距离计算更加合理。  </p><p><strong>为什么特征向量要映射到欧式空间？</strong></p><p>将离散特征通过one-hot编码映射到欧式空间，是因为，在回归，分类，聚类等机器学习算法中，特征之间距离的计算或相似度的计算是非常重要的，而我们常用的距离或相似度的计算都是在欧式空间的相似度计算，计算余弦相似性，基于的就是欧式空间</p><p>关于<a href="https://www.cnblogs.com/king-lps/p/7846414.html" target="_blank" rel="noopener">OneHotEncoder独热编码和 LabelEncoder标签编码</a></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> LabelEncoder, OneHotEncoder</span><br><span class="line">labelencoder_X = LabelEncoder() <span class="hljs-comment"># 对与不连续的变量进行编号</span></span><br><span class="line">X[ : , <span class="hljs-number">0</span>] = labelencoder_X.fit_transform(X[ : , <span class="hljs-number">0</span>])</span><br><span class="line"><span class="hljs-comment">#Creating a dummy variable</span></span><br><span class="line">onehotencoder = OneHotEncoder(categorical_features = [<span class="hljs-number">0</span>]) <span class="hljs-comment"># 进行虚位掩码</span></span><br><span class="line">X = onehotencoder.fit_transform(X).toarray()</span><br><span class="line">labelencoder_Y = LabelEncoder()</span><br><span class="line">Y =  labelencoder_Y.fit_transform(Y)</span><br><span class="line">print(Y)</span><br><span class="line">print(X[:,<span class="hljs-number">0</span>])</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0 1 0 0 1 1 0 1 0 1]</span><br><span class="line">[0. 1. 1. 1. 1. 0. 1. 0. 1. 0.]</span><br></pre></td></tr></table></figure><h2 id="5-拆分数据集分成训练集合和测试集合"><a href="#5-拆分数据集分成训练集合和测试集合" class="headerlink" title="5. 拆分数据集分成训练集合和测试集合"></a>5. 拆分数据集分成训练集合和测试集合</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 训练集和测试集</span></span><br><span class="line"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, Y_train, Y_test = train_test_split( X , Y , test_size = <span class="hljs-number">0.2</span>, random_state = <span class="hljs-number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>关于怎么拆分数据集</strong></p><p>拆分数据的目的是对模型进行评估，如果给定的样本数据充足，进行模型选择的一种简单方法是随机地将数据集切分成三部分，分别为<strong>训练集（training set）</strong>、<strong>验证集</strong>（validation set）和<strong>测试集（test set）</strong>, 比例一般是 6:2:2</p><p>但是，在许多实际应用中数据是不充足的。为了选择好的模型，可以采用交叉验证方法。</p><p><strong>交叉验证</strong>的基本想法是重复地使用数据；把给定的数据进行切分，将切分的数据集组合为训练集与测试集，在此基础上反复地进行训练、测试以及模型选择。一般有 <strong>简单交叉验证， S折交叉验证， 留一交叉验证</strong>等方法</p><p><em>我们会在《模型评估与模型选择》一节在进行详细描述</em></p><h2 id="6-特征缩放"><a href="#6-特征缩放" class="headerlink" title="6. 特征缩放"></a>6. 特征缩放</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 标准化</span></span><br><span class="line"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler</span><br><span class="line">sc_X = StandardScaler()</span><br><span class="line">X_train = sc_X.fit_transform(X_train) <span class="hljs-comment"># fit_transform 先训练数据得到方差期望等信息，再进行缩放</span></span><br><span class="line">X_test = sc_X.transform(X_test) <span class="hljs-comment"># transform直接进行数据缩放，用的是X_train的方差和期望</span></span><br></pre></td></tr></table></figure><p><strong>关于特征缩放</strong></p><p>特征缩放就是将所有的特征分布转成成同一数量级，示例数据中的年龄与薪水的方差、均值等分布特征相差很大，这样会导致年龄对模型的影响会很小，其实就是均一化。</p><p><code>sklearn</code>特征缩放<code>StandardScaler</code> 的计算公式:</p>$$  x_{stand} = \frac {x-mean(x)} {std} $$ <p>特征缩放的更多介绍:<br><a href="https://www.cnblogs.com/chaosimple/p/4153167.html" target="_blank" rel="noopener">关于使用sklearn进行数据预处理 —— 归一化/标准化/正则化</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://www.leafw.cn/2019/01/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0a-z%EF%BD%9E%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/" target="_blank" rel="noopener">机器学习A-Z～数据预处理</a></li><li><a href="https://github.com/MLEveryday/100-Days-Of-ML-Code" target="_blank" rel="noopener">机器学习100天</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数学与统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记-----线性回归</title>
      <link href="/2019/05/17/ji-qi-xue-xi-bi-ji-xian-xing-hui-gui/"/>
      <url>/2019/05/17/ji-qi-xue-xi-bi-ji-xian-xing-hui-gui/</url>
      
        <content type="html"><![CDATA[<h2 id="线性模型的基本形式"><a href="#线性模型的基本形式" class="headerlink" title="线性模型的基本形式"></a>线性模型的基本形式</h2><p>给定由d 个属性描述的示例$\vec x = (x_1,x_2,…x_d)$ ， 其中$x_i$是x在第i个属性上的取值，线性模型(linear model)试图学得一个通过属性的线性组合来进行预测的函数，即<br>公式（1）：<br>$$ f(\vec x) = \omega_1 x_1 + \omega_2 x_2 +\cdots + \omega_d x_d+d + b  $$ </p><p>写成向量式，公式（2）：<br>$$ f(\vec x) = \vec\omega^T \vec x  $$</p><a id="more"></a><p>这里的</p>$$\vec\omega^T = [\omega_1,\omega_2,\cdots,\omega_n]$$$$\vec x = \left[\begin{matrix}x_1 \\x_2 \\\cdots\\x_{n-1}\\1\end{matrix} \right]$$<p>式(2)是单个样本的模型，如果是多个样本，那么:</p>$$X = \left[\begin{matrix}x_1^{(1)} \ x_2^{(1)} \ x_1^{(1)} \ \cdots \ x_{n-1}^{(1)} \ 1 \\x_1^{(2)} \ x_2^{(2)} \ x_3^{(2)} \ \cdots \ x_{n-1}^{(2)} \ 1 \\x_1^{(3)} \ x_2^{(3)} \ x_3^{(3)} \ \cdots \ x_{n-1}^{(3)} \ 1 \\\cdots \\x_1^{(m)} \ x_2^{(m)} \ x_3^{(m)} \ \cdots \ x_{n-1}^{(m)} \ 1\end{matrix} \right] = \left[\begin{matrix}\vec x^{(1)T} \ 1 \\\vec x^{(2)T} \ 1 \\\vec x^{(3)T} \ 1 \\\cdots \\\vec x^{(m)T} \ 1 \\\end{matrix} \right]$$<p>因此多变量线性回归的公式就变成：</p><p>$$f(x)= X^T \vec\omega $$</p><h2 id="线性回归原理"><a href="#线性回归原理" class="headerlink" title="线性回归原理"></a>线性回归原理</h2><p>给定数据集$D = {(\vec x_1 ,y_1),(\vec x_2,y_2),\cdots,(\vec x_m,y_m)}$,线性回归就是使用$\vec x$得到一个线性模型是的输出$y’$ 无限接近与$y$，即：</p><p>公式（3）<br>$$f(\vec x ) = \vec\omega^T \vec x \simeq y $$<br>这里忽略了下标，即每一个输入$\vec x$ 通过线性回归模型的式子$(3)$得到的$y$ 都无限接近与数据集中的$y$</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>那么如何确定公式$(3)$中的$\vec\omega$呢?</p><p>如果我们的$f(x)$ 与$y$的差别足够小，那么我们就可以带入到公式$(3)$中直接解出$\vec\omega$和$b$来:</p><p>$$min\sum|f(x)-y|$$</p><p>而在实际运用过程中我们一般用平方误差来做性能度量，公式（4）：</p><p>$$min \sum(f(x)-y)^2 $$</p><p>当然也有其他的性能度量方式，只是平方误差这个在线性回归中最常用，这个求解线性回归参数的方法也叫做<strong>最小二乘法</strong><br>令：</p><p>公式（5）<br>$$J (\omega) = \sum(f(x)-y)^2 $$</p><p>$J(\omega)$在这里就叫做<strong>代价函数</strong>,吴恩达老师的机器学习课程中稍做了调整：</p><p>$$J(\omega) = \frac{1}{2m} \sum_{i=1}^m (f(x)-y)^2 $$</p><p>写成向量形式就是：<br>$$<br>J(\mathbf\omega) = \frac{1}{2}(\mathbf{X\vec\omega} -\mathbf{Y})^T(\mathbf{X\vec\omega} - \mathbf{Y})<br>$$</p><p>*<u>至于为什么加了1/2是因为在损失函数求导的过程中可以消去2，而1/m为了减少数据量对梯度的影响</u>*</p><p>我们只需要对$J(\omega)$求偏导就能够求得最小值，这里假设$J(\omega)$是<strong>凸函数</strong></p><h2 id="代价函数最小值"><a href="#代价函数最小值" class="headerlink" title="代价函数最小值"></a>代价函数最小值</h2><p>求最小值可以使用梯度下降法，在这之前，我们先讲如何直接解出$J(\omega)$的最小值：</p><h3 id="求导法"><a href="#求导法" class="headerlink" title="求导法"></a>求导法</h3><p><img src="/myphoto/ml1.png" alt=""></p><h3 id="矩阵法"><a href="#矩阵法" class="headerlink" title="矩阵法"></a>矩阵法</h3><p><img src="/myphoto/ml2.png" alt=""><br><img src="/myphoto/ml3.png" alt=""></p><p>显然这种方法比较复杂，而且逆矩阵也不一定存在，,貌似计算量也很大</p><p>下面讲另一种求解$J(\omega)$最小值的方式，</p><h3 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a><strong>梯度下降法</strong></h3><p>该方法的核心思想是同步更新$\vec\omega$中每个值：</p><p><code>for j in: len(w):</code><br>$$<br>\omega_j = \omega_j -\alpha \sum_{i=1}^m \frac{\partial J(\omega) }{\partial \omega_j}<br>$$</p><p>$\alpha$ 称作<strong>学习率</strong>,它的值太小会增加求解的时间，太大会容易造成过拟合。<br>该方法像是一种穷举，一步一步的找到最小值。<br>关于这种方法的实现我们将会在逻辑回归中演示，下面讲一下Scikit-Learn关于线性回归的用法。</p><h2 id="LinearRegression"><a href="#LinearRegression" class="headerlink" title="LinearRegression"></a>LinearRegression</h2><p><a href="http://cwiki.apachecn.org/pages/viewpage.action?pageId=12681716" target="_blank" rel="noopener">参考sklearn的官方文档中文版</a></p><p><code>linear_model.LinearRegression</code>类的成员函数 <code>fit</code> 以数组X和y为输入，并将线性模型的系数$\omega$存储在其成员变量<code>coef_</code> 中：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> linear_model</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>reg = linear_model.LinearRegression()</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>reg.fit ([[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>]], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])</span><br><span class="line">LinearRegression(copy_X=<span class="hljs-keyword">True</span>, fit_intercept=<span class="hljs-keyword">True</span>, n_jobs=<span class="hljs-number">1</span>, normalize=<span class="hljs-keyword">False</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>reg.coef_</span><br><span class="line">array([ <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>])</span><br></pre></td></tr></table></figure><blockquote><p>然而，最小二乘的系数估计依赖于模型特征项的独立性。当特征项相关并且设计矩阵X 的列近似的线性相关时，设计矩阵便接近于一个奇异矩阵(不是满秩，列数过多，会有多个最优解，需要<strong>正则化</strong>)，因此最小二乘估计对观测点中的随机误差变得高度敏感，产生大的方差。</p></blockquote><h2 id="手动实现线性回归"><a href="#手动实现线性回归" class="headerlink" title="手动实现线性回归"></a>手动实现线性回归</h2><p>这里我们使用矩阵方法求参数</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd</span><br><span class="line"><span class="hljs-keyword">import</span> matplotlib</span><br><span class="line"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line">boston = datasets.load_boston()</span><br><span class="line">X = boston.data</span><br><span class="line">Y = boston.target</span><br><span class="line"></span><br><span class="line">X = X[Y &lt; <span class="hljs-number">50.0</span>]</span><br><span class="line">Y = Y[Y &lt; <span class="hljs-number">50.0</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split </span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size = <span class="hljs-number">0.25</span>, random_state = <span class="hljs-number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># print(X.shape)</span></span><br><span class="line"><span class="hljs-comment"># print(Y.shape)</span></span><br><span class="line"><span class="hljs-comment"># (490, 13)</span></span><br><span class="line"><span class="hljs-comment"># (490,)</span></span><br><span class="line"><span class="hljs-comment"># 加一列截距</span></span><br><span class="line">X_train_b = np.insert(X_train,<span class="hljs-number">0</span>,values=<span class="hljs-number">1</span>,axis=<span class="hljs-number">1</span>)</span><br><span class="line">X_test_b = np.insert(X_test,<span class="hljs-number">0</span>,values=<span class="hljs-number">1</span>,axis=<span class="hljs-number">1</span>)</span><br><span class="line"><span class="hljs-comment"># print(y_train.shape)</span></span><br><span class="line">y_train_b = y_train.reshape(y_train.shape[<span class="hljs-number">0</span>],<span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">theta = np.linalg.inv(X_train_b.T.dot(X_train_b)).dot(X_train_b.T).dot(y_train_b)</span><br><span class="line">print(theta)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 使用sklearn</span></span><br><span class="line"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> linear_model</span><br><span class="line">reg = linear_model.LinearRegression()</span><br><span class="line">reg.fit(X,Y)</span><br><span class="line">print(reg.intercept_)</span><br><span class="line">print(reg.coef_)</span><br><span class="line"><span class="hljs-comment"># print(dir(reg))</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学与统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记-----Logistic回归</title>
      <link href="/2019/01/23/ji-qi-xue-xi-bi-ji-logistic-hui-gui/"/>
      <url>/2019/01/23/ji-qi-xue-xi-bi-ji-logistic-hui-gui/</url>
      
        <content type="html"><![CDATA[<p>Logistic回归,有翻译为“逻辑回归”，但是它跟“逻辑”这个单词一点关系都没有，也不是解决回归问题的，是用来解决二分类的算法，最准确的翻译应该是“对数几率回归”</p><p>至于为什么叫对数几率刚回归，请看下面的推倒过程</p><a id="more"></a> <h2 id="线性回归回顾"><a href="#线性回归回顾" class="headerlink" title="线性回归回顾"></a>线性回归回顾</h2><p>先来看一个简单的线性回归模型：</p><p>$$ f(x) = \vec\omega^T \vec{x}+b  $$<br>这里的</p><p>$$ \vec\omega^T = [\omega_1,\omega_2,\cdots,\omega_n] $$</p>$$ \vec x  = \left[\begin{matrix}x_1 \\x_2  \\\cdots\\x_n  \end{matrix} \right] $$<p>一般来说给定的数据集是：$D={(\vec x^{(1)},y^{(1)}),(\vec x^{(2)},y^{(2)}),⋯,(\vec x^{(m)},y^{(m)})}$, 即有m组数据，n个未知数，因此多变量线性回归的公式是：</p><p>$$f(x)= X^T \vec\omega $$</p><p>其中：</p>$$X = \left[\begin{matrix}x_1^{(1)} \   x_2^{(1)} \ x_1^{(1)} \ \cdots \ x_n^{(1)} \ 1 \\x_1^{(2)} \   x_2^{(2)} \ x_3^{(2)} \ \cdots \ x_n^{(2)} \ 1 \\x_1^{(3)} \   x_2^{(3)} \ x_3^{(3)} \ \cdots \ x_n^{(3)} \ 1 \\\cdots \\x_1^{(m)} \   x_2^{(m)} \ x_3^{(m)} \ \cdots \ x_n^{(m)} \ 1 \end{matrix} \right] =  \left[\begin{matrix}\vec x^{(1)T} \ 1 \\\vec x^{(2)T} \ 1 \\\vec x^{(3)T} \ 1 \\\cdots \\\vec x^{(m)T} \ 1 \\\end{matrix} \right]$$<p>展开式：</p><p>$$\omega_1 x_1^{(1)} + \omega_2 x_2^{(1)} + \cdots + \omega_n x_n^{(1)} +b = y^{(1)} $$</p><p>$$\omega_1 x_1^{(2)} + \omega_2 x_2^{(2)} + \cdots + \omega_n x_n^{(2)} + b = y^{(2)}$$</p><p>$$\cdots$$</p><p>$$\omega_1 x_1^{(m)} + \omega_2 x_2^{(m)} + \cdots + \omega_n x_n^{(m)} +b = y^{(m)}$$</p><p>我们为了便于推导，忽略了下标，只用了一组$(\vec{x},y)$,然后把$b$当做$\omega_0$，而此时$x_0 = 1$：</p><p>$$f(x)=\vec\omega^T \vec{x} $$</p><h2 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h2><p>线性回归很显然是一个连续的值，既然要解决二分类的问题，那最好是换成一个$0/1$的值</p><p>这里引出一个sigmoid函数：<br>$$g(z) = \frac {1}{1+e^{-z}}$$</p><p><img src="/myphoto/logtic.png" alt="logtic"></p><p>令：</p><p>$$z =\vec\omega^T \vec{x}+b $$</p><p>$$f(x) = g(z) = \frac {1}{1+e^{-\vec\omega^T \vec{x}}} $$</p><p>我们就引出了我们的模型：</p><p>$$ln \frac{y}{1-y} =  \vec\omega^T \vec{x}+b $$</p><p>上式中$\frac{y}{1-y}$ 称为几率，反应x获得正例(y)的相对可能性，由此可以看出，模型实际上是在用线性回归模型的预测结果去逼近真实值$y$的对数几率，因此该模型就称为<strong>对数几率回归模型</strong></p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>由于$y$的值为0,1，我们将$y$视为后验概率：</p><p>$$p(y=1 |  x;\omega) = f(x) $$</p><p>$$p(y=0 |  x;\omega) = 1- f(x) $$</p><p>$f(x)$越大，代表着预测值与$y$越接近，误差就越小，带入到公式中：</p><p>$$p(y=1 |  x;\omega) = \frac {e^{\vec\omega^T \vec{x}}}{1+e^{\vec\omega^T \vec{x}}} $$</p><p>$$p(y=0 |  x;\omega) = \frac {1}{1+e^{\vec\omega^T \vec{x}}}  $$</p><p>为了确定$\omega$用对数似然函数：</p><p>$$ \ell(\omega) = lnp(y|x ;\omega)$$</p><p>可以合并到一起：</p><p>$$ p(y|x ;\omega) = f(x)^y(1-f(x))^{(1-y)}$$</p><p>带入到对数似然函数中：</p><p>$$ln p(y|x ;\omega) = y lnf(x) + (1-y)ln(1-f(x)) $$</p><p>我们得到的代价函数：</p><p>$$J(\omega) = - \frac{1}{m} \sum_{i=1}^m [ y^{(i)} lnf(x^{(i)}) + (1-y^{(i)})ln(1-f(x^{(i)})) ] $$</p><p>$J(\omega)$越小，就说明$f(x) = 1$的概率越大，因此只要求出$J(\omega)$的<strong>最小值</strong></p><blockquote><p>ps：<br>1） 之前推倒时候忽略了上标，但是我们在最后的损失函数中为了完整性就把上标加了上去</p></blockquote><h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><p>对代价函数求导的过程就不写了，直接写最后的结果:</p><p>$$\frac{\partial J(\omega)}{\partial\omega_j} =\frac{1}{m} \sum_{i=1}^m (f(x^{(i)}) - y^{(i)})x_j^{(i)}  $$</p><p>或者是：</p><p>$$<br>\frac{\partial}{\partial\mathbf\omega}J(\mathbf\omega) = \frac{1}{m}<br>\mathbf{X}^T(\mathbf{X\vec\omega} - \mathbf{Y})<br>$$</p><p>$\omega$的更新公式：</p><p>$$\omega_{j} := \omega_j- \frac{1}{m}\alpha\sum_{i=1}^m(f(x^{(i)}) - y^{(i)})x_j^{(i)} $$</p><p>其中, $j=1,2,…n$，需要注意的是$n$个$\omega$是同时更新的</p><p>写成向量形式就是：</p><p>$$\omega_{j} := \omega_j- \frac{1}{m} \alpha \mathbf {X}^T (g(\mathbf{X} \vec\omega) - \vec y) $$</p><h2 id="sklearn代码实现逻辑回归"><a href="#sklearn代码实现逻辑回归" class="headerlink" title="sklearn代码实现逻辑回归"></a>sklearn代码实现逻辑回归</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt</span><br><span class="line"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd</span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataset = pd.read_csv(<span class="hljs-string">r'E:\Downloads\100-Days-Of-ML-Code-master\Social_Network_Ads.csv'</span>)</span><br><span class="line">dataset.head(<span class="hljs-number">5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = dataset.iloc[:,[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]].values</span><br><span class="line">Y = dataset.iloc[:,<span class="hljs-number">4</span>].values</span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size = <span class="hljs-number">0.25</span>, random_state = <span class="hljs-number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler</span><br><span class="line">sc = StandardScaler()</span><br><span class="line">X_train = sc.fit_transform(X_train)</span><br><span class="line">X_test = sc.transform(X_test)</span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression</span><br><span class="line">classifier = LogisticRegression()</span><br><span class="line">classifier.fit(X_train, y_train)</span><br><span class="line"><span class="hljs-comment"># classifier.coef_</span></span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_pred = classifier.predict(X_test)</span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> confusion_matrix</span><br><span class="line">cm = confusion_matrix(y_test, y_pred)</span><br></pre></td></tr></table></figure><p>可视化</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> matplotlib.colors <span class="hljs-keyword">import</span> ListedColormap</span><br><span class="line">X_set,y_set=X_train,y_train</span><br><span class="line">X1,X2=np. meshgrid(np. arange(start=X_set[:,<span class="hljs-number">0</span>].min()<span class="hljs-number">-1</span>, stop=X_set[:, <span class="hljs-number">0</span>].max()+<span class="hljs-number">1</span>, step=<span class="hljs-number">0.01</span>),</span><br><span class="line">                   np. arange(start=X_set[:,<span class="hljs-number">1</span>].min()<span class="hljs-number">-1</span>, stop=X_set[:,<span class="hljs-number">1</span>].max()+<span class="hljs-number">1</span>, step=<span class="hljs-number">0.01</span>))</span><br><span class="line">plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(),X2.ravel()]).T).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="hljs-number">0.75</span>, cmap = ListedColormap((<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(),X1.max())</span><br><span class="line">plt.ylim(X2.min(),X2.max())</span><br><span class="line"><span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> enumerate(np. unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set==j,<span class="hljs-number">0</span>],X_set[y_set==j,<span class="hljs-number">1</span>],</span><br><span class="line">                c = ListedColormap((<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>))(i), label=j)</span><br><span class="line"></span><br><span class="line">plt. title(<span class="hljs-string">' LOGISTIC(Training set)'</span>)</span><br><span class="line">plt. xlabel(<span class="hljs-string">' Age'</span>)</span><br><span class="line">plt. ylabel(<span class="hljs-string">' Estimated Salary'</span>)</span><br><span class="line">plt. legend()</span><br><span class="line">plt. show()</span><br><span class="line"></span><br><span class="line">X_set,y_set=X_test,y_test</span><br><span class="line">X1,X2=np. meshgrid(np. arange(start=X_set[:,<span class="hljs-number">0</span>].min()<span class="hljs-number">-1</span>, stop=X_set[:, <span class="hljs-number">0</span>].max()+<span class="hljs-number">1</span>, step=<span class="hljs-number">0.01</span>),</span><br><span class="line">                   np. arange(start=X_set[:,<span class="hljs-number">1</span>].min()<span class="hljs-number">-1</span>, stop=X_set[:,<span class="hljs-number">1</span>].max()+<span class="hljs-number">1</span>, step=<span class="hljs-number">0.01</span>))</span><br><span class="line"></span><br><span class="line">plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(),X2.ravel()]).T).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="hljs-number">0.75</span>, cmap = ListedColormap((<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(),X1.max())</span><br><span class="line">plt.ylim(X2.min(),X2.max())</span><br><span class="line"><span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> enumerate(np. unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set==j,<span class="hljs-number">0</span>],X_set[y_set==j,<span class="hljs-number">1</span>],</span><br><span class="line">                c = ListedColormap((<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>))(i), label=j)</span><br><span class="line"></span><br><span class="line">plt. title(<span class="hljs-string">' LOGISTIC(Test set)'</span>)</span><br><span class="line">plt. xlabel(<span class="hljs-string">' Age'</span>)</span><br><span class="line">plt. ylabel(<span class="hljs-string">' Estimated Salary'</span>)</span><br><span class="line">plt. legend()</span><br><span class="line">plt. show()</span><br></pre></td></tr></table></figure><p><img src="/myphoto/output_12_0.png" alt="png"></p><p><img src="/myphoto/output_12_1.png" alt="png"></p>]]></content>
      
      
      <categories>
          
          <category> 数学与统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 标准库系列(六)---base64</title>
      <link href="/2018/11/30/python3-biao-zhun-ku-xi-lie-liu-base64/"/>
      <url>/2018/11/30/python3-biao-zhun-ku-xi-lie-liu-base64/</url>
      
        <content type="html"><![CDATA[<p>base64模块是一种用64个字符来表示任意二进制数据的方法。</p><a id="more"></a><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> base64</span><br><span class="line"><span class="hljs-comment"># 将bytes字转为64位 存储</span></span><br><span class="line">base64.b64encode(<span class="hljs-string">b'hello world'</span>)</span><br></pre></td></tr></table></figure><pre><code>b&apos;aGVsbG8gd29ybGQ=&apos;</code></pre><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base64.b64decode(<span class="hljs-string">b'aGVsbG8gd29ybGQ='</span>) <span class="hljs-comment"># 解码</span></span><br></pre></td></tr></table></figure><pre><code>b&apos;hello world&apos;</code></pre><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base64.b64decode(<span class="hljs-string">b'aGVsbG8gd29ybGQ='</span>).decode(<span class="hljs-string">"utf-8"</span>) <span class="hljs-comment"># 解码后以utf-8编码</span></span><br></pre></td></tr></table></figure><pre><code>&apos;hello world&apos;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 标准库系列(五)---subprocess</title>
      <link href="/2018/11/14/python3-biao-zhun-ku-xi-lie-wu-subprocess/"/>
      <url>/2018/11/14/python3-biao-zhun-ku-xi-lie-wu-subprocess/</url>
      
        <content type="html"><![CDATA[<p>subprocess模块是用来执行外部命令，下面介绍两种主要的用法。</p><a id="more"></a><h2 id="subprocess-run"><a href="#subprocess-run" class="headerlink" title="subprocess.run"></a><code>subprocess.run</code></h2><p> 这里<code>call</code>, <code>check_call</code>, <code>check_output</code>, 与其功能性相似，也都是会造成进程阻塞，就不展开介绍了</p><p>常用参数：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">subprocess.run (args，*,</span><br><span class="line">stdin = <span class="hljs-keyword">None</span>,</span><br><span class="line">input = <span class="hljs-keyword">None</span>,</span><br><span class="line">stdout = <span class="hljs-keyword">None</span>,</span><br><span class="line">stderr = <span class="hljs-keyword">None</span>,</span><br><span class="line">shell = <span class="hljs-keyword">False</span>,</span><br><span class="line">cwd = <span class="hljs-keyword">None</span>,</span><br><span class="line">timeout = <span class="hljs-keyword">None</span>,</span><br><span class="line">check = <span class="hljs-keyword">False</span>,</span><br><span class="line">encoding = <span class="hljs-keyword">None</span>,</span><br><span class="line">errors = <span class="hljs-keyword">None</span>,</span><br><span class="line">env = <span class="hljs-keyword">None</span> )</span><br></pre></td></tr></table></figure><p>默认不会捕获stdout或stderr</p><p>如果check为true，并且进程以非零退出代码退出， CalledProcessError则会引发异常。该异常的属性包含参数，退出代码以及stdout和stderr（如果它们被捕获）,</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 这里捕获了stdout,stderr</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = subprocess.run([<span class="hljs-string">"ls"</span>, <span class="hljs-string">"-l"</span>, <span class="hljs-string">"/dev/null"</span>],stdout=subprocess.PIPE,stderr=subprocess.PIPE)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a.stdout</span><br><span class="line"><span class="hljs-string">b'crw-rw-rw-. 1 root root 1, 3 8\xe6\x9c\x88   3 13:24 /dev/null\n'</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a.stdout</span><br><span class="line"><span class="hljs-string">b'crw-rw-rw-. 1 root root 1, 3 8\xe6\x9c\x88   3 13:24 /dev/null\n'</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a.stdout.decode(<span class="hljs-string">"utf-8"</span>)</span><br></pre></td></tr></table></figure><p>如果我们使用了check参数的话，如果执行错误，就会引发异常，这里什么都捕获不到</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b = subprocess.run([<span class="hljs-string">"ls"</span>, <span class="hljs-string">"-l"</span>, <span class="hljs-string">"/null"</span>], check=<span class="hljs-keyword">True</span>,stdout=subprocess.PIPE,stderr=subprocess.PIPE)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="hljs-string">"/share/chg2master/prod/Other/zhongjw/miniconda3/lib/python3.6/subprocess.py"</span>, line <span class="hljs-number">418</span>, <span class="hljs-keyword">in</span> run</span><br><span class="line">    output=stdout, stderr=stderr)</span><br><span class="line">subprocess.CalledProcessError: Command <span class="hljs-string">'['</span>ls<span class="hljs-string">', '</span>-l<span class="hljs-string">', '</span>/null<span class="hljs-string">']'</span> returned non-zero exit status <span class="hljs-number">2.</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>dir(b)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="hljs-string">'b'</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined</span><br></pre></td></tr></table></figure><p><em>python3.7里新增了<code>capture_output</code>参数,如果设置为true，则将捕获stdout和stderr。 使用时，将使用stdout = PIPE和stderr = PIPE自动创建内部Popen对象。 也可能不使用stdout和stderr参数。那么Popen对象的stdout、stderr与上面示例里的有什么不同呢？</em></p><h2 id="subprocess-Popen"><a href="#subprocess-Popen" class="headerlink" title="subprocess.Popen"></a><code>subprocess.Popen</code></h2><p>subprocess中更底层的进程创建和管理可以通过Popen类实现。它提供了更多的灵活性，程序员通过它能处理更多复杂的情况。</p><p>常用参数：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">subprocess.Popen(args, </span><br><span class="line">bufsize=<span class="hljs-number">-1</span>, </span><br><span class="line">executable=<span class="hljs-keyword">None</span>, </span><br><span class="line">stdin=<span class="hljs-keyword">None</span>, </span><br><span class="line">stdout=<span class="hljs-keyword">None</span>, </span><br><span class="line">stderr=<span class="hljs-keyword">None</span>, </span><br><span class="line">preexec_fn=<span class="hljs-keyword">None</span>, </span><br><span class="line">close_fds=<span class="hljs-keyword">True</span>, </span><br><span class="line">shell=<span class="hljs-keyword">False</span>, </span><br><span class="line">cwd=<span class="hljs-keyword">None</span>, </span><br><span class="line">env=<span class="hljs-keyword">None</span>, </span><br><span class="line">universal_newlines=<span class="hljs-keyword">False</span>, </span><br><span class="line">startupinfo=<span class="hljs-keyword">None</span>, </span><br><span class="line">creationflags=<span class="hljs-number">0</span>, </span><br><span class="line">restore_signals=<span class="hljs-keyword">True</span>, </span><br><span class="line">start_new_session=<span class="hljs-keyword">False</span>, </span><br><span class="line">pass_fds=(), *, </span><br><span class="line">encoding=<span class="hljs-keyword">None</span>, </span><br><span class="line">errors=<span class="hljs-keyword">None</span>)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>obj = subprocess.Popen([<span class="hljs-string">"ls"</span>, <span class="hljs-string">"-l"</span>, <span class="hljs-string">"/null"</span>], stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>obj.stderr.read().decode(<span class="hljs-string">"utf-8"</span>)</span><br><span class="line"><span class="hljs-string">'ls: 无法访问/null: 没有那个文件或目录\n'</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>obj.stderr.read().decode(<span class="hljs-string">"utf-8"</span>)</span><br></pre></td></tr></table></figure><p>从上面示例中可以看出Popen对象的stdout、stderr获取的是数据流，而run捕获的stdout、stderr是字符串格式</p><p>当然官方文档说是不建议使用<code>.stdin.write</code>,<code>.stdout.read</code> 或者 <code>.stderr.read</code>，而是用<code>.communicate</code>方法，该方法会造成阻塞，以防止其他进程读取数据流造成死锁</p><p><code>.communicate()</code>方法如果同时有<code>.stdout</code>和 <code>.stderr</code>, 返回的是一个元组, 用下标可以访问捕获的<code>stdout</code>和 <code>stderr</code>。</p><p>还要补充一点就是如果不捕获输出的话，是不会造成阻塞的，如果要等待子进程运行完可以使用<code>.wait</code>方法，而<code>subprocesee.run</code>方法会造成主程序的阻塞，因为要获取子进程运行状态。</p><p>Popen对象的主要方法有：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="hljs-string">'communicate'</span>, <span class="hljs-string">'kill'</span>, <span class="hljs-string">'pid'</span>, <span class="hljs-string">'poll'</span>, <span class="hljs-string">'returncode'</span>, <span class="hljs-string">'send_signal'</span>, <span class="hljs-string">'stderr'</span>, <span class="hljs-string">'stdin'</span>, <span class="hljs-string">'stdout'</span>, <span class="hljs-string">'terminate'</span>, <span class="hljs-string">'universal_newlines'</span>, <span class="hljs-string">'wait'</span>]</span><br></pre></td></tr></table></figure><p>如果有需要使用其他的参数和方法请查阅<a href="https://docs.python.org/3.6/library/subprocess.html#module-subprocess" target="_blank" rel="noopener">官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 标准库系列(四)---logging</title>
      <link href="/2018/11/08/python3-biao-zhun-ku-xi-lie-si-logging/"/>
      <url>/2018/11/08/python3-biao-zhun-ku-xi-lie-si-logging/</url>
      
        <content type="html"><![CDATA[<p><code>logging</code>模块可以给脚本添加日志功能。</p><a id="more"></a><p>下面是一个输出日志的简单版：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># levelname 输出等级</span></span><br><span class="line"><span class="hljs-comment"># asctime 时间</span></span><br><span class="line"><span class="hljs-comment"># lineno 所在行</span></span><br><span class="line"><span class="hljs-comment"># module 所在模块名</span></span><br><span class="line"><span class="hljs-comment"># filename 日志输出函数的模块的文件名，注意不是参数 filename</span></span><br><span class="line"><span class="hljs-comment"># message 输出的内容</span></span><br><span class="line">logging.basicConfig(format=<span class="hljs-string">'%(levelname)s %(asctime)s,line %(lineno)s:\t%(message)s'</span>,</span><br><span class="line">                    level=logging.INFO,</span><br><span class="line">                    datefmt=<span class="hljs-string">'%Y-%m-%d %H:%M:%S'</span>) <span class="hljs-comment"># 可以加filename=logfile参数将日志输出到文件中</span></span><br><span class="line"></span><br><span class="line">logging.critical(<span class="hljs-string">'当发生严重错误，导致应用程序不能继续运行时记录的信息'</span>)</span><br><span class="line">logging.error(<span class="hljs-string">'由于一个更严重的问题导致某些功能不能正常运行时记录的信息'</span>)</span><br><span class="line">logging.warning(<span class="hljs-string">'当某些不期望的事情发生时记录的信息（如，磁盘可用空间较低），但是此时应用程序还是正常运行的'</span>)</span><br><span class="line">logging.info(<span class="hljs-string">'信息详细程度仅次于DEBUG，通常只记录关键节点信息，用于确认一切都是按照我们预期的那样进行工作'</span>)</span><br><span class="line">logging.debug(<span class="hljs-string">'最详细的日志信息，典型应用场景是 问题诊断'</span>)</span><br></pre></td></tr></table></figure><p>日志调用（<code>critical()</code>, <code>error()</code>, <code>warning()</code>, <code>info()</code>, <code>debug()</code>）以降序方式表示不同的严重级别,默认是<code>warning</code>。</p><p>下面的是一个自己用的以天为单位的输出日志的函数：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> re</span><br><span class="line"><span class="hljs-keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">from</span> logging.handlers <span class="hljs-keyword">import</span> TimedRotatingFileHandler</span><br><span class="line"><span class="hljs-keyword">from</span> logging.handlers <span class="hljs-keyword">import</span> RotatingFileHandler</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log_init</span><span class="hljs-params">(logfile)</span>:</span></span><br><span class="line">    log_fmt = <span class="hljs-string">'%(asctime)s\tFile \"%(filename)s\",line %(lineno)s\t%(levelname)s: %(message)s'</span></span><br><span class="line">    formatter = logging.Formatter(log_fmt)</span><br><span class="line">    <span class="hljs-comment"># 可以设置间隔时间，这里是一天生成一个文件</span></span><br><span class="line">    log_file_handler = TimedRotatingFileHandler(filename=logfile, when=<span class="hljs-string">"D"</span>, interval=<span class="hljs-number">1</span>, backupCount=<span class="hljs-number">7</span>)</span><br><span class="line">    log_file_handler.suffix = <span class="hljs-string">"%Y-%m-%d.log"</span></span><br><span class="line">    <span class="hljs-comment"># filehanlder.suffix的格式必须这么写，才能自动删除旧文件</span></span><br><span class="line">    <span class="hljs-comment"># 如果设定是天，就必须写成“%Y-%m-%d.log”，写成其他格式会导致删除旧文件不生效</span></span><br><span class="line"></span><br><span class="line">    log_file_handler.setFormatter(formatter)</span><br><span class="line">    <span class="hljs-comment"># log_file_handler.setLevel(logging.DEBUG)</span></span><br><span class="line">    logging.getLogger().setLevel(logging.DEBUG)</span><br><span class="line">    logging.getLogger().addHandler(log_file_handler)</span><br><span class="line">    <span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-string">    这里是需要运行的程序，需要按照文件格式删除log文件，需要启用 extMatch、removeHandle函数</span></span><br><span class="line"><span class="hljs-string">    '''</span></span><br><span class="line">    <span class="hljs-comment"># logging.info('this is a loggging info message')</span></span><br><span class="line">    <span class="hljs-comment"># logging.debug('this is a loggging debug message')</span></span><br><span class="line">    <span class="hljs-comment"># logging.warning('this is loggging a warning message')</span></span><br><span class="line">    <span class="hljs-comment"># logging.error('this is an loggging error message')</span></span><br><span class="line">    <span class="hljs-comment"># logging.critical('this is a loggging critical message')</span></span><br></pre></td></tr></table></figure><p>修改所调用的模块中的日志设置：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># somelib.py</span></span><br><span class="line"><span class="hljs-keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">log = logging.getLogger(__name__) <span class="hljs-comment"># 默认就是： __name__ 只的当前的模块</span></span><br><span class="line">log.addHandler(logging.NullHandler())</span><br><span class="line"><span class="hljs-comment"># Example function (for testing)</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    log.critical(<span class="hljs-string">'A Critical Error!'</span>)</span><br><span class="line">    log.debug(<span class="hljs-string">'A debug message'</span>)</span><br></pre></td></tr></table></figure><p>下面我们调用这个模块：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> logging</span><br><span class="line"><span class="hljs-comment"># 这是当前脚本的日志设置</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>logging.basicConfig(level=logging.ERROR)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> somelib</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>somelib.func()</span><br><span class="line">CRITICAL:somelib:A Critical Error!</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 指定模块名，改变该模块的输出级别</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>logging.getLogger(<span class="hljs-string">'somelib'</span>).level=logging.DEBUG</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>somelib.func()</span><br><span class="line">CRITICAL:somelib:A Critical Error!</span><br><span class="line">DEBUG:somelib:A debug message</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>在这里，根日志被配置成仅仅输出<code>ERROR</code> 或更高级别的消息。不过，<code>somelib</code> 的日志级别被单独配置成可以输出debug 级别的消息，它的优先级比全局配置高。像这样更改单独模块的日志配置对于调试来讲是很方便的，因为你无需去更改任何的全局日志配置——只需要修改你想要更多输出的模块的日志等级。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 标准库系列(三)---os.path</title>
      <link href="/2018/11/07/python3-biao-zhun-ku-xi-lie-san-os.path/"/>
      <url>/2018/11/07/python3-biao-zhun-ku-xi-lie-san-os.path/</url>
      
        <content type="html"><![CDATA[<p><code>os.path</code>模块比较简单，先记住下面这些常用的用就可以了</p><a id="more"></a><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> os</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>path = <span class="hljs-string">'/Users/beazley/Data/data.csv'</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 获取文件名</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.basename(path)</span><br><span class="line"><span class="hljs-string">'data.csv'</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 获取文件所在目录名</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.dirname(path)</span><br><span class="line"><span class="hljs-string">'/Users/beazley/Data'</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 多个元素拼接成一个链接</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.join(<span class="hljs-string">'tmp'</span>, <span class="hljs-string">'data'</span>, os.path.basename(path))</span><br><span class="line"><span class="hljs-string">'tmp/data/data.csv'</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 将家目录符号~换成真实链接</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>path = <span class="hljs-string">'~/Data/data.csv'</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.expanduser(path)</span><br><span class="line"><span class="hljs-string">'/Users/beazley/Data/data.csv'</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 获取文件扩展名</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.splitext(path)</span><br><span class="line">(<span class="hljs-string">'~/Data/data'</span>, <span class="hljs-string">'.csv'</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="hljs-comment"># 检查文件或目录是否存在</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.exists(<span class="hljs-string">'/etc/passwd'</span>)</span><br><span class="line"><span class="hljs-keyword">True</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 检测是不是文件类型</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.isfile(<span class="hljs-string">'/etc/passwd'</span>)</span><br><span class="line"><span class="hljs-keyword">True</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 检测是不是目录类型</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.isdir(<span class="hljs-string">'/etc/passwd'</span>)</span><br><span class="line"><span class="hljs-keyword">False</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 检测是不是符号链接</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.islink(<span class="hljs-string">'/usr/local/bin/python3'</span>)</span><br><span class="line"><span class="hljs-keyword">True</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 返回一个绝对路径</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.realpath(<span class="hljs-string">'/usr/local/bin/python3'</span>)</span><br><span class="line"><span class="hljs-string">'/usr/local/bin/python3.3'</span></span><br><span class="line">&gt;&gt;&gt;<span class="hljs-comment"># 获取文件大小</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.getsize(<span class="hljs-string">'/etc/passwd'</span>)</span><br><span class="line"><span class="hljs-number">3669</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 获取文件修改日期</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.getmtime(<span class="hljs-string">'/etc/passwd'</span>)</span><br><span class="line"><span class="hljs-number">1272478234.0</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> time</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>time.ctime(os.path.getmtime(<span class="hljs-string">'/etc/passwd'</span>))</span><br><span class="line"><span class="hljs-string">'Wed Apr 28 13:10:34 2010'</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 获取指定目录下的文件列表 </span></span><br><span class="line">&gt;&gt;&gt;os.listdir(<span class="hljs-string">'somedir'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 标准库系列(二)---argparse 模块</title>
      <link href="/2018/11/07/python3-biao-zhun-ku-xi-lie-er-argparse/"/>
      <url>/2018/11/07/python3-biao-zhun-ku-xi-lie-er-argparse/</url>
      
        <content type="html"><![CDATA[<p><code>argparse</code> 模块是标准库中最大的模块之一，拥有大量的配置选项，本章只列出了一些常用的选项</p><a id="more"></a><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="hljs-string">'Search some files'</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(dest=<span class="hljs-string">'filenames'</span>,metavar=<span class="hljs-string">'filename'</span>, nargs=<span class="hljs-string">'*'</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="hljs-string">'-p'</span>, <span class="hljs-string">'--pat'</span>,metavar=<span class="hljs-string">'pattern'</span>, required=<span class="hljs-keyword">True</span>,dest=<span class="hljs-string">'patterns'</span>, action=<span class="hljs-string">'append'</span>,help=<span class="hljs-string">'text pattern to search for'</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="hljs-string">'-v'</span>, dest=<span class="hljs-string">'verbose'</span>, action=<span class="hljs-string">'store_true'</span>,help=<span class="hljs-string">'verbose mode'</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="hljs-string">'-o'</span>, dest=<span class="hljs-string">'outfile'</span>, action=<span class="hljs-string">'store'</span>,help=<span class="hljs-string">'output file'</span>)</span><br><span class="line">parser.add_argument(<span class="hljs-string">'--speed'</span>, dest=<span class="hljs-string">'speed'</span>, action=<span class="hljs-string">'store'</span>,choices=&#123;<span class="hljs-string">'slow'</span>,<span class="hljs-string">'fast'</span>&#125;, default=<span class="hljs-string">'slow'</span>,help=<span class="hljs-string">'search speed'</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="hljs-comment"># 使用方法</span></span><br><span class="line">print(args.filenames)</span><br><span class="line">print(args.patterns)</span><br><span class="line">print(args.verbose)</span><br><span class="line">print(args.outfile)</span><br><span class="line">print(args.speed)</span><br></pre></td></tr></table></figure><p>为了解析命令行选项， 你首先要创建一个<code>ArgumentParser</code> 实例，并使用<code>add_argument()</code>方法声明你想要支持的选项。</p><p>在每个<code>add_argument()</code> 调用中，</p><ul><li><p><code>dest</code>参数指定解析结果被指派给属性的名字。</p></li><li><p><code>metavar</code> 参数被用来生成帮助信息(<code>metavar</code>仅更改显示的名称，<code>parse_args()</code>对象上属性的名称仍由<code>dest</code>值确定)。</p></li><li><p><code>action</code>参数指定跟属性对应的处理逻辑，通常的值为<code>store</code> , 被用来存储某个值或将多个参数值收集到一个列表中。其他参数：<code>store_true</code>,<code>store_false</code>:</p></li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="hljs-string">'--foo'</span>, action=<span class="hljs-string">'store_true'</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="hljs-string">'--bar'</span>, action=<span class="hljs-string">'store_false'</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="hljs-string">'--baz'</span>, action=<span class="hljs-string">'store_false'</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="hljs-string">'--foo --bar'</span>.split())</span><br><span class="line">Namespace(foo=<span class="hljs-keyword">True</span>, bar=<span class="hljs-keyword">False</span>, baz=<span class="hljs-keyword">True</span>)</span><br></pre></td></tr></table></figure><p>下面的参数收集所有剩余的命令行参数到一个列表中。在本例中它被用来构造一个文件名列表：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(dest=<span class="hljs-string">'filenames'</span>,metavar=<span class="hljs-string">'filename'</span>, nargs=<span class="hljs-string">'*'</span>)</span><br></pre></td></tr></table></figure><p>下面的参数根据参数是否存在来设置一个Boolean 标志：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="hljs-string">'-v'</span>, dest=<span class="hljs-string">'verbose'</span>, action=<span class="hljs-string">'store_true'</span>,help=<span class="hljs-string">'verbose mode'</span>)</span><br></pre></td></tr></table></figure><p>下面的参数接受一个单独值并将其存储为一个字符串：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="hljs-string">'-o'</span>, dest=<span class="hljs-string">'outfile'</span>, action=<span class="hljs-string">'store'</span>,help=<span class="hljs-string">'output file'</span>)</span><br></pre></td></tr></table></figure><ul><li><p>如果要接收多个值，可以使用<code>nargs</code>参数，其支持的值有：</p><ul><li>N  (整数), 检测命令行的该参数值的个数，只接收N个值</li><li>* , 也就是说参数可以接收任意个数值</li><li>+,  与‘*’ 一样，但是如果少于一个值，会生成错误信息，有点像通配符</li><li>？，如果传入了参数就使用参数给定的值，如果没有，就用默认值,这个需要设置默认值</li><li><code>argparse.REMAINDER</code>所有剩余的命令行参数都收集到一个列表中:</li></ul></li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="hljs-string">'PROG'</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="hljs-string">'--foo'</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="hljs-string">'command'</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="hljs-string">'args'</span>, nargs=argparse.REMAINDER)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>print(parser.parse_args(<span class="hljs-string">'--foo B cmd --arg1 XX ZZ'</span>.split()))</span><br><span class="line">Namespace(args=[<span class="hljs-string">'--arg1'</span>, <span class="hljs-string">'XX'</span>, <span class="hljs-string">'ZZ'</span>], command=<span class="hljs-string">'cmd'</span>, foo=<span class="hljs-string">'B'</span>)</span><br></pre></td></tr></table></figure><ul><li>下面的参数说明接受一个值，但是会将其和可能的选择值做比较，以检测其合法性：</li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="hljs-string">'--speed'</span>, dest=<span class="hljs-string">'speed'</span>, action=<span class="hljs-string">'store'</span>,choices=&#123;<span class="hljs-string">'slow'</span>,<span class="hljs-string">'fast'</span>&#125;, default=<span class="hljs-string">'slow'</span>,help=<span class="hljs-string">'search speed'</span>)</span><br></pre></td></tr></table></figure><p>也就是说只能选择<code>choices</code>参数中的值，否则会报错</p><p>其他一些参数：</p><ul><li><code>default</code>: 设置默认值</li><li><code>type</code>: 设置接收的内置类型，如<code>float</code>或<code>int</code>,(常见的内置类型和<strong>函数</strong>可以直接用作type参数的值)</li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="hljs-string">'foo'</span>, type=int)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="hljs-string">'bar'</span>, type=open)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="hljs-string">'2 temp.txt'</span>.split())</span><br><span class="line">Namespace(bar=&lt;_io.TextIOWrapper name=<span class="hljs-string">'temp.txt'</span> encoding=<span class="hljs-string">'UTF-8'</span>&gt;, foo=<span class="hljs-number">2</span>)</span><br></pre></td></tr></table></figure><ul><li><code>required</code>: 设置为必须参数</li></ul><p><code>ArgumentParser.add_argument_group</code>可以参数设置分组：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="hljs-string">'PROG'</span>, add_help=<span class="hljs-keyword">False</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>group = parser.add_argument_group(<span class="hljs-string">'group'</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>group.add_argument(<span class="hljs-string">'--foo'</span>, help=<span class="hljs-string">'foo help'</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>group.add_argument(<span class="hljs-string">'bar'</span>, help=<span class="hljs-string">'bar help'</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [--foo FOO] bar</span><br><span class="line"></span><br><span class="line">group:</span><br><span class="line">  bar    bar help</span><br><span class="line">  --foo FOO  foo help</span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="hljs-string">'PROG'</span>, add_help=<span class="hljs-keyword">False</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>group1 = parser.add_argument_group(<span class="hljs-string">'group1'</span>, <span class="hljs-string">'group1 description'</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>group1.add_argument(<span class="hljs-string">'foo'</span>, help=<span class="hljs-string">'foo help'</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>group2 = parser.add_argument_group(<span class="hljs-string">'group2'</span>, <span class="hljs-string">'group2 description'</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>group2.add_argument(<span class="hljs-string">'--bar'</span>, help=<span class="hljs-string">'bar help'</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [--bar BAR] foo</span><br><span class="line"></span><br><span class="line">group1:</span><br><span class="line">  group1 description</span><br><span class="line"></span><br><span class="line">  foo    foo help</span><br><span class="line"></span><br><span class="line">group2:</span><br><span class="line">  group2 description</span><br><span class="line"></span><br><span class="line">  --bar BAR  bar help</span><br></pre></td></tr></table></figure><ul><li><code>ArgumentParser.add_mutually_exclusive_group(required=False)</code> 可以设置一组互斥的参数组，即在该组中参数只能选零个或一个,当<code>required=True</code>时，标准该参数组必须选组中的一个参数：</li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="hljs-string">'PROG'</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>group = parser.add_mutually_exclusive_group(required=<span class="hljs-keyword">True</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>group.add_argument(<span class="hljs-string">'--foo'</span>, action=<span class="hljs-string">'store_true'</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>group.add_argument(<span class="hljs-string">'--bar'</span>, action=<span class="hljs-string">'store_false'</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>parser.parse_args([]) </span><br><span class="line"><span class="hljs-comment"># 如果required=False,那么这里不会报错</span></span><br><span class="line"><span class="hljs-comment"># Namespace(bar=True, foo=False)</span></span><br><span class="line">usage: PROG [-h] (--foo | --bar)</span><br><span class="line">PROG: error: one of the arguments --foo --bar <span class="hljs-keyword">is</span> required</span><br></pre></td></tr></table></figure><ul><li>添加一个子命令</li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(prog=<span class="hljs-string">'PROG'</span>)</span><br><span class="line">parser.add_argument(<span class="hljs-string">'--foo'</span>, action=<span class="hljs-string">'store_true'</span>, help=<span class="hljs-string">'foo help'</span>)</span><br><span class="line">subparsers = parser.add_subparsers(help=<span class="hljs-string">'sub-command help'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># create the parser for the "a" command</span></span><br><span class="line">parser_a = subparsers.add_parser(<span class="hljs-string">'a'</span>, help=<span class="hljs-string">'a help'</span>)</span><br><span class="line">parser_a.add_argument(<span class="hljs-string">'bar'</span>, type=int, help=<span class="hljs-string">'bar help'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># create the parser for the "b" command</span></span><br><span class="line">parser_b = subparsers.add_parser(<span class="hljs-string">'b'</span>, help=<span class="hljs-string">'b help'</span>)</span><br><span class="line">parser_b.add_argument(<span class="hljs-string">'--baz'</span>, choices=<span class="hljs-string">'XYZ'</span>, help=<span class="hljs-string">'baz help'</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$python temp.py -h</span><br><span class="line">usage: PROG [-h] [--foo] &#123;a,b&#125; ...</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  &#123;a,b&#125;       sub-command help</span><br><span class="line">    a         a help</span><br><span class="line">    b         b help</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help  show this help message <span class="hljs-keyword">and</span> exit</span><br><span class="line">  --foo       foo help</span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$python temp.py a -h</span><br><span class="line">usage: PROG a [-h] bar</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  bar         bar help</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help  show this help message <span class="hljs-keyword">and</span> exit</span><br></pre></td></tr></table></figure><ul><li>快速使用(自用)</li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_argparses</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="hljs-string">'description'</span>)</span><br><span class="line">    parser.add_argument(<span class="hljs-string">'-i'</span>,<span class="hljs-string">'--input'</span>,required=<span class="hljs-keyword">True</span>,dest=<span class="hljs-string">'input'</span>,</span><br><span class="line">                        help=<span class="hljs-string">"input file"</span>)</span><br><span class="line">    parser.add_argument(<span class="hljs-string">'-o'</span>,<span class="hljs-string">'--output'</span>,required=<span class="hljs-keyword">True</span>,dest=<span class="hljs-string">'output'</span>,help=<span class="hljs-string">"output file"</span>)</span><br><span class="line">    <span class="hljs-keyword">if</span> len(sys.argv) == <span class="hljs-number">1</span>:</span><br><span class="line">       parser.print_help()</span><br><span class="line">       sys.exit()</span><br><span class="line">    <span class="hljs-keyword">return</span> parser.parse_args()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 标准库系列(一)---email模块</title>
      <link href="/2018/11/02/python3-biao-zhun-ku-xi-lie-yi-email/"/>
      <url>/2018/11/02/python3-biao-zhun-ku-xi-lie-yi-email/</url>
      
        <content type="html"><![CDATA[<p>自己写的一个发邮件的类，自己用的时候，省的再到处翻教程</p><a id="more"></a><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-comment">#-*-coding:utf-8-*-</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> smtplib</span><br><span class="line"><span class="hljs-keyword">import</span> sys</span><br><span class="line"><span class="hljs-keyword">import</span> re</span><br><span class="line"><span class="hljs-keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">from</span> email.mime.multipart <span class="hljs-keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="hljs-keyword">from</span> email.mime.text <span class="hljs-keyword">import</span> MIMEText</span><br><span class="line"><span class="hljs-keyword">from</span> email.mime.image <span class="hljs-keyword">import</span> MIMEImage</span><br><span class="line"><span class="hljs-keyword">from</span> email <span class="hljs-keyword">import</span> encoders</span><br><span class="line"><span class="hljs-keyword">from</span> email.header <span class="hljs-keyword">import</span> Header</span><br><span class="line"><span class="hljs-keyword">from</span> email.utils <span class="hljs-keyword">import</span> parseaddr, formataddr</span><br><span class="line"></span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-string">发送邮件：</span></span><br><span class="line"><span class="hljs-string">文本，网页，附件，图片</span></span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sendemail</span><span class="hljs-params">()</span>:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,mailToList,mailHost,mailUser,mailPass,sub)</span>:</span></span><br><span class="line">        self.mailToList = mailToList  <span class="hljs-comment"># 邮件接收方的邮件地址，传入的必须是list类型</span></span><br><span class="line">        self.mailHost = mailHost    <span class="hljs-comment"># 邮件传送协议服务器: smtp.qiye.163.com</span></span><br><span class="line">        self.mailUser = mailUser  <span class="hljs-comment"># 邮件发送方的邮箱账号: xxxx@xxxx.org</span></span><br><span class="line">        self.mailPass = mailPass  <span class="hljs-comment"># 邮件发送方的邮箱密码: ****</span></span><br><span class="line">        self.sub = sub <span class="hljs-comment"># 邮件名</span></span><br><span class="line">        <span class="hljs-comment">#self.content = content # 内容</span></span><br><span class="line">        <span class="hljs-comment">#self.subtype = subtype # 发送类型 plain(文字)</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_formatAddr</span><span class="hljs-params">(self,s)</span>:</span></span><br><span class="line">        <span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-string">            处理发件人的名字，防止有带中文名的发件人</span></span><br><span class="line"><span class="hljs-string">        '''</span></span><br><span class="line">        name, addr = parseaddr(s)</span><br><span class="line">        <span class="hljs-keyword">return</span> formataddr((Header(name, <span class="hljs-string">'utf-8'</span>).encode(), addr))</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sendEmail</span><span class="hljs-params">(self,content,subtype)</span>:</span></span><br><span class="line">        msg = MIMEMultipart(<span class="hljs-string">'mixed'</span>) <span class="hljs-comment">#　默认就是　mixed类型</span></span><br><span class="line">        me = re.split(<span class="hljs-string">'@'</span>,self.mailUser)[<span class="hljs-number">0</span>]+<span class="hljs-string">"&lt;"</span>+self.mailUser+<span class="hljs-string">"&gt;"</span></span><br><span class="line">        msg[<span class="hljs-string">'Subject'</span>] = self.sub</span><br><span class="line">        msg[<span class="hljs-string">'From'</span>] = self._formatAddr(me)</span><br><span class="line">        msg[<span class="hljs-string">'To'</span>] = <span class="hljs-string">','</span>.join(self.mailToList)  <span class="hljs-comment"># 多个收件人以“,”分隔</span></span><br><span class="line">        text = MIMEText(content, _subtype=subtype, _charset=<span class="hljs-string">'utf-8'</span>)</span><br><span class="line">        msg.attach(text)</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">try</span>:</span><br><span class="line">            server = smtplib.SMTP()</span><br><span class="line">            server.connect(self.mailHost)</span><br><span class="line">            server.login(self.mailUser, self.mailPass)</span><br><span class="line">            server.sendmail(me, self.mailToList, msg.as_string())</span><br><span class="line">            server.quit()</span><br><span class="line">            print(<span class="hljs-string">"发送成功"</span>)</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span></span><br><span class="line">        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:</span><br><span class="line">            <span class="hljs-keyword">print</span> (e)</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sendFile</span><span class="hljs-params">(self,file)</span>:</span></span><br><span class="line">        <span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-string">        发送附件'''</span></span><br><span class="line">        msg = MIMEMultipart(<span class="hljs-string">'mixed'</span>) <span class="hljs-comment">#　默认就是　mixed类型</span></span><br><span class="line">        me = re.split(<span class="hljs-string">'@'</span>,self.mailUser)[<span class="hljs-number">0</span>]+<span class="hljs-string">"&lt;"</span>+self.mailUser+<span class="hljs-string">"&gt;"</span></span><br><span class="line">        msg[<span class="hljs-string">'Subject'</span>] = self.sub</span><br><span class="line">        msg[<span class="hljs-string">'From'</span>] = self._formatAddr(me)</span><br><span class="line">        msg[<span class="hljs-string">'To'</span>] = <span class="hljs-string">','</span>.join(self.mailToList)</span><br><span class="line">        </span><br><span class="line">        sendfile=open(file,<span class="hljs-string">'rb'</span>).read()</span><br><span class="line">        text_att = MIMEText(sendfile, <span class="hljs-string">'base64'</span>, <span class="hljs-string">'utf-8'</span>) </span><br><span class="line">        text_att[<span class="hljs-string">"Content-Type"</span>] = <span class="hljs-string">'application/octet-stream'</span>  </span><br><span class="line">        <span class="hljs-comment"># 设置附件名字，如果是windows下的中文文件名需要以gbk编码，这里默认是再Linux上的中文名字的文件</span></span><br><span class="line">        text_att.add_header(<span class="hljs-string">'Content-Disposition'</span>, <span class="hljs-string">'attachment'</span>, filename=(<span class="hljs-string">"utf-8"</span>, <span class="hljs-string">""</span>,os.path.basename(file)))</span><br><span class="line">        <span class="hljs-comment">#return text_att</span></span><br><span class="line">        </span><br><span class="line">        msg.attach(text_att)</span><br><span class="line">        <span class="hljs-keyword">try</span>:</span><br><span class="line">            server = smtplib.SMTP()</span><br><span class="line">            server.connect(self.mailHost)</span><br><span class="line">            server.login(self.mailUser, self.mailPass)</span><br><span class="line">            server.sendmail(me, self.mailToList, msg.as_string())</span><br><span class="line">            server.quit()</span><br><span class="line">            print(<span class="hljs-string">"发送成功"</span>)</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span></span><br><span class="line">        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:</span><br><span class="line">            <span class="hljs-keyword">print</span> (e)</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    mailToList = [<span class="hljs-string">"xxx@xx.com"</span>,<span class="hljs-string">"xxx@xxx.com"</span>]  <span class="hljs-comment"># 邮件接收方的邮件地址，传入的必须是list类型</span></span><br><span class="line">    mailHost = <span class="hljs-string">"smtp.qiye.163.com"</span>    <span class="hljs-comment"># 邮件传送协议服务器: smtp.qiye.163.com</span></span><br><span class="line">    mailUser = <span class="hljs-string">"xxx@xxx.com"</span>  <span class="hljs-comment"># 邮件发送方的邮箱账号: xxxx@xxxx.com</span></span><br><span class="line">    mailPass = <span class="hljs-string">"xxxx"</span>  <span class="hljs-comment"># 邮件发送方的邮箱密码: ****</span></span><br><span class="line">    sub = <span class="hljs-string">"测试邮件"</span> <span class="hljs-comment"># 邮件名</span></span><br><span class="line">    s = Sendemail(mailToList,mailHost,mailUser,mailPass,sub)</span><br><span class="line">    <span class="hljs-comment">#content  内容/文件路径</span></span><br><span class="line">    <span class="hljs-comment">#subtype  发送类型 plain(文字) html(网页) 正文图片(目前只能实现插入一张图) 附件</span></span><br><span class="line">    content = <span class="hljs-string">"test"</span></span><br><span class="line">    subtype = <span class="hljs-string">"plain"</span></span><br><span class="line">    <span class="hljs-comment"># 如果发送的是附件用这个函数，暂时不支持邮件正文中发图片，因为比较麻烦，就是把图片插入网页格式中</span></span><br><span class="line">    s.sendFile(<span class="hljs-string">"filepath"</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWK简明教程</title>
      <link href="/2018/05/16/awk-jian-ming-jiao-cheng/"/>
      <url>/2018/05/16/awk-jian-ming-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<p>AWK是一种处理文本文件的语言，是一个强大的文本分析工具。之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。</p><a id="more"></a><h3 id="awk命令格式和选项"><a href="#awk命令格式和选项" class="headerlink" title="awk命令格式和选项"></a>awk命令格式和选项</h3><p>语法形式</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk [options] &apos;script&apos; var=value file(s)</span><br><span class="line">awk [options] -f scriptfile var=value file(s)</span><br></pre></td></tr></table></figure><p>常用命令选项</p><ul><li>-F fs   fs指定输入分隔符，fs可以是字符串或正则表达式，如-F:</li><li>-v var=value   赋值一个用户定义变量，将外部变量传递给awk</li><li>-f scripfile  从脚本文件中读取awk命令</li><li>-m[fr] val   对val值设置内在限制，-mf选项限制分配给val的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</li></ul><p><strong>工作原理</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hawk &apos;BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;&apos;</span><br></pre></td></tr></table></figure><h3 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h3><table><thead><tr><th>变量</th><th>详细说明</th></tr></thead><tbody><tr><td>$0</td><td>当前记录（这个变量中存放着整个行的内容）</td></tr><tr><td>$1~$n</td><td>当前记录的第n个字段，字段间由FS分隔</td></tr><tr><td>FS</td><td>输入字段分隔符 默认是空格或Tab (<strong>也可以是-F</strong>)</td></tr><tr><td>NF</td><td>当前记录中的字段个数，就是有多少列</td></tr><tr><td>NR</td><td>已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中。</td></tr><tr><td>FNR</td><td>当前记录数，与NR不同的是，这个值会是各个文件自己的行号</td></tr><tr><td>RS</td><td>输入的记录分隔符， 默认为换行符</td></tr><tr><td>OFS</td><td>输出字段分隔符， 默认也是空格</td></tr><tr><td>ORS</td><td>输出的记录分隔符，默认为换行符</td></tr><tr><td>FILENAME</td><td>当前输入文件的名字</td></tr></tbody></table><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span> awk '$6 ~ /FIN|TIME/ || NR==1 &#123;print NR,$4,$5,$6&#125;' OFS="\t" netstat.txt</span><br></pre></td></tr></table></figure><h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>下面的命令计算所有的C文件，CPP文件和H文件的文件大小总和。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l  *.cpp *.c *.h | awk &apos;&#123;sum+=$5&#125; END &#123;print sum&#125;&apos;</span><br><span class="line">2511401</span><br></pre></td></tr></table></figure><p>统计每个用户的进程的占了多少内存</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span> ps aux | awk 'NR!=1&#123;a[$1]+=$6;&#125; END &#123; for(i in a) print i ", " a[i]"KB";&#125;'</span><br><span class="line">dbus, 540KB</span><br><span class="line">mysql, 99928KB</span><br><span class="line">www, 3264924KB</span><br><span class="line">root, 63644KB</span><br><span class="line">hchen, 6020KB</span><br></pre></td></tr></table></figure><p><strong>控制结构和脚本语言待补充</strong></p><p><strong>参考链接：</strong></p><p><a href="http://man.linuxde.net/awk" target="_blank" rel="noopener">http://man.linuxde.net/awk</a><br><a href="https://coolshell.cn/articles/9070.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9070.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> awk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我为什么要写博客</title>
      <link href="/2018/03/03/you-are-what-you-write/"/>
      <url>/2018/03/03/you-are-what-you-write/</url>
      
        <content type="html"><![CDATA[<h2 id="You-Are-What-You-Write"><a href="#You-Are-What-You-Write" class="headerlink" title="You Are What You Write"></a>You Are What You Write</h2><p><em>原文：<a href="https://www.linkedin.com/pulse/you-what-write-harry-shum?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">https://www.linkedin.com/pulse/you-what-write-harry-shum?from=timeline&amp;isappinstalled=0</a></em></p><p>Are Twitter, PowerPoint, Facebook, Instagram and texting eroding our ability to think?</p><p>There is a Chinese proverb that says “见文如见人,” which literally means “reading the document is the same as seeing the author.” If we are what we write, then who have we, as a society, become?</p><p>I was sitting in a technical review recently, listening to one of our reviewers grill the engineer who was presenting: Why did you choose that design? Why is the service showing bad results? How many users will switch to the solution?</p><a id="more"></a> <p>The presenter’s answers lacked depth. It seemed like he hadn’t done enough rigorous thinking, the kind where you sit quietly, sift through research, contemplate options, determine what you know, don’t know and where more work is required. The kind of thinking I did as a young researcher when peers took me and my work apart when I took short cuts. Back then, I practiced a disciplined approach, spending hours just thinking, and even more hours on the hardest part—writing it down.</p><p>Today, long-form writing is being replaced. Tweets pass for dialogue. PowerPoint condenses thoughts to bullets. Words have been traded for emojis and GIFs. And we’ve become addicted to the noise. What happens in an Internet minute? 16 million text messages. 1.8 million snaps. 452,000 Tweets. 156 million emails. Who has time to think, let alone write?</p><p>And maybe we, in the technology industry, have shaped this reality. We created the phones, apps and 24/7-connected world. We’ve enabled society to put down the pen. The only writing I do today is email or quick WeChat posts.</p><p>So now I worry that we’re losing a valuable tool that helps us to think deeply, express who we are at our greatest and expand the intellect of those around us. And for us in the technical community, this is especially troubling. The stakes are higher than ever before with AI. We’re under enormous pressure to ship quickly, to achieve more, faster, but we can’t do this at the expense of the highest engineering quality. We have to think carefully about consequences and alternatives. Who gets blamed when a self-driving car hits someone? The engineer who wrote the code is the driver. Who is accountable for the AI algorithm with bias? The engineer who created the AI.</p><p>I see fewer engineers writing and sharing deep thinking, but this is what will lead to far more true innovation across the industry. How will we achieve the big transformative breakthroughs versus the incremental milestones?</p><p>By writing. Because the way to think is actually to write.</p><p>Putting pen to paper forces you to develop and refine your thinking by iterating, revising and exploring alternatives. Anyone who can think deeply can write beautiful code, inspiring papers or develop the plan to bring the next big thing to life. I encourage you to read Reid Hoffman’s Series B pitch for LinkedIn in which he shares the thinking that helped him succeed. At the time, he shares that a partner in a venture firm was exposed to around 5,000 pitches, looked more closely at 600 to 800, and did between 0 and 2 deals.</p><p>Writing offers the possibility to create lasting artifacts. I think of papers I published that endure, albeit perhaps as reference materials. Plenoptic Sampling. Lazy Snapping. Poisson Matting. These are my work’s contribution to the field of computer vision and graphics. They will survive me and, if I’m lucky, even help shape a mind or two.</p><p>One of my favorite professors at Carnegie Mellon, Takeo Kanade, said that you have to write research papers like detective novels. You need story, suspense, surprise and ‘aha’ to explain your ideas to peers, to inspire others to contribute and advance your work and the whole field.</p><p>Writing is an equalizer to get the best from the whole team. At Amazon, presentations are done with the six-page paper. Meetings kick off with everyone reading followed by comments and questions to the author. Everyone operates from the same context, and introverts, extroverts and non-native speakers have an equal chance to get their thinking across. It’s not about the presenter’s personality, but the words.</p><p>Ultimately, writing helps make you successful. You might be the smartest person with the best idea, but if you can’t communicate your thinking in a compelling way, you won’t get far. Two engineers in our AI+R team who inspire me with their regular writing habits are Bill Ramsey and Ronny Kohavi. Bill has written over 250 blog posts at Microsoft, benefitting our entire technical community. With Ronny, you don’t even need to meet him—his highly cited A/B test experimentation papers say it all, and he’s publishing for the benefit of the industry on LinkedIn.</p><p>As you’re reading this, you may be logging your objections: I need to drive results, so I need to go straight to code. I’m known for my code, so I don’t need to write papers. I’m not a native speaker, and I speak better with my code. I don’t know what to write about. I don’t have time… But please set them aside—for your own success, for your company’s, for the industry’s advancement—and start writing.</p><p>I see so many occasions for building long-form writing back into the engineering culture—planning documents, project proposals, technology LRP’s, review articles—to inspire us to work together, collectively creating and cultivating big ideas and big thinking.</p><p>I took a first step recently, writing a research paper with my colleagues Xiaodong He and Di Li, From Eliza to XiaoIce: Challenges and Opportunities with Social Chatbots, for the first time in years, so please no judgment, only constructive feedback!</p><p>I challenge everyone reading this piece to write 500 words per week. If you’ve got an idea or you see a problem, write your proposal and share it!</p><p>Let’s rewrite our standards for thought leadership and engineering quality by writing more!</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘抄 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
