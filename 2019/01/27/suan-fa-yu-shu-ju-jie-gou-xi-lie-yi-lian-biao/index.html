<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>算法与数据结构系列(一)： 链表 | 木叶村 | life is short</title>

  
  <meta name="author" content="Naruto">
  

  
  <meta name="description" content="无人为孤岛，一书一世界">
  

  
  
  <meta name="keywords" content="python3,数据结构">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="算法与数据结构系列(一)： 链表"/>

  <meta property="og:site_name" content="木叶村"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="木叶村" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">木叶村</a>
    </h1>
    <p class="site-description">life is short</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>算法与数据结构系列(一)： 链表</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/01/27/suan-fa-yu-shu-ju-jie-gou-xi-lie-yi-lian-biao/" rel="bookmark">
        <time class="entry-date published" datetime="2019-01-26T16:00:00.000Z">
          2019-01-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <pre class=" language-lang-python"><code class="language-lang-python">
'''
名称：链表基本操作

版本：python3.6

日期：20190127

'''


class ListNode():
    '''
    链表结构，节点类
    单链表结构都有两个属性，一个存储自身的值，另一个指针指向下一个值
    '''
    def __init__(self,value):
        self.value = value
        self.next = None

class UNorderList():
    '''
    创建一个无序链表,需要实现的操作有：
    add(item) ,remove(item),search(item),isEmpty(),size（）,append(item)
    index(item),insert(pos，item) ,pop() ,pop(pos) 

    '''
    def __init__(self):
        '''
        创建一个空链表
        '''
        self.head = None

    def isEmpty(self):
        '''
        检查列表是否为空。它不需要参数，并返回布尔值。
        '''
        return self.head == None

    def add(self,item):
        '''
        向列表头部添加一个新项。它需要 item 作为参数，并不返回任何内容。假定该 item 不在列表中。
        '''
        temp = ListNode(item) # 创建节点
        temp.next = self.head
        self.head = temp

    def append(self,item):
        '''
        将一个新项添加到列表的末尾，使其成为集合中的最后一项。
        它需要 item 作为参数，并不返回任何内容。假定该项不在列表中。
        '''
        cur = self.head
        item = ListNode(item)
        if self.head is None:
            self.head = item
        else:
            while cur.next != None:
                cur = cur.next
            cur.next = item

    def size(self):
        '''
        返回列表中的项数。它不需要参数，并返回一个整数。
        '''
        cur = self.head
        count = 0
        if cur == None:
            return count
        while cur.next != None:
            count += 1
            cur = cur.next
        return count+1

    def search(self,item):
        '''
         搜索列表中的项目。它需要 item 作为参数，并返回一个布尔值。
        '''
        cur = self.head
        while cur.next != None:
            if item == cur.value:
                return True
            cur = cur.next
        return False

    def remove(self,item):
        cur = self.head
        prev = None
        while cur.next != None:
            if item == cur.value:
                if prev == None:
                    self.head = self.head.next
                else:
                    prev.next = cur.next
                    self.head = prev
                return True
            prev = cur
            cur = cur.next
        return False

    def index(self,item):
        '''
        返回项在列表中的位置。它需要 item 作为参数并返回索引。假定该项在列表中。
        '''
        count = 0
        cur = self.head
        while cur.next != None:
            if cur.value == item:
                return count
            count += 1
            cur = cur.next
        return count

    def insert(self,pos,item):
        '''
        在位置 pos 处向列表中添加一个新项。它需要 item 作为参数并不返回任何内容。
        假设该项不在列表中，并且有足够的现有项使其有 pos 的位置。
        '''
        cur = self.head
        count = 1
        prev = None
        item = ListNode(item)
        while cur.next != None:
            if count == pos:
                if prev == None:
                    item.next = cur
                    self.head = item
                else:
                    prev.next = item
                    item.next = cur
                return True
            else:
                count += 1
                prev = cur
                cur = cur.next

    def pop(self,pos=None):
        '''
        删除并返回列表中的最后一个项。假设该列表至少有一个项。
        删除并返回位置 pos 处的项。它需要 pos 作为参数并返回项。假定该项在列表中。
        '''
        cur = self.head
        prev = None
        count = 1
        while cur.next != None:
            if count == pos:
                if prev == None:
                    prev = cur
                    cur = cur.next
                    self.head = cur
                    return prev.value
                else:
                    prev.next = cur.next
                    return cur.value
            else: 
                prev = cur
                cur = cur.next
                count += 1 

        prev.next = None
        return cur.value

    def reverse(self):
        '''
        反转链表
        要点：后一个节点的next = 前一个节点
        '''
        head = self.head
        prev = None
        while head != None:
            temp = head.next
            head.next = prev # 关键步骤
            prev = head
            head = temp

        return prev

def main():
    test_list = UNorderList()
    for i in range(5):
        test_list.append(i)

    print(test_list.reverse().value)

if __name__ == "__main__":
    main()
</code></pre>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/算法与数据结构/">算法与数据结构</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/python3/">python3</a><a href="/tags/数据结构/">数据结构</a>
    </span>
    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2019 Naruto
    
  </p>
</footer>
    
  </div>
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>