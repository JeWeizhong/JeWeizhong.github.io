<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 3 页 | 木叶村 | life is short</title>

  
  <meta name="author" content="Naruto">
  

  
  <meta name="description" content="无人为孤岛，一书一世界">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="木叶村"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="木叶村" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">木叶村</a>
    </h1>
    <p class="site-description">life is short</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/13/perl-jiao-ben-mo-ban/"><span>perl 脚本模板</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/13/perl-jiao-ben-mo-ban/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-12T16:00:00.000Z">
          2018-11-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <pre class=" language-lang-perl"><code class="language-lang-perl">#!/usr/bin/perl -w
use strict;
use Getopt::Long;
use File::Basename;
use FindBin qw($Bin $Script);


my $USAGE = qq{

Fuction：
        test
Useage:
        perl $0 [Options]
Options:
        -h|help         Print this help
        -i| input       <str>  input input file
        -o|output       <str>  output output file
Other:

};


my ($help,$input,$output);

GetOptions(    # 冒号为设置参数类型
    "help:s"=>\$help,
    "input:s"=>\$input,
    "output:s"=>\$output
);
die "$USAGE\n" unless ($input && $output);
</code></pre>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/perl/">perl</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/编程语言/">编程语言</a><a href="/tags/perl/">perl</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/13/linux-xi-lie-vim/"><span>vim 用法大全</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/13/linux-xi-lie-vim/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-12T16:00:00.000Z">
          2018-11-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>打开/退出</p>
<pre><code>vim -R file1 只读打开
:qall 退出所有文件
:wq 写入并退出
:q! 强制退出
</code></pre><p>插入</p>
<pre><code>i 在当前位置生前插入
I 在当前行首插入
a 在当前位置后插入
A 在当前行尾插入
o 在当前行之后插入一行
O 在当前行之前插入一行
</code></pre><p>移动</p>
<pre><code>h 左移一个字符
l 右移一个字符
k 上移一个字符
j 下移一个字符
</code></pre><p>删除</p>
<pre><code>dd 删除当前行
dj 删除当前行和上一行
dk 删除当前行和下一行
10dd 删除当前行开始的共10行
D 删除当前字符至行尾
</code></pre><p>跳转</p>
<pre><code>gg 跳转到文件头
G 跳转到文件尾
gg=G自动缩进 （非常有用）
Ctrl + d 向下滚动半屏
Ctrl + u 向上滚动半屏
Ctrl + f 向下滚动一屏
Ctrl + b 向上滚动一屏
冒号+行号，跳转到指定行；比如:120，跳转到120行；
$ 跳转到行尾
0 跳转到行首
</code></pre><p>编辑</p>
<pre><code>u 撤销
Ctrl + r 重做
yy 复制当前行
按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制任意部分
p 粘贴在当前位置
另外，删除在vim里面就是剪切的意思，所以dd就是剪切当前行，可以用v或V选择特定部分再按d就是任意剪切了
</code></pre><p>查找</p>
<pre><code>/text　　查找text，按n健查找下一个，按N健查找前一个
?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个
:set ignorecase　　忽略大小写的查找
:set noignorecase　　不忽略大小写的查找
</code></pre><p>替换</p>
<pre><code>:s/old/new/ 用old替换new，替换当前行的第一个匹配
:s/old/new/g 用old替换new，替换当前行的所有匹配
:%s/old/new/ 用old替换new，替换所有行的第一个匹配
:%s/old/new/g 用old替换new，替换整个文件的所有匹配
也可以用v或V选择指定行，然后执行
</code></pre><p>多文件操作</p>
<pre><code>vim file1 file2 file3 ... 同时编辑多个文件
:split 将窗口分成上下两个子窗口，对应两个不同的文件
:vsplit 将窗口分成左右两个子窗口，对应两个不同的文件
:open file4 打开新文件
:bn 切换到下一个文件（当前窗口）
:bp 切换到上一个文件（当前窗口）
Ctrl-w h    移动到窗口左边
Ctrl-w j    移动到窗口下边
Ctrl-w k    移动到窗口上边
Ctrl-w l    移动到窗口右边
</code></pre><p><em>未完待续……</em></p>
<p>参考链接：<a href="https://www.cnblogs.com/linyx/p/4131699.html" target="_blank" rel="noopener">https://www.cnblogs.com/linyx/p/4131699.html</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Linux/">Linux</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Linux/">Linux</a><a href="/tags/vim/">vim</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/12/python3cook-xi-lie-bi-ji-ba/"><span>python3 cookbook笔记： 第八章 类与对象(二)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/12/python3cook-xi-lie-bi-ji-ba/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-11T16:00:00.000Z">
          2018-11-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><em>本节介绍property装饰器的用法</em></p>
<p><code>proprety</code>的作用是可以将方法变成属性，那它到底是怎么实现的呢？让我们先来看一个例子：</p>
<pre class=" language-lang-python"><code class="language-lang-python">class Person:
    def __init__(self, name):
        self.first_name = name
    # Getter 方法
    @property
    def first_name(self):
        return self._first_name
    # Setter 方法
    @first_name.setter
    def first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value
    # Deleter 方法(可选)
    @first_name.deleter
    def first_name(self):
        raise AttributeError("Can't delete attribute")
</code></pre>
<p>使用方法：</p>
<pre class=" language-lang-python"><code class="language-lang-python">>>> a = Person('Guido')
>>> a.first_name # 调用getter方法
'Guido'
</code></pre>
<p>当我们进行赋值操作时<code>a = Person(&#39;Guido&#39;)</code>就创建了实例，在构造函数中的赋值语句<code>self.first_name</code>就会自动调用<code>first_name</code>的<code>getter</code>、<code>setter</code>、<code>deleter</code>方法(实质上是调用了<code>__get__()</code> 、<code>__set__()</code>和<code>__delete__()</code> 方法)。</p>
<p>而将等号右边的<code>name</code>参数传入到<code>@first_name.setter</code>下面的方法中，书中是用的<code>first_name</code>变量名字，其实这里设置成其他的变量名比较好，要不然容易混淆参数与方法函数。</p>
<p>因此装饰器<code>property</code>将原来的<code>first_name()</code>方法，变成了<code>self.first_name</code>属性,一开始我们要调用方法是<code>var.mothed()</code>,现在变成了属性，只用<code>.</code>运算符就可以, 括号就不需要了</p>
<p>接下来我们来看另一中形式：</p>
<pre class=" language-lang-python"><code class="language-lang-python">class Animal(object):
    def __init__(self, name, age):
        self._name = name

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if isinstance(value, str):
            self._name = value
        else:
            self._name = 'to getter '
</code></pre>
<p>这里在构造函数中并没有调用<code>getter</code>、<code>setter</code>方法，那么，<code>self._name</code>，<code>self.name</code>其实是两个不同的属性，只是<code>self._name</code>属性依赖于<code>self.name</code>:</p>
<pre class=" language-lang-python"><code class="language-lang-python">>>> a = Animal('black dog', 3)
>>> a.name # 此时其实是没有调用setter方法的，只调用了 getter方法
'black dog'
>>> a._name # 因为没有调用setter方法，所以self._name值也没有修改
'black dog'
>>> a.name = 1 # 调用了setter方法，但是不是字符串类型的，所以执行 self._name = 'to getter '，然后调用getter方法，返回self._name的值
>>> a.name
'to getter '
>>> a._name # 因为进行了赋值操作，因此self._name的值也进行了修改
'to getter '
>>> a.name = "white55k" 
>>> a.name
'white55k'
>>> a._name
'white55k'
</code></pre>
<p>这里要说明的一点是<code>__init__</code>函数的参数<code>name</code>只是执行了<code>self._name = name</code>赋值操作，由于并没有调用<code>setter</code>方法，因此<code>def name(self, value)</code>需要重新传入参数(赋值)</p>
<p>在看另一种用法，只设置<code>getter</code>方法，变成只读属性，实现编程接口：</p>
<pre class=" language-lang-python"><code class="language-lang-python">class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2018 - self._birth

# 使用
>>> a=Student() # 创建实例
>>> a.birth=1990 # setter
>>> a.birth # getter
1990
>>> a.age # 只有 getter
28
>>> a.age=2 # 调用setter方法，会报错
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: can't set attribute
</code></pre>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/python3/">python3</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/编程语言/">编程语言</a><a href="/tags/python3/">python3</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/11/perl-ming-ling-xing-da-yin-dan-yin-hao/"><span>perl 命令行中打印单引号</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/11/perl-ming-ling-xing-da-yin-dan-yin-hao/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-10T16:00:00.000Z">
          2018-11-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>一开始我以为在单行命令中打印单引号是这样的：</p>
<pre class=" language-lang-perl"><code class="language-lang-perl">  perl -e 'print "\'";'
</code></pre>
<p>后来发现这样写是不行的，在第二个单号的时候就会与第一个引号匹配，而被当作这命令未结束。</p>
<p>因为反斜杠对符号做了转义，这样的命令解释成：perl -e ‘print ‘;’ (双引号内一个单引号，它被当作了括住命令的单引号了)</p>
<p>搜索了一波才知道要这样写：</p>
<pre class=" language-lang-perl"><code class="language-lang-perl">  perl -e 'print "'\''";'
</code></pre>
<p>双引号内是 单引号 反斜杠 单引号 ，这样经过双引号代换后变成：</p>
<pre class=" language-lang-perl"><code class="language-lang-perl">  perl -e 'print \' '
</code></pre>
<p>也就是说，在命令行中要使用反转义线’\’, 就必须带（单？）引号,这样才会被Perl语言解释成反转义线，要不然会被shell捕获成反转义线</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/perl/">perl</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/编程语言/">编程语言</a><a href="/tags/perl/">perl</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/11/linux-xi-lie-tar/"><span>Linux命令：tar</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/11/linux-xi-lie-tar/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-10T16:00:00.000Z">
          2018-11-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <pre class=" language-lang-shell"><code class="language-lang-shell">tar -cvf log.tar log2018.log    #仅打包，不压缩！

tar -zcvf log.tar.gz log2018.log   #打包后，以 gzip 压缩
tar -jcvf log.tar.bz2 log2018.log  #打包后，以 bzip2 压缩

tar -zxvf /opt/soft/test/log.tar.gz # 解压gz
tar -jxvf /opt/soft/test/log.tar.bz2 # 解压bz2
</code></pre>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Linux/">Linux</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/编程语言/">编程语言</a><a href="/tags/Linux/">Linux</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/09/python3cook-xi-lie-bi-ji-qi/"><span>python3 cookbook笔记： 第八章 类与对象(一)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/09/python3cook-xi-lie-bi-ji-qi/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-08T16:00:00.000Z">
          2018-11-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类 定义了一组属性，这些属性与一组叫做<strong>实例</strong>的对象相关且由其共享。类通常是由函数（称为<strong>方法</strong> ，method）、变量（称为<strong>类变量</strong> ，class variable）和计算出的属性（称为<strong>特性</strong> ，property）组成的集合</p>
<h3 id="class-语句"><a href="#class-语句" class="headerlink" title="class 语句"></a>class 语句</h3><p>使用<code>class</code>语句可定义类。类主体包含一系列在类定义时执行的语句，例如：</p>
<pre class=" language-lang-python"><code class="language-lang-python">class Account(object):
　　 num_accounts = 0
　　 def __init__(self,name,balance):
　　　　 self.name = name
　　　　 self.balance = balance
　　　　 Account.num_accounts += 1
　　 def __del__(self):
　　　　 Account.num_accounts -= 1
　　 def deposit(self,amt):
　　　　 self.balance = self.balance + amt
　　 def withdraw(self,amt):
　　　　 self.balance = self.balance - amt
　　 def inquiry(self):
　　　　 return self.balance
</code></pre>
<p>在类主体执行期间创建的值放在类对象中，这个对象充当着命名空间，与模块极为相似。例如，访问Account 类成员的方式如下：</p>
<pre class=" language-lang-python"><code class="language-lang-python">Account.num_accounts
Account.__init__
Account.__del__
Account.deposit
Account.withdraw
Account.inquiry
</code></pre>
<p>需要注意的是，class 语句本身并不创建该类的任何实例（例如，上一个例子实际上不会创建任何账户）。类仅设置将在以后创建的所有实例使用的属性。从这种意义上讲，可以将类看作一个蓝图。</p>
<p>类中定义的函数称为<strong>实例方法</strong> 。实例方法是一种在类的实例上进行操作的函数，类实例作为第一个参数传递。根据约定，这个参数称为<code>self</code> ，尽管所有合法的标识符都可以使用。在前面的例子中，<code>deposit()</code> 、<code>withdraw()</code>和<code>inquiry()</code> 都是实例方法。</p>
<p><strong>类变量</strong>（如<code>num_accounts</code> ）是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。上例中的<code>num_accounts</code> 变量用于跟踪存在多少个Account 实例。</p>
<h3 id="类实例"><a href="#类实例" class="headerlink" title="类实例"></a>类实例</h3><p>类的实例是以函数形式调用类对象来创建的。这种方法将创建一个新实例，然后将该实例传递给类的<code>__init__()</code>方法。<code>__init__()</code> 方法的参数包括新创建的实例self 和在调用类对象时提供的参数。例如：</p>
<pre class=" language-lang-python"><code class="language-lang-python"># 创建一些账户
a = Account("Guido", 1000.00)　 
# 调用Account.__init__(a,"Guido",1000.00)
b = Account("Bill", 10.00)
</code></pre>
<p>在<code>__init__()</code> 内，通过将属性分配给self 来将其保存到实例中。上例中，<code>self.name =  &quot;Guido&quot;</code>。</p>
<p><strong>上面创建了两个实例</strong>，然后用(<code>.</code>)运算符即可访问属性：</p>
<pre class=" language-lang-python"><code class="language-lang-python">a.deposit(100.00)　　　
# 调用Account.deposit(a,100.00)
# self.balance已经通过__init__实例化,即self.balance = 1000.00
# 所以访问deposit属性后：
# self.balance = 1000.00 + 100.00
b.withdraw(50.00)　　　# 调用Account.withdraw(b,50.00)
name = a.name　　　　　# 获取账户名
</code></pre>
<h2 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h2><ul>
<li>默认的字符串显示是<code>__str__()</code>方法，我们可以自定义<code>__repr__()</code> 和<code>__str__()</code>来是的交互更加友好</li>
<li><code>format()</code> 函数实际上是调用的<code>__formait__()</code>方法</li>
<li><code>with</code>语句是调用的<code>__enter__()</code> 和<code>__exit__()</code> 方法,我们可以在定义类的时候定义这两个方法，就能使对象支持<code>witg</code>上下文管理</li>
</ul>
<pre class=" language-lang-python"><code class="language-lang-python">    from socket import socket, AF_INET, SOCK_STREAM

    class LazyConnection:
        def __init__(self, address, family=AF_INET, type=SOCK_STREAM):
            self.address = address
            self.family = family
            self.type = type
            self.sock = None
        def __enter__(self):
            if self.sock is not None:
                raise RuntimeError('Already connected')
            self.sock = socket(self.family, self.type)
            self.sock.connect(self.address)
            return self.sock
        def __exit__(self, exc_ty, exc_val, tb):
            self.sock.close()
            self.sock = None
</code></pre>
<ul>
<li>类添加<code>__slots__</code>属性来极大的减少实例所占的内存,但使用后我们不能再给实例添加新的属性了，只能使用在<code>__slots__</code> 中定义的那些属性名。</li>
<li>约定是任何以单下划线<code>_</code> 开头的名字都应该是内部实现</li>
<li><p>使用双下划线开始会导致访问名称变成其他形式:</p>
<pre class=" language-lang-python"><code class="language-lang-python">  class B:
      def __init__(self):
          self.__private = 0
      def __private_method(self):
          pass
      def public_method(self):
          pass
          self.__private_method()
</code></pre>
</li>
</ul>
<p>比如，在前面的类<code>B</code> 中，私有属性会被分别重命名为<code>_B__private</code> 和<code>_B__private_method</code> 。这时候你可能会问这样重命名的目的是什么，答案就是继承——这种属性通过继承是无法被覆盖的。比如：</p>
<pre><code>```python
class C(B):
    def __init__(self):
        super().__init__()
        self.__private = 1 # Does not override B.__private
    # Does not override B.__private_method()
    def __private_method(self):
    pass
```
</code></pre><p>这里，私有名称<code>__private</code> 和<code>__private_method</code> 被重命名为<code>_C__private</code> 和<code>_C__private_method</code> ，这个跟父类<code>B</code> 中的名称是完全不同的。</p>
<ul>
<li>有时候你定义的一个变量和某个保留关键字冲突，这时候可以使用单下划线作为后缀</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/python3/">python3</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/编程语言/">编程语言</a><a href="/tags/python3/">python3</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/08/python3-biao-zhun-ku-xi-lie-si-logging/"><span>python3 标准库系列(四)---logging</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/08/python3-biao-zhun-ku-xi-lie-si-logging/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-07T16:00:00.000Z">
          2018-11-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><code>logging</code>模块可以给脚本添加日志功能。</p>
<p>下面是一个输出日志的简单版：</p>
<pre class=" language-lang-python"><code class="language-lang-python">import logging

# levelname 输出等级
# asctime 时间
# lineno 所在行
# module 所在模块名
# filename 日志输出函数的模块的文件名，注意不是参数 filename
# message 输出的内容
logging.basicConfig(format='%(levelname)s %(asctime)s,line %(lineno)s:\t%(message)s',
                    level=logging.INFO,
                    datefmt='%Y-%m-%d %H:%M:%S') # 可以加filename=logfile参数将日志输出到文件中

logging.critical('当发生严重错误，导致应用程序不能继续运行时记录的信息')
logging.error('由于一个更严重的问题导致某些功能不能正常运行时记录的信息')
logging.warning('当某些不期望的事情发生时记录的信息（如，磁盘可用空间较低），但是此时应用程序还是正常运行的')
logging.info('信息详细程度仅次于DEBUG，通常只记录关键节点信息，用于确认一切都是按照我们预期的那样进行工作')
logging.debug('最详细的日志信息，典型应用场景是 问题诊断')
</code></pre>
<p>日志调用（<code>critical()</code>, <code>error()</code>, <code>warning()</code>, <code>info()</code>, <code>debug()</code>）以降序方式表示不同的严重级别,默认是<code>warning</code>。</p>
<p>下面的是一个自己用的以天为单位的输出日志的函数：</p>
<pre class=" language-lang-python"><code class="language-lang-python">import re
import logging

from logging.handlers import TimedRotatingFileHandler
from logging.handlers import RotatingFileHandler

def log_init(logfile):
    log_fmt = '%(asctime)s\tFile \"%(filename)s\",line %(lineno)s\t%(levelname)s: %(message)s'
    formatter = logging.Formatter(log_fmt)
    # 可以设置间隔时间，这里是一天生成一个文件
    log_file_handler = TimedRotatingFileHandler(filename=logfile, when="D", interval=1, backupCount=7)
    log_file_handler.suffix = "%Y-%m-%d.log"
    # filehanlder.suffix的格式必须这么写，才能自动删除旧文件
    # 如果设定是天，就必须写成“%Y-%m-%d.log”，写成其他格式会导致删除旧文件不生效

    log_file_handler.setFormatter(formatter)
    # log_file_handler.setLevel(logging.DEBUG)
    logging.getLogger().setLevel(logging.DEBUG)
    logging.getLogger().addHandler(log_file_handler)
    '''
    这里是需要运行的程序，需要按照文件格式删除log文件，需要启用 extMatch、removeHandle函数
    '''
    # logging.info('this is a loggging info message')
    # logging.debug('this is a loggging debug message')
    # logging.warning('this is loggging a warning message')
    # logging.error('this is an loggging error message')
    # logging.critical('this is a loggging critical message')
</code></pre>
<p>修改所调用的模块中的日志设置：</p>
<pre class=" language-lang-python"><code class="language-lang-python"># somelib.py
import logging

log = logging.getLogger(__name__) # 默认就是： __name__ 只的当前的模块
log.addHandler(logging.NullHandler())
# Example function (for testing)
def func():
    log.critical('A Critical Error!')
    log.debug('A debug message')
</code></pre>
<p>下面我们调用这个模块：</p>
<pre class=" language-lang-python"><code class="language-lang-python">>>> import logging
# 这是当前脚本的日志设置
>>> logging.basicConfig(level=logging.ERROR)
>>> import somelib
>>> somelib.func()
CRITICAL:somelib:A Critical Error!
>>> # 指定模块名，改变该模块的输出级别
>>> logging.getLogger('somelib').level=logging.DEBUG
>>> somelib.func()
CRITICAL:somelib:A Critical Error!
DEBUG:somelib:A debug message
>>>
</code></pre>
<p>在这里，根日志被配置成仅仅输出<code>ERROR</code> 或更高级别的消息。不过，<code>somelib</code> 的日志级别被单独配置成可以输出debug 级别的消息，它的优先级比全局配置高。像这<br>样更改单独模块的日志配置对于调试来讲是很方便的，因为你无需去更改任何的全局日志配置——只需要修改你想要更多输出的模块的日志等级。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/python3/">python3</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/编程语言/">编程语言</a><a href="/tags/python3/">python3</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/07/python3cook-xi-lie-bi-ji-liu/"><span>python3 cookbook笔记：第四章 文件与IO</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/07/python3cook-xi-lie-bi-ji-liu/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-06T16:00:00.000Z">
          2018-11-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>所有程序都要处理输入和输出。这一章将涵盖处理不同类型的文件，包括文本和二进制文件，文件编码和其他相关的内容。对文件名和目录的操作也会涉及到。</p>
<p>文本打开模式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">t</td>
<td style="text-align:left">文本模式(默认)</td>
</tr>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:left">以只读方式打开文件。这是默认模式。</td>
</tr>
<tr>
<td style="text-align:center">rb</td>
<td style="text-align:left">读取二进制文件</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td style="text-align:left">写入文件</td>
</tr>
<tr>
<td style="text-align:center">wb</td>
<td style="text-align:left">写入二进制到文件中</td>
</tr>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:left">追加形式写入文件</td>
</tr>
<tr>
<td style="text-align:center">w+</td>
<td style="text-align:left">打开文件用于读写，文件指针在开始</td>
</tr>
<tr>
<td style="text-align:center">a+</td>
<td style="text-align:left">打开文件用于读写，追加模式</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>open()</code> 函数默认是以”utf-8“编码打开文件，<code>encoding</code>参数可以指定编码：</li>
</ul>
<pre class=" language-lang-python"><code class="language-lang-python">with open('somefile.txt', 'rt', encoding='latin-1') as f:
    ...
</code></pre>
<p><em>ps:我们都指定写入文件是用的<code>f.write()</code>,但是<code>print()</code>函数也可以指定<code>file</code>参数来输出内容到文件中：</em></p>
<pre class=" language-lang-python"><code class="language-lang-python">with open('d:/work/test.txt', 'wt') as f:
    print('Hello World!', file=f)
</code></pre>
<p><code>newline</code>参数可以指定行分隔符。默认情况下，Python 会以统一模式处理换行符(，在Unix 和Windows 中是不一样的,分别是\n 和\r\n ):</p>
<pre class=" language-lang-python"><code class="language-lang-python">with open('somefile.txt', 'rt', newline='') as f:
    ...
</code></pre>
<ul>
<li>读写一个gzip 或bz2 格式的压缩文件，跟普通读写差别不是很大，直接看示例就好。</li>
</ul>
<p>读取压缩文件：</p>
<pre class=" language-lang-python"><code class="language-lang-python"># gzip compression
import gzip
with gzip.open('somefile.gz', 'rt') as f:
    text = f.read()
# bz2 compression
import bz2
with bz2.open('somefile.bz2', 'rt') as f:
    text = f.read()
</code></pre>
<p>写入压缩文件：</p>
<pre class=" language-lang-python"><code class="language-lang-python">with gzip.open('somefile.gz', 'wt', compresslevel=5) as f:
f.write(text)
</code></pre>
<p><code>compresslevel</code>参数是指定压缩级别，默认的等级是9，也是最高的压缩等级。等级越低性能越好，但是数据压缩程度也越低。</p>
<ul>
<li>获取固定长度，而不是一行一行迭代：</li>
</ul>
<pre class=" language-lang-python"><code class="language-lang-python">from functools import partial
RECORD_SIZE = 32

with open('somefile.data', 'rb') as f:
    records = iter(partial(f.read, RECORD_SIZE), b'')
    for r in records:
        ...
</code></pre>
<ul>
<li>本章也介绍了<code>os.path</code>模块的使用，请参见<strong>python3标准库系列笔记</strong></li>
<li>创建临时文件和文件夹，使用完以后会自动销毁：</li>
</ul>
<pre class=" language-lang-python"><code class="language-lang-python">from tempfile import TemporaryFile
# 创建临时文件
with TemporaryFile('w+t') as f:
    # Read/write to the file
    f.write('Hello World\n')
    f.write('Testing\n')

    # 回到文件开始，读取文件
    f.seek(0)
    data = f.read()
</code></pre>
<p>或者：</p>
<pre class=" language-lang-python"><code class="language-lang-python">f = TemporaryFile('w+t')
# Use the temporary file
...
f.close()
# File is destroyed
</code></pre>
<p>在大多数Unix 系统上，通过<code>TemporaryFile()</code> 创建的文件都是匿名的，甚至连目录都没有。如果你想打破这个限制，可以使用<code>NamedTemporaryFile()</code> 来代替。比如：</p>
<pre class=" language-lang-python"><code class="language-lang-python">from tempfile import NamedTemporaryFile
with NamedTemporaryFile('w+t') as f:
    print('filename is:', f.name)
    ...
# File automatically destroyed
</code></pre>
<p>这里，被打开文件的<code>f.name</code> 属性包含了该临时文件的文件名。当你需要将文件<br>名传递给其他代码来打开这个文件的时候，这个就很有用了。和<code>TemporaryFile()</code> 一样，结果<strong>文件关闭</strong>时会被自动删除掉。如果你不想这么做，可以传递一个关键字参数<code>delete=False</code> 即可。比如：</p>
<pre><code>with NamedTemporaryFile(&#39;w+t&#39;, delete=False) as f:
    print(&#39;filename is:&#39;, f.name)
    ...
</code></pre><p>为了创建一个临时目录，可以使用<code>tempfile.TemporaryDirectory()</code> 。比如：</p>
<pre class=" language-lang-python"><code class="language-lang-python">from tempfile import TemporaryDirectory

with TemporaryDirectory() as dirname:
    print('dirname is:', dirname)
    # Use the directory
    ...
# Directory and all contents destroyed
</code></pre>
<ul>
<li>序列化Python 对象</li>
</ul>
<p>以下内容来源于廖老师的<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener"><strong>python教程</strong></a>,非常感谢廖老师出了如此优秀的入门教程</p>
<p>在程序运行的过程中，所有的变量都是在内存中，比如，定义一个<code>dict</code>：</p>
<pre class=" language-lang-python"><code class="language-lang-python">d = dict(name='Bob', age=20, score=88)
</code></pre>
<p>可以随时修改变量，比如把<code>name</code>改成<code>&#39;Bill&#39;</code>，但是一旦程序结束，变量所占用的内存就被操作系统全部回收。如果没有把修改后的<code>&#39;Bill&#39;</code>存储到磁盘上，下次重新运行程序，变量又被初始化为<code>&#39;Bob&#39;</code>。</p>
<p>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫<code>pickling</code>，在其他语言中也被称之为<code>serialization</code>，<code>marshalling</code>，<code>flattening</code>等等，都是一个意思。</p>
<p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p>
<p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即<code>unpickling</code>。</p>
<p>Python提供两个模块来实现序列化：<code>cPickle</code>和<code>pickle</code>。这两个模块功能是一样的，区别在于<code>cPickle</code>是C语言写的，速度快，<code>pickle</code>是纯Python写的，速度慢，跟<code>cStringIO</code>和<code>StringIO</code>一个道理。用的时候，先尝试导入<code>cPickle</code>，如果失败，再导入<code>pickle</code>：</p>
<pre class=" language-lang-python"><code class="language-lang-python">try:
    import cPickle as pickle
except ImportError:
    import pickle
</code></pre>
<p>首先，我们尝试把一个对象序列化并写入文件：</p>
<pre class=" language-lang-python"><code class="language-lang-python">>>> d = dict(name='Bob', age=20, score=88)
>>> pickle.dumps(d)
"(dp0\nS'age'\np1\nI20\nsS'score'\np2\nI88\nsS'name'\np3\nS'Bob'\np4\ns."
</code></pre>
<p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>str</code>，然后，就可以把这个<code>str</code>写入文件。或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个<code>file-like Object</code>：</p>
<pre class=" language-lang-python"><code class="language-lang-python">>>> f = open('dump.txt', 'wb')
>>> pickle.dump(d, f)
>>> f.close()
</code></pre>
<p>看看写入的<code>dump.txt</code>文件，一堆乱七八糟的内容，这些都是Python保存的对象内部信息。</p>
<p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个<code>str</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象。我们打开另一个Python命令行来反序列化刚才保存的对象：</p>
<pre class=" language-lang-python"><code class="language-lang-python">>>> f = open('dump.txt', 'rb')
>>> d = pickle.load(f)
>>> f.close()
>>> d
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<p>变量的内容又回来了！</p>
<p>当然，这个变量和原来的变量是完全不相干的对象，它们只是内容相同而已。</p>
<p><em>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</em></p>
<p>为了从字节流中恢复一个对象，使用<code>picle.load()</code> 或<code>pickle.loads()</code> 函数。比如：</p>
<pre class=" language-lang-python"><code class="language-lang-python"># Restore from a file
f = open('somefile', 'rb')
data = pickle.load(f)
# Restore from a string
data = pickle.loads(s)
</code></pre>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/python3/">python3</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/编程语言/">编程语言</a><a href="/tags/python3/">python3</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/07/python3-biao-zhun-ku-xi-lie-er-argparse/"><span>python3 标准库系列(二)---argparse 模块</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/07/python3-biao-zhun-ku-xi-lie-er-argparse/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-06T16:00:00.000Z">
          2018-11-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><code>argparse</code> 模块是标准库中最大的模块之一，拥有大量的配置选项，本章只列出了一些常用的选项：</p>
<pre class=" language-lang-python"><code class="language-lang-python">import argparse

parser = argparse.ArgumentParser(description='Search some files')

parser.add_argument(dest='filenames',metavar='filename', nargs='*')

parser.add_argument('-p', '--pat',metavar='pattern', required=True,dest='patterns', action='append',    help='text pattern to search for')

parser.add_argument('-v', dest='verbose', action='store_true',help='verbose mode')

parser.add_argument('-o', dest='outfile', action='store',help='output file')
parser.add_argument('--speed', dest='speed', action='store',choices={'slow','fast'}, default='slow',help='search speed')

args = parser.parse_args()
# 使用方法
print(args.filenames)
print(args.patterns)
print(args.verbose)
print(args.outfile)
print(args.speed)
</code></pre>
<p>为了解析命令行选项， 你首先要创建一个<code>ArgumentParser</code> 实例，并使用<code>add_argument()</code>方法声明你想要支持的选项。</p>
<p>在每个<code>add_argument()</code> 调用中，</p>
<ul>
<li><p><code>dest</code>参数指定解析结果被指派给属性的名字。</p>
</li>
<li><p><code>metavar</code> 参数被用来生成帮助信息(<code>metavar</code>仅更改显示的名称，<code>parse_args()</code>对象上属性的名称仍由<code>dest</code>值确定)。</p>
</li>
<li><p><code>action</code>参数指定跟属性对应的处理逻辑，通常的值为<code>store</code> , 被用来存储某个值或将多个参数值收集到一个列表中。其他参数：<code>store_true</code>,<code>store_false</code>:</p>
</li>
</ul>
<pre class=" language-lang-python"><code class="language-lang-python">>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', action='store_true')
>>> parser.add_argument('--bar', action='store_false')
>>> parser.add_argument('--baz', action='store_false')
>>> parser.parse_args('--foo --bar'.split())
Namespace(foo=True, bar=False, baz=True)
</code></pre>
<p>下面的参数收集所有剩余的命令行参数到一个列表中。在本例中它被用来构造一个文件名列表：</p>
<pre class=" language-lang-python"><code class="language-lang-python">parser.add_argument(dest='filenames',metavar='filename', nargs='*')
</code></pre>
<p>下面的参数根据参数是否存在来设置一个Boolean 标志：</p>
<pre class=" language-lang-python"><code class="language-lang-python">parser.add_argument('-v', dest='verbose', action='store_true',help='verbose mode')
</code></pre>
<p>下面的参数接受一个单独值并将其存储为一个字符串：</p>
<pre class=" language-lang-python"><code class="language-lang-python">parser.add_argument('-o', dest='outfile', action='store',help='output file')
</code></pre>
<ul>
<li><p>如果要接收多个值，可以使用<code>nargs</code>参数，其支持的值有：</p>
<ul>
<li>N  (整数), 检测命令行的该参数值的个数，只接收N个值</li>
<li>* , 也就是说参数可以接收任意个数值</li>
<li>+,  与‘*’ 一样，但是如果少于一个值，会生成错误信息，有点像通配符</li>
<li>？，如果传入了参数就使用参数给定的值，如果没有，就用默认值,这个需要设置默认值</li>
<li><code>argparse.REMAINDER</code>所有剩余的命令行参数都收集到一个列表中:</li>
</ul>
</li>
</ul>
<pre class=" language-lang-python"><code class="language-lang-python">>>> parser = argparse.ArgumentParser(prog='PROG')
>>> parser.add_argument('--foo')
>>> parser.add_argument('command')
>>> parser.add_argument('args', nargs=argparse.REMAINDER)
>>> print(parser.parse_args('--foo B cmd --arg1 XX ZZ'.split()))
Namespace(args=['--arg1', 'XX', 'ZZ'], command='cmd', foo='B')
</code></pre>
<ul>
<li>下面的参数说明接受一个值，但是会将其和可能的选择值做比较，以检测其合法性：</li>
</ul>
<pre class=" language-lang-python"><code class="language-lang-python">parser.add_argument('--speed', dest='speed', action='store',choices={'slow','fast'}, default='slow',help='search speed')
</code></pre>
<p>也就是说只能选择<code>choices</code>参数中的值，否则会报错</p>
<p>其他一些参数：</p>
<ul>
<li><code>default</code>: 设置默认值</li>
<li><code>type</code>: 设置接收的内置类型，如<code>float</code>或<code>int</code>,(常见的内置类型和<strong>函数</strong>可以直接用作type参数的值)</li>
</ul>
<pre class=" language-lang-python"><code class="language-lang-python">>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('foo', type=int)
>>> parser.add_argument('bar', type=open)
>>> parser.parse_args('2 temp.txt'.split())
Namespace(bar=<_io.TextIOWrapper name='temp.txt' encoding='UTF-8'>, foo=2)
</code></pre>
<ul>
<li><code>required</code>: 设置为必须参数</li>
</ul>
<p><code>ArgumentParser.add_argument_group</code>可以参数设置分组：</p>
<pre class=" language-lang-python"><code class="language-lang-python">>>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)
>>> group = parser.add_argument_group('group')
>>> group.add_argument('--foo', help='foo help')
>>> group.add_argument('bar', help='bar help')
>>> parser.print_help()
usage: PROG [--foo FOO] bar

group:
  bar    bar help
  --foo FOO  foo help
</code></pre>
<pre class=" language-lang-python"><code class="language-lang-python">>>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)
>>> group1 = parser.add_argument_group('group1', 'group1 description')
>>> group1.add_argument('foo', help='foo help')
>>> group2 = parser.add_argument_group('group2', 'group2 description')
>>> group2.add_argument('--bar', help='bar help')
>>> parser.print_help()
usage: PROG [--bar BAR] foo

group1:
  group1 description

  foo    foo help

group2:
  group2 description

  --bar BAR  bar help
</code></pre>
<ul>
<li><code>ArgumentParser.add_mutually_exclusive_group(required=False)</code> 可以设置一组互斥的参数组，即在该组中参数只能选零个或一个,当<code>required=True</code>时，标准该参数组必须选组中的一个参数：</li>
</ul>
<pre class=" language-lang-python"><code class="language-lang-python">>>> parser = argparse.ArgumentParser(prog='PROG')
>>> group = parser.add_mutually_exclusive_group(required=True)
>>> group.add_argument('--foo', action='store_true')
>>> group.add_argument('--bar', action='store_false')
>>> parser.parse_args([]) 
# 如果required=False,那么这里不会报错
# Namespace(bar=True, foo=False)
usage: PROG [-h] (--foo | --bar)
PROG: error: one of the arguments --foo --bar is required
</code></pre>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/python3/">python3</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/编程语言/">编程语言</a><a href="/tags/python3/">python3</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/07/python3-biao-zhun-ku-xi-lie-san-os.path/"><span>python3 标准库系列(三)---os.path</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/07/python3-biao-zhun-ku-xi-lie-san-os.path/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-06T16:00:00.000Z">
          2018-11-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><code>os.path</code>模块比较简单，先记住下面这些常用的用就可以了：</p>
<pre class=" language-lang-python"><code class="language-lang-python">>>> import os
>>> path = '/Users/beazley/Data/data.csv'
>>> # 获取文件名
>>> os.path.basename(path)
'data.csv'
>>> # 获取文件所在目录名
>>> os.path.dirname(path)
'/Users/beazley/Data'
>>> # 多个元素拼接成一个链接
>>> os.path.join('tmp', 'data', os.path.basename(path))
'tmp/data/data.csv'
>>> # 将家目录符号~换成真实链接
>>> path = '~/Data/data.csv'
>>> os.path.expanduser(path)
'/Users/beazley/Data/data.csv'
>>> # 获取文件扩展名
>>> os.path.splitext(path)
('~/Data/data', '.csv')
>>># 检查文件或目录是否存在
>>> os.path.exists('/etc/passwd')
True
>>> # 检测是不是文件类型
>>> os.path.isfile('/etc/passwd')
True
>>> # 检测是不是目录类型
>>> os.path.isdir('/etc/passwd')
False
>>> # 检测是不是符号链接
>>> os.path.islink('/usr/local/bin/python3')
True
>>> # 返回一个绝对路径
>>> os.path.realpath('/usr/local/bin/python3')
'/usr/local/bin/python3.3'
>>># 获取文件大小
>>> os.path.getsize('/etc/passwd')
3669
>>> # 获取文件修改日期
>>> os.path.getmtime('/etc/passwd')
1272478234.0
>>> import time
>>> time.ctime(os.path.getmtime('/etc/passwd'))
'Wed Apr 28 13:10:34 2010'
>>> # 获取指定目录下的文件列表 
>>>os.listdir('somedir')
</code></pre>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/python3/">python3</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/编程语言/">编程语言</a><a href="/tags/python3/">python3</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/05/python3cook-xi-lie-bi-ji-wu/"><span>python3 cookbook笔记：第四章 迭代器与生成器</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/05/python3cook-xi-lie-bi-ji-wu/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-04T16:00:00.000Z">
          2018-11-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>可迭代对象是一个比较新的词汇，而迭代是Python 最强大的功能之一。初看起来，你可能会简单的认为迭代只不过是处理序列中元素的一种方法。然而，绝非仅仅就是如此，还有很多你可能不知道的，比如创建你自己的迭代器对象，在itertools 模块中使用有用的迭代模式，构造生成器函数等等。</p>
<ol>
<li><p>使用<code>next()</code>可以实现手动手动迭代，其实任何迭代内部都是调用了<code>__next__()</code>方法迭代结束标识是在结尾处捕获了<code>StopIteration</code></p>
</li>
<li><p><code>yield</code> 语句可是创建一个可迭代对象</p>
</li>
<li><p>函数<code>itertools.islice()</code>用于在迭代器和生成器上做切片操作:</p>
<pre class=" language-lang-python"><code class="language-lang-python">     >>> def count(n):
 ...         while True:
 ...             yield n
 ...             n += 1
 ...
 >>> c = count(0)
 >>> c[10:20]
 Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
 TypeError: 'generator' object is not subscriptable
 >>> # Now using islice()
 >>> import itertools
 >>> for x in itertools.islice(c, 10, 20):
 ... print(x)
 ...
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 >>>
</code></pre>
<p> 迭代器和生成器不能使用标准的切片操作，因为它们的长度事先我们并不知道(并且也没有实现索引)。函数islice() 返回一个可以生成指定元素的迭代器，它通过遍<br>历并丢弃直到切片开始索引位置的所有元素。然后才开始一个个的返回元素，并直到切片结束索引位置。<br> 这里要着重强调的一点是islice() 会消耗掉传入的迭代器中的数据。必须考虑到迭代器是不可逆的这个事实。所以如果你需要之后再次访问这个迭代器的话，那你就得<br>先将它里面的数据放入一个列表中。</p>
</li>
<li><p><code>itertools.dropwhile()</code> 函数,你给它传递一个函数对象和一个可迭代对象。它会返回一个迭代器对象，丢弃原有序列中直到函数返回Flase 之前的所有元素，然后返回后<br>面所有元素。</p>
</li>
<li><p><strong>排列组合的迭代：</strong>迭代遍历一个集合中元素的所有可能的排列或组合。<br><code>itertools.permutations()</code>函数接受一个集合并产生一个元组序列，序列包括了集合中所有的排列组合(顺序不同也算是一种组合)：</p>
<pre class=" language-lang-python"><code class="language-lang-python"> >>> items = ['a', 'b', 'c']
 >>> from itertools import permutations
 >>> for p in permutations(items):
 ... print(p)
 ...
 ('a', 'b', 'c')
 ('a', 'c', 'b')
 ('b', 'a', 'c')
 ('b', 'c', 'a')
 ('c', 'a', 'b')
 ('c', 'b', 'a')
 >>>
</code></pre>
<p> 如果你想得到指定长度的所有排列，你可以传递一个可选的长度参数:</p>
<pre class=" language-lang-python"><code class="language-lang-python"> >>> for p in permutations(items, 2):
 ... print(p)
 ...
 ('a', 'b')
 ('a', 'c')
 ('b', 'a')
 ('b', 'c')
 ('c', 'a')
 ('c', 'b')
 >>>
</code></pre>
<p> <code>itertools.combinations()</code>函数也是返回排列组合，但是忽略顺序，即，组合(‘a’,’b’) 跟(‘b’, ‘a’)</p>
</li>
<li><p>内置的<code>enumerate() 函数</code>返回索引跟对应的元素</p>
</li>
<li><p><code>zip()</code> 函数可以同时迭代多喝序列：</p>
<pre class=" language-lang-python"><code class="language-lang-python"> >>> xpts = [1, 5, 4, 2, 10, 7]
 >>> ypts = [101, 78, 37, 15, 62, 99]
 >>> for x, y in zip(xpts, ypts):
 ...     print(x,y)
 ...
 1 101
 5 78
 4 37
 2 15
 10 62
 7 99
 >>>
</code></pre>
</li>
<li><p><code>isinstance(x, Iterable)</code> 检查某个元素是否是可迭代的</p>
</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/python3/">python3</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/编程语言/">编程语言</a><a href="/tags/python3/">python3</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/02/python3-biao-zhun-ku-xi-lie-yi-email/"><span>python3 标准库系列(一)---email模块</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/02/python3-biao-zhun-ku-xi-lie-yi-email/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-01T16:00:00.000Z">
          2018-11-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>自己写的一个发邮件的类，自己用的时候，省的自己再到处翻教程</p>
<pre class=" language-lang-Python"><code class="language-lang-Python">
#-*-coding:utf-8-*-

import smtplib
import sys
import re
import os

from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.image import MIMEImage
from email import encoders
from email.header import Header
from email.utils import parseaddr, formataddr

'''
发送邮件：
文本，网页，附件，图片
'''

class Sendemail():


    def __init__(self,mailToList,mailHost,mailUser,mailPass,sub):
        self.mailToList = mailToList  # 邮件接收方的邮件地址，传入的必须是list类型
        self.mailHost = mailHost    # 邮件传送协议服务器: smtp.qiye.163.com
        self.mailUser = mailUser  # 邮件发送方的邮箱账号: xxxx@xxxx.org
        self.mailPass = mailPass  # 邮件发送方的邮箱密码: ****
        self.sub = sub # 邮件名
        #self.content = content # 内容
        #self.subtype = subtype # 发送类型 plain(文字)

    def _formatAddr(self,s):
        '''
            处理发件人的名字，防止有带中文名的发件人
        '''
        name, addr = parseaddr(s)
        return formataddr((Header(name, 'utf-8').encode(), addr))

    def sendEmail(self,content,subtype):
        msg = MIMEMultipart('mixed') #　默认就是　mixed类型
        me = re.split('@',self.mailUser)[0]+"<"+self.mailUser+">"
        msg['Subject'] = self.sub
        msg['From'] = self._formatAddr(me)
        msg['To'] = ','.join(self.mailToList)  # 多个收件人以“,”分隔
        text = MIMEText(content, _subtype=subtype, _charset='utf-8')
        msg.attach(text)

        try:
            server = smtplib.SMTP()
            server.connect(self.mailHost)
            server.login(self.mailUser, self.mailPass)
            server.sendmail(me, self.mailToList, msg.as_string())
            server.quit()
            print("发送成功")
            return True
        except Exception as e:
            print (e)
            return False


    def sendFile(self,file):
        '''
        发送附件'''
        msg = MIMEMultipart('mixed') #　默认就是　mixed类型
        me = re.split('@',self.mailUser)[0]+"<"+self.mailUser+">"
        msg['Subject'] = self.sub
        msg['From'] = self._formatAddr(me)
        msg['To'] = ','.join(self.mailToList)

        sendfile=open(file,'rb').read()
        text_att = MIMEText(sendfile, 'base64', 'utf-8') 
        text_att["Content-Type"] = 'application/octet-stream'  
        # 设置附件名字，如果是windows下的中文文件名需要以gbk编码，这里默认是再Linux上的中文名字的文件
        text_att.add_header('Content-Disposition', 'attachment', filename=("utf-8", "",os.path.basename(file)))
        #return text_att

        msg.attach(text_att)
        try:
            server = smtplib.SMTP()
            server.connect(self.mailHost)
            server.login(self.mailUser, self.mailPass)
            server.sendmail(me, self.mailToList, msg.as_string())
            server.quit()
            print("发送成功")
            return True
        except Exception as e:
            print (e)
            return False


def main():

    mailToList = ["xxx@xx.com","xxx@xxx.com"]  # 邮件接收方的邮件地址，传入的必须是list类型
    mailHost = "smtp.qiye.163.com"    # 邮件传送协议服务器: smtp.qiye.163.com
    mailUser = "xxx@xxx.com"  # 邮件发送方的邮箱账号: xxxx@xxxx.com
    mailPass = "xxxx"  # 邮件发送方的邮箱密码: ****
    sub = "测试邮件" # 邮件名
    s = Sendemail(mailToList,mailHost,mailUser,mailPass,sub)
    #content  内容/文件路径
    #subtype  发送类型 plain(文字) html(网页) 正文图片(目前只能实现插入一张图) 附件
    content = "test"
    subtype = "plain"
    # 如果发送的是附件用这个函数，暂时不支持邮件正文中发图片，因为比较麻烦，就是把图片插入网页格式中
    s.sendFile("filepath")

if __name__ == '__main__':
    main()
</code></pre>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/python3/">python3</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/编程语言/">编程语言</a><a href="/tags/python3/">python3</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/2/" class="pagination-prev">上一页</a>
  
  
  <a href="/page/4/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2019 Naruto
    
  </p>
</footer>
    
  </div>
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>