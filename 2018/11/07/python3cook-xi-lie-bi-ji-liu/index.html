<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>python3 cookbook笔记：第四章 文件与IO | 木叶村 | life is short</title>

  
  <meta name="author" content="Naruto">
  

  
  <meta name="description" content="无人为孤岛，一书一世界">
  

  
  
  <meta name="keywords" content="编程语言,python3">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="python3 cookbook笔记：第四章 文件与IO"/>

  <meta property="og:site_name" content="木叶村"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="木叶村" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">木叶村</a>
    </h1>
    <p class="site-description">life is short</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>python3 cookbook笔记：第四章 文件与IO</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/07/python3cook-xi-lie-bi-ji-liu/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-06T16:00:00.000Z">
          2018-11-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>所有程序都要处理输入和输出。这一章将涵盖处理不同类型的文件，包括文本和二进制文件，文件编码和其他相关的内容。对文件名和目录的操作也会涉及到。</p>
<p>文本打开模式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">t</td>
<td style="text-align:left">文本模式(默认)</td>
</tr>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:left">以只读方式打开文件。这是默认模式。</td>
</tr>
<tr>
<td style="text-align:center">rb</td>
<td style="text-align:left">读取二进制文件</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td style="text-align:left">写入文件</td>
</tr>
<tr>
<td style="text-align:center">wb</td>
<td style="text-align:left">写入二进制到文件中</td>
</tr>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:left">追加形式写入文件</td>
</tr>
<tr>
<td style="text-align:center">w+</td>
<td style="text-align:left">打开文件用于读写，文件指针在开始</td>
</tr>
<tr>
<td style="text-align:center">a+</td>
<td style="text-align:left">打开文件用于读写，追加模式</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>open()</code> 函数默认是以”utf-8“编码打开文件，<code>encoding</code>参数可以指定编码：</li>
</ul>
<pre class=" language-lang-python"><code class="language-lang-python">with open('somefile.txt', 'rt', encoding='latin-1') as f:
    ...
</code></pre>
<p><em>ps:我们都指定写入文件是用的<code>f.write()</code>,但是<code>print()</code>函数也可以指定<code>file</code>参数来输出内容到文件中：</em></p>
<pre class=" language-lang-python"><code class="language-lang-python">with open('d:/work/test.txt', 'wt') as f:
    print('Hello World!', file=f)
</code></pre>
<p><code>newline</code>参数可以指定行分隔符。默认情况下，Python 会以统一模式处理换行符(，在Unix 和Windows 中是不一样的,分别是\n 和\r\n ):</p>
<pre class=" language-lang-python"><code class="language-lang-python">with open('somefile.txt', 'rt', newline='') as f:
    ...
</code></pre>
<ul>
<li>读写一个gzip 或bz2 格式的压缩文件，跟普通读写差别不是很大，直接看示例就好。</li>
</ul>
<p>读取压缩文件：</p>
<pre class=" language-lang-python"><code class="language-lang-python"># gzip compression
import gzip
with gzip.open('somefile.gz', 'rt') as f:
    text = f.read()
# bz2 compression
import bz2
with bz2.open('somefile.bz2', 'rt') as f:
    text = f.read()
</code></pre>
<p>写入压缩文件：</p>
<pre class=" language-lang-python"><code class="language-lang-python">with gzip.open('somefile.gz', 'wt', compresslevel=5) as f:
f.write(text)
</code></pre>
<p><code>compresslevel</code>参数是指定压缩级别，默认的等级是9，也是最高的压缩等级。等级越低性能越好，但是数据压缩程度也越低。</p>
<ul>
<li>获取固定长度，而不是一行一行迭代：</li>
</ul>
<pre class=" language-lang-python"><code class="language-lang-python">from functools import partial
RECORD_SIZE = 32

with open('somefile.data', 'rb') as f:
    records = iter(partial(f.read, RECORD_SIZE), b'')
    for r in records:
        ...
</code></pre>
<ul>
<li>本章也介绍了<code>os.path</code>模块的使用，请参见<strong>python3标准库系列笔记</strong></li>
<li>创建临时文件和文件夹，使用完以后会自动销毁：</li>
</ul>
<pre class=" language-lang-python"><code class="language-lang-python">from tempfile import TemporaryFile
# 创建临时文件
with TemporaryFile('w+t') as f:
    # Read/write to the file
    f.write('Hello World\n')
    f.write('Testing\n')

    # 回到文件开始，读取文件
    f.seek(0)
    data = f.read()
</code></pre>
<p>或者：</p>
<pre class=" language-lang-python"><code class="language-lang-python">f = TemporaryFile('w+t')
# Use the temporary file
...
f.close()
# File is destroyed
</code></pre>
<p>在大多数Unix 系统上，通过<code>TemporaryFile()</code> 创建的文件都是匿名的，甚至连目录都没有。如果你想打破这个限制，可以使用<code>NamedTemporaryFile()</code> 来代替。比如：</p>
<pre class=" language-lang-python"><code class="language-lang-python">from tempfile import NamedTemporaryFile
with NamedTemporaryFile('w+t') as f:
    print('filename is:', f.name)
    ...
# File automatically destroyed
</code></pre>
<p>这里，被打开文件的<code>f.name</code> 属性包含了该临时文件的文件名。当你需要将文件<br>名传递给其他代码来打开这个文件的时候，这个就很有用了。和<code>TemporaryFile()</code> 一样，结果<strong>文件关闭</strong>时会被自动删除掉。如果你不想这么做，可以传递一个关键字参数<code>delete=False</code> 即可。比如：</p>
<pre><code>with NamedTemporaryFile(&#39;w+t&#39;, delete=False) as f:
    print(&#39;filename is:&#39;, f.name)
    ...
</code></pre><p>为了创建一个临时目录，可以使用<code>tempfile.TemporaryDirectory()</code> 。比如：</p>
<pre class=" language-lang-python"><code class="language-lang-python">from tempfile import TemporaryDirectory

with TemporaryDirectory() as dirname:
    print('dirname is:', dirname)
    # Use the directory
    ...
# Directory and all contents destroyed
</code></pre>
<ul>
<li>序列化Python 对象</li>
</ul>
<p>以下内容来源于廖老师的<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener"><strong>python教程</strong></a>,非常感谢廖老师出了如此优秀的入门教程</p>
<p>在程序运行的过程中，所有的变量都是在内存中，比如，定义一个<code>dict</code>：</p>
<pre class=" language-lang-python"><code class="language-lang-python">d = dict(name='Bob', age=20, score=88)
</code></pre>
<p>可以随时修改变量，比如把<code>name</code>改成<code>&#39;Bill&#39;</code>，但是一旦程序结束，变量所占用的内存就被操作系统全部回收。如果没有把修改后的<code>&#39;Bill&#39;</code>存储到磁盘上，下次重新运行程序，变量又被初始化为<code>&#39;Bob&#39;</code>。</p>
<p>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫<code>pickling</code>，在其他语言中也被称之为<code>serialization</code>，<code>marshalling</code>，<code>flattening</code>等等，都是一个意思。</p>
<p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p>
<p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即<code>unpickling</code>。</p>
<p>Python提供两个模块来实现序列化：<code>cPickle</code>和<code>pickle</code>。这两个模块功能是一样的，区别在于<code>cPickle</code>是C语言写的，速度快，<code>pickle</code>是纯Python写的，速度慢，跟<code>cStringIO</code>和<code>StringIO</code>一个道理。用的时候，先尝试导入<code>cPickle</code>，如果失败，再导入<code>pickle</code>：</p>
<pre class=" language-lang-python"><code class="language-lang-python">try:
    import cPickle as pickle
except ImportError:
    import pickle
</code></pre>
<p>首先，我们尝试把一个对象序列化并写入文件：</p>
<pre class=" language-lang-python"><code class="language-lang-python">>>> d = dict(name='Bob', age=20, score=88)
>>> pickle.dumps(d)
"(dp0\nS'age'\np1\nI20\nsS'score'\np2\nI88\nsS'name'\np3\nS'Bob'\np4\ns."
</code></pre>
<p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>str</code>，然后，就可以把这个<code>str</code>写入文件。或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个<code>file-like Object</code>：</p>
<pre class=" language-lang-python"><code class="language-lang-python">>>> f = open('dump.txt', 'wb')
>>> pickle.dump(d, f)
>>> f.close()
</code></pre>
<p>看看写入的<code>dump.txt</code>文件，一堆乱七八糟的内容，这些都是Python保存的对象内部信息。</p>
<p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个<code>str</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象。我们打开另一个Python命令行来反序列化刚才保存的对象：</p>
<pre class=" language-lang-python"><code class="language-lang-python">>>> f = open('dump.txt', 'rb')
>>> d = pickle.load(f)
>>> f.close()
>>> d
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<p>变量的内容又回来了！</p>
<p>当然，这个变量和原来的变量是完全不相干的对象，它们只是内容相同而已。</p>
<p><em>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</em></p>
<p>为了从字节流中恢复一个对象，使用<code>picle.load()</code> 或<code>pickle.loads()</code> 函数。比如：</p>
<pre class=" language-lang-python"><code class="language-lang-python"># Restore from a file
f = open('somefile', 'rb')
data = pickle.load(f)
# Restore from a string
data = pickle.loads(s)
</code></pre>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/python3/">python3</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/编程语言/">编程语言</a><a href="/tags/python3/">python3</a>
    </span>
    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2019 Naruto
    
  </p>
</footer>
    
  </div>
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>